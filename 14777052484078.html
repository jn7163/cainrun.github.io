<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	玩转iOS开发：5.《Core Animation》CALayer的Transforms - Cain For iOS
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Cain For iOS" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="asset/icon.png" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">Cain For iOS</a></h1>
					<p class="subtitle">指弹吉他演奏爱好者, 摄影爱好者, iOS 开发工程师, 如果您有更好的建议或者其他不明白的地方, 可以联系我QQ: 350116542</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">




<a target="_blank" class="linkedin" href="www.linkedin.com/in/cainluo" title="LinkedIn">LinkedIn</a>



<a target="_blank" class="weibo" href="http://weibo.com/1826190094" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com/CainRun" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:zhebushimengfei@qq.com" title="Email">Email</a>

								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">玩转iOS开发：5.《Core Animation》CALayer的Transforms</h1>
		<div class="entry-content" itemprop="articleBody">
			<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>之前我们所了解的<strong>CALayer</strong>都是比较抽象化, 好在<a href="https://cainrun.github.io/14775511877452.html">《Core Animation》CALayer的视觉效果</a>解决我们这些视觉动物的学东西的枯燥, 今天我们就来讲讲<strong>Transforms</strong>, 也就是<strong>CALayer</strong>的<strong>Transforms</strong>.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>CALayer Transforms</strong>讲得是<strong>CALayer</strong>一些我们能够看得见的东西, 这些知识点在我们日常开发中也会有用到的, 比如<strong>Affine Transforms</strong>, <strong>3D Transforms</strong>, <strong>Solid Objects</strong>等等, 待我们一一去讲解.</p>
</blockquote>

<hr/>

<h3 id="toc_2">Affine Transforms</h3>

<blockquote>
<p><strong>Affine Transforms</strong>的中文意思叫做仿射转换, 在前一篇文章的时候我们就使用过<strong>transform</strong>来旋转<strong>UIView</strong>, 但那时候我们只是简单的使用罢了, 并没有说明它的原理.<br/>
<dr/><br/>
实际上<strong>UIView</strong>里的<strong>transform</strong>是<strong>CAAffineTransform</strong>类型, 用于做二维空间的旋转, 缩放, 平移等操作, 而且<strong>CAAffineTransform</strong>可以和一个二维空间的向量, 比如<strong>CGPoint</strong>做<strong>3x2</strong>的矩阵.<br/>
<dr/><br/>
大概的运算原理就是, 用<strong>CGPoint</strong>的每一列和<strong>CGAffineTransform</strong>矩阵的每一列对应的元素进行相乘再求和, 这样子就会形成一个新的<strong>CGPoint</strong>.<br/>
<dr/><br/>
说到这里, 应该会有人有疑惑, <strong>CGAffineTransform</strong>和<strong>CGPoint</strong>完全都不是一样东西, 怎么能做运算呢? 其实并不是的, 当你使用它们两个进行运算的时候, 系统会自动补上一些缺少的元素, 使得<strong>CGAffineTransform</strong>和<strong>CGPoint</strong>进行一一对应, 但运算完之后, 这些填充值就会被抛弃掉, 不会进行保存, 仅仅只是用来做运算罢了.<br/>
<dr/><br/>
所以我们通常遇到的二维变换都是使用<strong>3x3</strong>, 而不是刚刚所说到的<strong>2x3</strong>, 但在某些情况下我们也会遇到<strong>2x3</strong>的格式矩阵, 这就是所谓的以列为主(这个等下用事例来查看吧), 但无论如何都好, 只要能够保持一致, 用什么格式又何妨呢?<br/>
<dr/><br/>
当对图层进行矩阵变换时, 图层矩形内的每一个点都被相应的做变换, 从而形成一个新的四边形的形状, <strong>CGAffineTransform</strong>中的&quot;仿射&quot;的意思是无论你如何去改变矩阵的值, 图层中平行的两条线在变换之后仍然保持平行, 这就是<strong>CGAffineTransform</strong>的&quot;仿射&quot;.</p>
</blockquote>

<h4 id="toc_3">Creating a CGAffineTransform - 创建一个CGAffineTransform</h4>

<blockquote>
<p>其实对矩阵数学的阐述早就超过了<strong>Core Animation</strong>的讨论范围了, 如果你是对矩阵数学一点都不了解的话, 那你就要哭晕在厕所了, 不过还好, <strong>Core Graphics</strong>提供了一系列的<strong>API</strong>, 对完全没有数学基础的开发者来讲也能够做一些简单的变换, 比如:</p>
</blockquote>

<pre><code class="language-objectivec">    CGAffineTransformMakeRotation(CGFloat angle);
    CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);
    CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);
</code></pre>

<blockquote>
<p>在<strong>UIView</strong>可以通过设置<strong>transform</strong>属性进行变换, 但实际上还是对CGLayer进行了一些图层转变的封装.<br/>
<dr/><br/>
<strong>CALayer</strong>同样也有一个<strong>transform</strong>属性, 它叫做<strong>affineTransform</strong>, 但它的类型是<strong>CATransform3D</strong>, 而不是<strong>CGAffineTransform</strong>, 这个后面再解释一下神马是<strong>CATransform3D</strong>.<br/>
<dr/><br/>
直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewTransform {
    
    self.view.backgroundColor = [UIColor grayColor];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    // 旋转
    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);
    imageView.layer.affineTransform = transform;
    
    // 缩放
//    CGAffineTransform scaleTransform = CGAffineTransformMakeScale(0.5, 0.5);
//    imageView.layer.affineTransform = scaleTransform;
    
    // 平移
//    CGAffineTransform translationTransform = CGAffineTransformMakeTranslation(50, 50);
//    imageView.layer.affineTransform = translationTransform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/1.png" alt="1"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/2.png" alt="2"/></p>

<blockquote>
<p>注意一下, 我们在这里使用的是<strong>M_PI_4</strong>, 而不是我们自己输入的神马<strong>45</strong>之类的数字, 因为在<strong>iOS</strong>当中, 使用的的是弧度单位, 而不是角度单位, 弧度用数学常量是表示为<strong>pi</strong>, 一个<strong>pi</strong>就为<strong>180°</strong>, 而四分之一度就是<strong>45°</strong>了.<br/>
<dr/><br/>
但这里会有一个问题, 这些宏都是系统提供给我们的, 如果你要自己去加载更多或者是扩展的话, 可以自己手动去写一个<strong>API</strong>.</p>
</blockquote>

<h4 id="toc_4">Combining Transforms - 混合变换</h4>

<blockquote>
<p><strong>Core Graphics</strong>提供了一系列的API可以在一个<strong>transform</strong>的基础上做更深层次的<strong>transform</strong>, 比如说缩放之后再旋转, 比如下面几个<strong>API</strong>:<br/>
<dr/></p>
</blockquote>

<pre><code class="language-objectivec">    CGAffineTransformRotate(CGAffineTransform t, CGFloat angle);
    CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy);
    CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)
</code></pre>

<blockquote>
<p>当你操纵一个<strong>transform</strong>的时候, 需要先创建一个<strong>CGAffineTransform</strong>类型的空值, 直接把<strong>CGAffineTransformIdentity</strong>赋值过去就好了, 这个称为单位矩阵.<br/>
<dr/><br/>
如果你需要把两个已经写好的<strong>transform</strong>合成为一个的话, 你可以使用系统提供的<strong>API</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);
</code></pre>

<blockquote>
<p>不说那么多废话了, 直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewCombiningTransforms {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    CGAffineTransform transform = CGAffineTransformIdentity;
    
    // 旋转
    transform = CGAffineTransformRotate(transform, M_PI_4);
    // 缩放
    transform = CGAffineTransformScale(transform, 0.5f, 0.5f);
    // 平移
    transform = CGAffineTransformTranslate(transform, 200, 0);
    
    imageView.layer.affineTransform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/3.png" alt="3"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/4.png" alt="4"/></p>

<blockquote>
<p>看到图片的时候, 你会发现结果好像和想象有些差异, 为什么会平移了那么多? 原因是在于当你按顺序做了<strong>transform</strong>, 上一个<strong>transform</strong>会影响到下一个<strong>transform</strong>, 所以平移之后, 你会发现同样被缩放和旋转了, 这就是意味着, 你在旋转之后的平移和平移之后的旋转讲会得到两种不同的结果, 这个大家需要注意一下.</p>
</blockquote>

<hr/>

<h3 id="toc_5">3D Transforms</h3>

<blockquote>
<p>在之前, 我们有提及过<strong>zPosition</strong>这个属性, 可以从用户角度的来让让图层远离或者是靠近,<strong>CATransform</strong>类型的<strong>transform</strong>可以真正做到让图层在<strong>3D</strong>空间内平移或者旋转.<br/>
<dr/><br/>
和<strong>CGAffineTransform</strong>类似,<strong>CATransform3D</strong>也是一个矩阵, 但和之间所说的<strong>2x3</strong>矩阵不一样,<strong>CATransform3D</strong>是一个可以在3D空间内做变换的<strong>4x4</strong>矩阵.<br/>
<dr/><br/>
和<strong>CGAffineTransform</strong>矩阵类似, <strong>Core Animation</strong>也提供了一系列的使用方法, 用来创建和组合<strong>CATransform3D</strong>矩阵, 于<strong>Core Graphics</strong>的函数相比, 也只是在<strong>3D</strong>的平移和旋转中多出了一个<strong>z</strong>参数, 而旋转的API除了有angle参数之外, 还多出了<strong>x</strong>, <strong>y</strong>, <strong>z</strong>等三个参数, 分别决定了每个坐标轴方向上的旋转, 比如:</p>
</blockquote>

<pre><code class="language-objectivec">
CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z);
CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz);
CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz);
</code></pre>

<blockquote>
<p>在之前的文章里, 我们都应该了解了在<strong>iOS</strong>当中, 原点<strong>{0, 0}</strong>是在左上角, <strong>x</strong>轴正方向为右边, <strong>y</strong>轴正方向为下边, 在<strong>Mac OS</strong>当中则是和<strong>iOS</strong>相反, 但是<strong>Z</strong>轴呢, 则是分别和<strong>x</strong>, <strong>y</strong>轴分别垂直, 指向视角外为正方向, 说那么多, 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewTransforms3D {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];

    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/5.png" alt="5"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/6.png" alt="6"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/7.png" alt="7"/></p>

<h4 id="toc_6">Perspective Projection</h4>

<blockquote>
<p>所谓的<strong>Perspective Projection</strong>就是透视投影, 这里需要普及一些知识(虽然我也看不太懂).<br/>
<dr/><br/>
在现实生活中, 当物体远离我们的时候, 会由于视角的问题, 物体看起来会变小, 理论上说远离我们的视图边要比靠近视角边更短, 但实际上, 我们的视角是等距离的, 也就是在<strong>3D Transform</strong>中仍然保持平行, 和之前提到的仿射变换有些类似.<br/>
<dr/><br/>
所以为了做一些修正, 我们需要引入<strong>投影变换</strong>, 又称为<strong>z变换</strong>, 来对一些做了变换的矩阵做一些修改, 旋转的除外, <strong>Core Animation</strong>, 当中并没有给我们提供直接设置透视变换的函数, 所以我们需要手动去修改矩阵值, 但很庆幸的是, 这个修改是很简单的, 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewPerspectiveProjection {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform;
    
    CATransform3D transform3DIdentity = CATransform3DIdentity;
    transform3DIdentity.m34 = - 1.0 / 500.0;
    transform3DIdentity = CATransform3DRotate(transform3DIdentity, M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform3DIdentity;
}
</code></pre>

<blockquote>
<p>在<strong>CATransform3D</strong>中, 有一个<strong>m34</strong>的元素, 它是用于按比例来缩放<strong>X</strong>和<strong>Y</strong>的值, 从而来计算离视角的距离.<br/>
<dr/><br/>
<strong>m34</strong>的默认值为0, 我们可以通过设置<strong>m34</strong>来应用透视效果, 公式是<strong>-1.0/d</strong>, <strong>d</strong>代表了想象中视角相机和屏幕之间的距离, 以像素为单位, 通常设置<strong>500-1000</strong>之间, 但是对于一些特殊视图, 设置的值要小一些, 或者大一些要比<strong>500-1000</strong>要好一些, 所以这些值并不是固定的, 最好是根据需求来调节, 不然会出现湿疹, 或者是失去透视效果.</p>
</blockquote>

<h4 id="toc_7">The Vanishing Point</h4>

<blockquote>
<p><strong>The Vanishing Point</strong>翻译过来叫做<strong>消失点</strong>, 意思是当在透视角度绘图时, 原理视觉角度的物体将会变小变远, 远离到一个极限的时候, 所有物体最后都会汇聚并且消失在同一个点.<br/>
<dr/><br/>
在现实生活中, 这个点通常都是视图的中心, 如果要在应用中创建拟真效果的透视, 这个点一般是在屏幕的重点, 至少是所有3D对象的视图中点.<br/>
<dr/><br/>
在<strong>Core Animation</strong>中, 这个点是位于变换图层的<strong>anchorPoint</strong>(当然也有一些特殊的情况), 也就是说, 当图层发生变换的时候, 这个点永远位于图层变换钱的<strong>anchorPoint</strong>位置.<br/>
<dr/><br/>
当我们改变一个图层的<strong>position</strong>时, 也同时改变了它的消失点, 所以在我们做3D变换的时候要记住.<br/>
<dr/><br/>
当我们去调整视图的<strong>m34</strong>来让视图更加有3D效果, 通常要把它放置在屏幕的中央, 然后通过平移来把它移动到指定的位置, 这样子做, 就可以让所有的3D图层都有同一个消失点.</p>
</blockquote>

<h4 id="toc_8">Sublayer Transform</h4>

<blockquote>
<p>如果在开发中, 我们有多个视图或者多个图层, 而且他们都要做3D变换, 那我们就要对这些视图或者图层每个都设置相同的<strong>m34</strong>值, 并且还要确保在变换钱都在屏幕中央都有一个相同的<strong>position</strong>, 当然, 我们可以自己封装一下, 但这样子也非常的蛋疼, 那该怎么做呢?<br/>
<dr/><br/>
在<strong>CALayer</strong>中有一个属性叫做<strong>sublayerTransform</strong>, 它也是<strong>CATransform3D</strong>类型, 但和我们一个一个的去设置图层不同, 它将会影响所有的子图层, 这就是说明了, 我们只要使用<strong>sublayerTransform</strong>, 就可以一次性的把所有子图层都改变.<br/>
<dr/><br/>
这也可以提供另一个好处, 就是当我们使用<strong>sublayerTransform</strong>属性时, 我们就不需要再对子图层挨个挨个的去设置消失点, 因为消失点将会被设置在容器图层的中心点, 那我们就可以随意设置<strong>position</strong>和<strong>frame</strong>来放置子图层, 还是直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewSublayerTransform {
    
    UIImageView *imageViewOne = [[UIImageView alloc] initWithFrame:CGRectMake(80, 100, 100, 100)];
    
    imageViewOne.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    UIImageView *imageViewTwo = [[UIImageView alloc] initWithFrame:CGRectMake(250, 100, 100, 100)];
    
    imageViewTwo.image = [UIImage imageNamed:@&quot;expression&quot;];

    [self.view addSubview:imageViewOne];
    [self.view addSubview:imageViewTwo];
    
    CATransform3D perspective = CATransform3DIdentity; perspective.m34 = - 1.0 / 500.0;
    
    self.view.layer.sublayerTransform = perspective;
    
    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    
    imageViewOne.layer.transform = transform1;
    
    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);
    
    imageViewTwo.layer.transform = transform2;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/8.png" alt="8"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/9.png" alt="9"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/10.png" alt="10"/></p>

<h4 id="toc_9">Backfaces</h4>

<blockquote>
<p>我们既然可以在3D场景下旋转图层, 当然也可以从背面去观察它, 比如我们把翻转的角度设置为<strong>M_PI</strong>, 那么就会显示一个镜像的图层, 我们来看看代码:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewBackfaces {
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
        
    CATransform3D transform3DIdentity = CATransform3DIdentity;
    transform3DIdentity.m34 = - 1.0 / 500.0;
    transform3DIdentity = CATransform3DRotate(transform3DIdentity, M_PI, 0, 1, 0);
    imageView.layer.transform = transform3DIdentity;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/11.png" alt="11"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/12.png" alt="12"/></p>

<h4 id="toc_10">Layer Flattening</h4>

<blockquote>
<p>有人会问, 如果我们对已经做过变换的图层做反方向的会发生啥事?<br/>
<dr/><br/>
在理论上来讲, 我们如果对内部图层做了一个-45度的旋转, 如果要恢复正常, 则要做相反的变换, 才能相互抵消, 为了验证一下, 我们先试试:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewLayerFlattening {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 200, 200)];
    view.backgroundColor = [UIColor blueColor];
    
    [self.view addSubview:view];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [view addSubview:imageView];
    
    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);
    view.layer.transform = outer;
    
    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);
    imageView.layer.transform = inner;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/13.png" alt="13"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/14.png" alt="14"/></p>

<blockquote>
<p>看结果, 和我们想象的一样, 再试试再3D变化的情况下能不能抵消, 继续看代码:</p>
</blockquote>

<pre><code class="language-objectivec">    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 200, 200)];
    view.backgroundColor = [UIColor blueColor];
    
    [self.view addSubview:view];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [view addSubview:imageView];
    
//    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);
//    view.layer.transform = outer;
//    
//    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);
//    imageView.layer.transform = inner;
    
    // 3D Trans
    CATransform3D outer = CATransform3DIdentity; outer.m34 = -1.0 / 500.0;
    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0); view.layer.transform = outer;
    
    CATransform3D inner = CATransform3DIdentity; inner.m34 = -1.0 / 500.0;
    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0); imageView.layer.transform = inner;
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/15.png" alt="15"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/16.png" alt="16"/></p>

<blockquote>
<p>这里我并没有使用<strong>sublayerTransform</strong>属性, 因为这里面的图层并不是容器图层直接的子图层, 所以这里分别对图层设置了<strong>Perspective Projection</strong>.<br/>
<dr/><br/>
结果也是和我们所预期的不太一样, 虽然按道理来讲是显示正常的方块, 但实际上并不是的.<br/>
<dr/><br/>
在<strong>Core Animation</strong>当中, 3D图层存在于3D空间之内, 但它们并不是存在同一个, 其实每一个图层的3D场景都是扁平化的, 当我们正面观察一个图层时, 看到的图层其实是由子图层创建的3D场景, 当你倾斜这个图层时, 会发现这个3D场景只是被绘制在图层的表面罢了.<br/>
<dr/><br/>
总之一句话说完, 用<strong>Core Animation</strong>创建非常负责的3D场景是很蛋疼的, 因为我们不能直接创建一个个图层的去套, 然后构建成一个3D结构的图层关系, 刚刚也说了, 在相同场景下任何3D表面必须和同样的图层保持一致, 这是因为每一个父视图都把它的子视图扁平化了.<br/>
<dr/><br/>
那这个有办法解决吗? 当然有, 使用<strong>CALayer</strong>就可以啦, 在<strong>CALayer</strong>中, 有一个叫做<strong>CATransformLayer</strong>的子类就可以解决这个问题, 这个后面再说吧.</p>
</blockquote>

<hr/>

<h3 id="toc_11">Solid Objects</h3>

<blockquote>
<p><strong>Solid Objects</strong>翻译过来就叫做固体对象, 前面我们懂得了一丢丢的3D空间图层布局, 现在我们尝试着来创建一个固态的3D对象(也就是我们所谓的骰子), 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewSolidObjects {
    
    CATransform3D perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;

    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);
    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);

    self.view.layer.sublayerTransform = perspective;
    
    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);

    for (NSInteger i = 0; i &lt; 6; i++) {
        
        UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
        
        label.backgroundColor = [UIColor whiteColor];
        label.textColor = [UIColor redColor];
        label.layer.borderColor = [UIColor blackColor].CGColor;
        label.layer.borderWidth = 0.5;
        label.tag = i;
        label.text = [NSString stringWithFormat:@&quot;%ld&quot;, i + 1];
        label.font = [UIFont systemFontOfSize:30];
        label.textAlignment = NSTextAlignmentCenter;
        
        switch (label.tag) {
            case 0: {
                
                [self addLabel:label withTransform:transform];
            }
                break;
            case 1: {
                transform = CATransform3DMakeTranslation(100, 0, 0);
                transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 2: {
                transform = CATransform3DMakeTranslation(0, -100, 0);
                transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 3: {
                transform = CATransform3DMakeTranslation(0, 100, 0);
                transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 4: {
                transform = CATransform3DMakeTranslation(-100, 0, 0);
                transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 5: {
                transform = CATransform3DMakeTranslation(0, 0, -100);
                transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            default:
                break;
        }
    }
}

- (void)addLabel:(UILabel *)label withTransform:(CATransform3D)transform {
    
    [self.view addSubview:label];
    
    CGSize containerSize = self.view.bounds.size;
    label.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);
    label.layer.transform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/17.png" alt="17"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/18.png" alt="18"/></p>

<h4 id="toc_12">Light and Shadow</h4>

<blockquote>
<p>刚刚我们弄了一个看上去像是立方体的, 但是它们之前的每一个面之间的连接压根就分辨不出, 虽然在<strong>Core Animation</strong>可以用3D显示图层, 但它并没有光线的概念, 如果要让这个立方体看起来更加的真实, 那我们就要手动给它加个阴影效果, 这个就根据自己的需求来看了.<br/>
<dr/><br/>
这里我们简单的来看看事例: </p>
</blockquote>

<pre><code class="language-objectivec">- (void)addLightingToLabel:(CALayer *)labelLayer {
    
    CALayer *layer = [CALayer layer];
    layer.frame = labelLayer.bounds;
    
    [labelLayer addSublayer:layer];
    
    CATransform3D transform = labelLayer.transform;
    
    GLKMatrix4 matrix4 = [self matrixFrom3DTransformation:transform];
    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);
    
    GLKVector3 normal = GLKVector3Make(0, 0, 1);
    normal = GLKMatrix3MultiplyVector3(matrix3, normal);
    normal = GLKVector3Normalize(normal);
    
    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));
    CGFloat dotProduct = GLKVector3DotProduct(normal, light);
    
    CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;
    UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];
    
    layer.backgroundColor = color.CGColor;
}

- (GLKMatrix4)matrixFrom3DTransformation:(CATransform3D)transform {
    GLKMatrix4 matrix = GLKMatrix4Make(transform.m11, transform.m12, transform.m13, transform.m14,
                                       transform.m21, transform.m22, transform.m23, transform.m24,
                                       transform.m31, transform.m32, transform.m33, transform.m34,
                                       transform.m41, transform.m42, transform.m43, transform.m44);
    
    return matrix;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/19.png" alt="19"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/20.png" alt="20"/></p>

<h4 id="toc_13">Touch Events</h4>

<blockquote>
<p>虽然说我们现在用的是<strong>UILabel</strong>, 如果我们把3, 4, 5, 6换成<strong>UIButton</strong>和<strong>UIView</strong>的组合, 那4, 5, 6点击按钮是无法触发点击事件的.<br/>
<dr/><br/>
这是因为由于视图的顺序, 在之前我们就说过, 点击事件的处理是由视图再父视图中的顺序决定的, 并不是在<strong>3D空间</strong>的<strong>Z轴顺序</strong>上.<br/>
<dr/><br/>
但在这个例子当中, 我们的视图的确是按照顺序来添加的, 那为什么把4, 5, 6换成<strong>UIButton</strong>和<strong>UIView</strong>之后就无法处理点击事件了呢? 那是因为被前面的三个视图挡住了, 在表面上截断了4, 5, 6的点击事件, 这个是和普通的2D布局在按钮上覆盖物体是一样的.<br/>
<dr/><br/>
我们可以把除了3视图之外的视图<strong>userInteractionEnabled</strong>属性都设置成<strong>NO</strong>, 这样子就可以禁止事件传递, 或者通过简单的代码, 把<strong>视图3</strong>覆盖在<strong>视图6</strong>上, 那这样子无论你如何点, 都可以点击到按钮了.</p>
</blockquote>

<hr/>

<h3 id="toc_14">总结</h3>

<blockquote>
<p>总结一下:<br/>
* AffineTransforms的使用<br/>
* AffineTransforms的混合变换<br/>
* 3D Transforms的Perspective Projection<br/>
* 3D Transforms的The Vanishing Point<br/>
* 3D Transforms的Sublayer Transform<br/>
* 3D Transforms的Backfaces<br/>
* 3D Transforms的Layer Flattening<br/>
* 最后再来一丢丢的Solid Objects</p>
</blockquote>

<hr/>

<h3 id="toc_15">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_16">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  
	      <div class="ds-thread" data-thread-key="14777052484078.html" data-url="https://cainrun.github.io/14777052484078.html" data-title="玩转iOS开发：5.《Core Animation》CALayer的Transforms"></div>
	  

	</div>
</div>        </div>
    		<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="https://cainrun.github.io">Cain</a>    
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
    	</div>
    </div>

  


<script type="text/javascript">
var duoshuoQuery = {short_name:'cainluo'};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
    
<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>