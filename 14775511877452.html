<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	玩转iOS开发：4.《Core Animation》CALayer的视觉效果 - Cain For iOS
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Cain For iOS" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="asset/icon.png" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">Cain For iOS</a></h1>
					<p class="subtitle">指弹吉他演奏爱好者, 摄影爱好者, iOS 开发工程师, 如果您有更好的建议或者其他不明白的地方, 可以在对应的文章留言</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">




<a target="_blank" class="linkedin" href="www.linkedin.com/in/cainluo" title="LinkedIn">LinkedIn</a>



<a target="_blank" class="weibo" href="http://weibo.com/1826190094" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com/CainRun" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:zhebushimengfei@qq.com" title="Email">Email</a>

								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">玩转iOS开发：4.《Core Animation》CALayer的视觉效果</h1>
		<div class="entry-content" itemprop="articleBody">
			<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前一章我们对<strong>CALayer</strong>了解的更加深入了一些<a href="https://cainrun.github.io/14773198375857.html">《Core Animation》CALayer的几何图层</a>今天我们就来讲讲<strong>CALayer Visual Effects</strong>, 也就是<strong>CALayer</strong>的视觉效果.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>CALayer Visual Effects</strong>讲得是<strong>CALayer</strong>一些我们能够看得见的东西, 这些知识点在我们日常开发中也会有用到的, 比如<strong>Rounded Corners</strong>, <strong>Layer Borders</strong>, <strong>Drop Shadows</strong>, <strong>Layer Masking</strong>, <strong>Scaling Filters</strong>, <strong>Group Opacity</strong>等等, 待我们一一去讲解.</p>
</blockquote>

<hr/>

<h3 id="toc_2">Rounded Corners</h3>

<blockquote>
<p><strong>Rounded Corners</strong>这个东西我们用的其实也是挺多的, 我们都知道, 在<strong>iOS 7</strong>之前, 基本上所有的<strong>Button</strong>都是椭圆形的, 而这些<strong>Button</strong>之所以都是椭圆形, 大多数都是因为<strong>Rounded Corners</strong>这个东西的原因.<br/>
<dr/><br/>
在<strong>CALayer</strong>有一个叫<strong>conrnerRadius</strong>的CGFloat类型属性来控制着图层角的曲率, 默认值为0, 你可以设置任意数值, 是的图层角显示不一样的曲率, 而且<strong>conrnerRadius</strong>这个属性所影响的到的只有设置该属性的<strong>CALayer</strong>, 并不会影响到子图层或者是背景图, 但如果你要让子图层或者是背景图也要跟着该<strong>CALayer</strong>进行曲率处理, 你可以把<strong>masksToBounds</strong>设置为<strong>YES</strong>, 这样子就可以满足你的需求了.<br/>
<dr/><br/>
我们直接来看看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerRoundedCorners {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor redColor];
    view.layer.cornerRadius = 50.f;
    view.layer.masksToBounds = YES;
    
    CALayer *layer = [CALayer layer];
    
    layer.backgroundColor = [UIColor blueColor].CGColor;
    layer.frame = CGRectMake(50, 50, 50, 50);
    
    [view.layer addSublayer:layer];
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/2.png" alt="2"/></p>

<blockquote>
<p><strong><font color=red>PS: 这里需要注意一点, 由于</strong>masksToBounds<strong>和</strong>conrnerRadius<strong>这两个属性同时使用是挺消耗性能的, 如果你是要大面积的去使用, 会造成卡顿现象, 比如说在</strong>UICollectionView<strong>或者是</strong>UITableView<strong>上使用.</font></strong></p>
</blockquote>

<hr/>

<h3 id="toc_3">Layer Borders</h3>

<blockquote>
<p><strong>CALayer</strong>还有两个更好玩的属性, 这也是在<strong>iOS 7</strong>之前<strong>Button</strong>会默认实现的两个属性, 一个叫做<strong>borderWidth</strong>, 一个叫做<strong>borderColor</strong>.<br/>
<dr/></p>

<ul>
<li><strong>borderWidth</strong>: 这是一个<strong>CGFloat</strong>类型的属性, 是用来设置<strong>CALayer</strong>边框宽度, 默认值是为0.</li>
<li><strong>borderColor</strong>: 这是一个<strong>CGColorRef</strong>类型的属性, 所以你不能给它直接设置一个<strong>UIColor</strong>对象, 前面我们已经对<strong>CGColorRef</strong>这个东东进行了简单的介绍, 这里我们只需要知道直接给它赋个值就好了, 还有就是<strong>borderColor</strong>是用来设置<strong>CALayer</strong>边框颜色, 在<strong>iOS 7</strong>之前默认值是为黑色, <strong>iOS 7</strong>之后默认值是为透明.</li>
</ul>

<p><dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerBorders {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor blueColor];
    view.layer.borderWidth = 5.f;
    view.layer.borderColor = [UIColor redColor].CGColor;
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/3.png" alt="3"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_4">Drop Shadows</h3>

<blockquote>
<p>在<strong>iOS</strong>当中, 还有一个特性, 叫做<strong>Drop Shadows(阴影)</strong>, 其实这个也不算是<strong>iOS</strong>特有的, 毕竟在<strong>Mac OS</strong>里早就已经有这个特性了.<br/>
<dr/><br/>
阴影往往是起暗示作用, 比如说你现在正在显示的窗口, 周边就会带上阴影, 或者是强调里面的某个图层的优先级, 大多数时候只是用来装饰罢了.<br/>
<dr/><br/>
设置阴影的时候也是很简单, 直接给<strong>shadowOpacity</strong>属性设置一个大于<strong>0.0</strong>的值就好了, <strong>shadowOpacity</strong>这个属性可设置的值是在<strong>0.0~1.0</strong>之间, 默认是<strong>0.f</strong>, 最大值是<strong>1.f</strong>, 如果直接设置为<strong>1.f</strong>, 那么将会显示一个轻微模糊的黑色阴影在图层的上方, 另外, 你可以通过<strong>CALayer</strong>所提供的<strong>shadowColor</strong>, <strong>shadowOffset</strong>, <strong>shadowRadius</strong>对阴影进行一些额外的操作, 这里就不一一介绍了, 各位童鞋们可以自行尝试一下~<br/>
<dr/><br/>
说到这里, 会有人问, 为什么阴影是在图层的上方呢? 其实在之前我们就有了解过Mac OS和iOS的一些东西, 基本上iOS的一些东西都是从Mac OS搬过来, 然后再改改的, 包括这个阴影也是如此, 所以你才会看到在iOS当中阴影是反过来的, 这里我们只需要设置一下<strong>shadowOffset</strong>就可以正常显示了.<br/>
<dr/><br/>
直接看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerDropShadows {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor redColor];
    view.layer.shadowOpacity = 1.0f;
    view.layer.shadowOffset = CGSizeMake(0, 3);
    view.layer.shadowRadius = 10.f;
    view.layer.shadowColor = [UIColor blueColor].CGColor;
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/5.png" alt="5"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/6.png" alt="6"/></p>

<h4 id="toc_5">Shadow Clipping</h4>

<blockquote>
<p>这里还有一个比较好玩的东西, 就是阴影剪切, 我们都知道<strong>CALayer</strong>超出了<strong>UIView</strong>的范围, 如果要剪切掉的话, 只能用<strong>masksToBounds</strong>这个属性去剪切.<br/>
<dr/><br/>
但这样子会带来另一个的问题, 因为一旦使用<strong>masksToBounds</strong>这个属性, 剪切掉的就不只是多出来的部分, 会连阴影部分都一起剪切完, 为了防止阴影也跟着被剪切掉, 我们需要使用一个比较笨的方法, 就是再创建多一个<strong>CALayer</strong>, 让它去创建阴影部分, 另一个<strong>CALayer</strong>去剪切内容就可以了.<br/>
<dr/><br/>
我们还是直接看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerShadowClipping {
    
    UIView *contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
    UIView *blueView = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    UIView *shadowView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    contentView.backgroundColor = [UIColor grayColor];
    blueView.backgroundColor = [UIColor blueColor];
    
    contentView.layer.masksToBounds = YES;
    
    shadowView.layer.shadowOpacity = 1.0f;
    shadowView.layer.shadowOffset = CGSizeMake(0, 0.5f);
    shadowView.layer.shadowColor = [UIColor redColor].CGColor;

    [contentView addSubview:blueView];
    [shadowView addSubview:contentView];
    
    [self.view addSubview:shadowView];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/7.png" alt="7"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/8.png" alt="8"/></p>

<h4 id="toc_6">shadowPath</h4>

<blockquote>
<p>我们都知道其实阴影是没有形态的, 它是根据图层的形状来进行显示, 如果在一个视图当中有很多子图层, 然后要一个一个的去计算阴影的形状, 那是非常耗性能的, 但如果在开发之前你就已经知道阴影的形状, 那么你就可以提前设置好, 这样子就可以优化性能了, 而这个属性就是<strong>shadowPath</strong>, <br/>
<dr/><br/>
<strong>shadowPath</strong>是<strong>CGPathRef</strong>类型, 可以说是一个指向<strong>CGPath</strong>的指针, 而<strong>CGPath</strong>是一个<strong>Core Graphics</strong>对象, 可以用来任意描绘一个矢量图形, 我们也可以使用它来描绘阴影, 大大的提升性能.<br/>
<dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerShadowPath {
    
    UIView *shadowViewOne = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    UIView *shadowViewTwo = [[UIView alloc] initWithFrame:CGRectMake(50, 250, 100, 100)];

    shadowViewOne.layer.shadowOpacity = 0.5f;
    shadowViewTwo.layer.shadowOpacity = 0.5f;
    
    CGMutablePathRef squarePath = CGPathCreateMutable();
    CGPathAddRect(squarePath, NULL, shadowViewOne.bounds);
    shadowViewOne.layer.shadowPath = squarePath;
    
    CGPathRelease(squarePath);
    
    CGMutablePathRef circlePath = CGPathCreateMutable();
    CGPathAddEllipseInRect(circlePath, NULL, shadowViewTwo.bounds);
    shadowViewTwo.layer.shadowPath = circlePath;
    
    CGPathRelease(circlePath);

    [self.view addSubview:shadowViewOne];
    [self.view addSubview:shadowViewTwo];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/9.png" alt="9"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/10.png" alt="10"/></p>

<hr/>

<h3 id="toc_7">Layer Masking</h3>

<blockquote>
<p>我们都知道如果我们要剪切超出范围的图层可以使用<strong>masksToBounds</strong>, 通过<strong>conrnerRadius</strong>可以设置图层为圆角, 但如果你需要设置一个不规整的图层时, 用上面的两个属性是没法实现的.<br/>
<dr/><br/>
虽然我们可以使用一个<strong>32位</strong>且带有<strong>alpha</strong>通道的<strong>png</strong>图片可以实现, 但这个方法也是有局限的, 不能以动态编码的形式生成蒙版, 也不能让子图层或者子视图也裁剪成同样的形状.<br/>
<dr/><br/>
苹果为了解决这个为题, 在<strong>CALayer</strong>当中提供了一个<strong>CGLayer</strong>类型, 名叫<strong>mask</strong>的属性, 有着和其他CALayer一样的布局属性, 它就像是一个子图层, 相对于父图层来进行布局的, 但它又区别于子图层, 它是定义父图层可见部分的.<br/>
<dr/><br/>
虽然<strong>mask</strong>里也有<strong>Color</strong>这个属性, 但它并没啥用, 真正重要的是图层的轮廓, 它就像是一台切割机一样, 实心图层部分会被保留, 其他的就会作为垃圾一样被抛弃.<br/>
<dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerMasking {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;arrow&quot;];
    
    CALayer *maskLayer = [CALayer layer];
    UIImage *maskImage = [UIImage imageNamed:@&quot;star&quot;];
    
    maskLayer.frame = imageView.bounds;
    maskLayer.contents = (__bridge id _Nullable)(maskImage.CGImage);
    
    imageView.layer.mask = maskLayer;
    
    [self.view addSubview:imageView];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/11.png" alt="11"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/12.png" alt="12"/></p>

<hr/>

<h3 id="toc_8">Scaling Filters</h3>

<blockquote>
<p>这里我们提及一个点, 是关于图片显示的一个问题, 我们都知道如果要让一个<strong>CALayer</strong>显示一张图片是直接给它的<strong>contents</strong>直接设置内容, 但是呢, 这个图片是否正确的显示, 画质如何, 我们都无从而知.<br/>
<dr/><br/>
为了解决这个问题,<strong>CALayer</strong>分别提供了<strong>minificationFilter</strong>和<strong>magnificationFilter</strong>属性, 它们都是<strong>NSString</strong>类型, 说到这里, 有人会疑问, 直接显示不就是最好的么, 为啥要那么麻烦, 其实不一定的, 原因的话, 大概有三点吧:<br/>
<dr/></p>

<ul>
<li>能够显示最好的画质, 指的是像素没有被压缩也没有被拉伸.</li>
<li>可以节省资源, 比如神马内存, 存储之类的.</li>
<li>可以优化性能, 减轻CPU的压力.
<dr/></li>
</ul>

<p>打个比方, 比如我们开发的时候, 有个头像省略图, 这个时候呢, 你说是用全图比较好, 还是压缩过的比较好? 答案肯定是压缩过的比较好, 因为可以省资源.<br/>
<dr/><br/>
顺便说说, 这两个属性可设置的值分别是:</p>

<ul>
<li>kCAFilterLinear(默认值)</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear
<dr/>
说那么多, 直接来看Demo吧:</li>
</ul>
</blockquote>

<pre><code class="language-objectivec">- (void)layerScalingFilters {
    
    UIImageView *imageViewOne = [[UIImageView alloc] initWithFrame:CGRectMake(0, 100, self.view.bounds.size.width / 2, 200)];
    UIImageView *imageViewTwo = [[UIImageView alloc] initWithFrame:CGRectMake(self.view.bounds.size.width / 2, 100, self.view.bounds.size.width / 2, 200)];
    UIImageView *imageViewThree = [[UIImageView alloc] initWithFrame:CGRectMake(0, 300, self.view.bounds.size.width / 2, 200)];
    
    imageViewOne.image = [UIImage imageNamed:@&quot;expression&quot;];
    imageViewTwo.image = [UIImage imageNamed:@&quot;expression&quot;];
    imageViewThree.image = [UIImage imageNamed:@&quot;expression&quot;];

    imageViewOne.layer.magnificationFilter = kCAFilterNearest;
    imageViewTwo.layer.magnificationFilter = kCAFilterLinear;
    imageViewThree.layer.magnificationFilter = kCAFilterTrilinear;

    imageViewOne.layer.minificationFilter = kCAFilterNearest;
    imageViewTwo.layer.minificationFilter = kCAFilterLinear;
    imageViewThree.layer.minificationFilter = kCAFilterTrilinear;
    
    [self.view addSubview:imageViewOne];
    [self.view addSubview:imageViewTwo];
    [self.view addSubview:imageViewThree];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/13.png" alt="13"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/14.png" alt="14"/></p>

<blockquote>
<p>额...这个有些尴尬, 看起来的效果区别不太大...凑合着看吧..</p>
</blockquote>

<hr/>

<h3 id="toc_9">Group Opacity</h3>

<blockquote>
<p>最后, 我们来说说<strong>Group Opacity</strong>这个东西, 在<strong>iOS 7</strong>之前, 如果你在一个<strong>Button</strong>上添加一个视图, 在<strong>alpha</strong>设置为<strong>50%</strong>的情况下会出现图层有分割, 需要设置<strong>shouldRasterize</strong>和<strong>rasterizationScale</strong>两个属性才能使得在半透明的情况下看起来是一体, 但是这个问题在<strong>iOS 7</strong>之后就已经解决了, 现在<strong>shouldRasterize</strong>属性更多的是用来解决<strong>UITableView</strong>里的<strong>CALayer</strong>圆角显示图层的处理, 这里就不做多的解释了, 有兴趣的童鞋们可以去谷歌搜搜<strong>shouldRasterize</strong>的用法, 都是挺简单的~</p>
</blockquote>

<hr/>

<h3 id="toc_10">总结</h3>

<blockquote>
<p>总结一下, 这一章我们了解更多的是<strong>CALayer</strong>肉眼上能看到的东西, 比如:<br/>
<br/></p>

<ul>
<li><strong>Rounded Corners</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>圆角的处理.</li>
<li><strong>Layer Borders</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>边框的处理, 包括边框的厚度, 以及颜色等</li>
<li><strong>Drop Shadows</strong>: 在这个知识点里, 我们知道了<strong>CALayer</strong>阴影的处理.</li>
<li><strong>Layer Masking</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>可以作为一个<strong>mask</strong>去使用, 并且可以显示不同不规则的形状.</li>
<li><strong>Scaling Filters</strong>: 在这个知识点里, 我们知道<strong>CALayer</strong>可以更改显示的画质, 优化显示的资源等等.</li>
<li><strong>Group Opacity</strong>: 在这个知识点里, 虽然在<strong>iOS 7</strong>之后已经解决了这个问题, 但我们也可以把<strong>shouldRasterize</strong>属性运用在其他的地方.</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_11">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_12">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

		</div>
	</article>
	<div class="share-comment">
	 <!-- UY BEGIN -->
<div id="uyan_frame"></div>
<script type="text/javascript" src="http://v2.uyan.cc/code/uyan.js?uid=2137618"></script>
<!-- UY END -->

	  

	  
	      <div class="ds-thread" data-thread-key="14775511877452.html" data-url="https://cainrun.github.io/14775511877452.html" data-title="玩转iOS开发：4.《Core Animation》CALayer的视觉效果"></div>
	  

	</div>
</div>        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

  


<script type="text/javascript">
var duoshuoQuery = {short_name:'cainluo'};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
    
<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>