<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	玩转iOS开发：3.《Core Animation》CALayer的几何图层 - Cain For iOS
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Cain For iOS" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="asset/icon.png" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">Cain For iOS</a></h1>
					<p class="subtitle">指弹吉他演奏爱好者, 摄影爱好者, iOS 开发工程师, 如果您有更好的建议或者其他不明白的地方, 可以联系我QQ: 350116542</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">




<a target="_blank" class="linkedin" href="www.linkedin.com/in/cainluo" title="LinkedIn">LinkedIn</a>



<a target="_blank" class="weibo" href="http://weibo.com/1826190094" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com/CainRun" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:zhebushimengfei@qq.com" title="Email">Email</a>

								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">玩转iOS开发：3.《Core Animation》CALayer的几何图层</h1>
		<div class="entry-content" itemprop="articleBody">
			<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前一章我们了解真正了<strong>CALayer</strong>是干嘛的, <a href="https://cainrun.github.io/14771496782021.html">《Core Animation》初识CALayer</a>今天我们就来讲讲<strong>CALayer Geometry</strong>.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>CALayer Geometry</strong>讲得是图层的几何, 主要内容分别有<strong>Layout</strong>, <strong>anchorPoint</strong>, <strong>Coordinate Systems</strong>, <strong>Hit Testing</strong>, <strong>Automatic Layout</strong>, <strong>Summary</strong>, 待我们一一去了解和学习~</p>
</blockquote>

<hr/>

<h3 id="toc_2">Layout</h3>

<blockquote>
<p><strong>Layout</strong>顾名思义就是布局的意思, 这一段讲的是视图和图层简单的布局, 比如<strong>UIView</strong>里面有<strong>frame</strong>, <strong>bounds</strong>, <strong>center</strong>, <strong>CALayer</strong>里面有<strong>frame</strong>, <strong>bounds</strong>, <strong>position</strong>.</p>

<p>这里对布局属性进行一下解释: </p>

<p><strong>frame</strong>: 代表了的是图层外部的一个坐标轴, 也是相对于父视图.<br/>
<strong>bounds</strong>: 代表了的是内部坐标轴, 它的原点永远都是<strong>{0, 0}</strong>, 是相对于本视图的位置和大小.<br/>
<strong>center</strong>以及<strong>position</strong>: 代表的是现对于父视图所在的位置, 也就是我们经常所说的中心点, 但是呢, 其实这个说法不太对, 其实是应该相对于父视图<strong>anchorPoint</strong>属性所在的位置才对,<strong>anchorPoint</strong>属性我们后面再解释, 现在让它打一下酱油先.</p>

<p>我们来看看Demo中的实例:</p>
</blockquote>

<pre><code class="language-objectivec">
- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self logViewAndLayer];
}

- (void)logViewAndLayer {

    NSLog(@&quot;View X: %f&quot;, self.view.center.x);
    NSLog(@&quot;View Y: %f&quot;, self.view.center.y);
    NSLog(@&quot;View Frame Width: %f&quot;, self.view.frame.size.width);
    NSLog(@&quot;View Frame Height: %f&quot;, self.view.frame.size.height);
    NSLog(@&quot;View Bounds Width: %f&quot;, self.view.bounds.size.width);
    NSLog(@&quot;View Bounds Height: %f&quot;, self.view.bounds.size.height);
    NSLog(@&quot;\n&quot;);
    NSLog(@&quot;Layer X: %f&quot;, self.view.layer.position.x);
    NSLog(@&quot;Layer Y: %f&quot;, self.view.layer.position.y);
    NSLog(@&quot;Layer Frame Width: %f&quot;, self.view.layer.frame.size.width);
    NSLog(@&quot;Layer Frame Height: %f&quot;, self.view.layer.frame.size.height);
    NSLog(@&quot;Layer Bounds Width: %f&quot;, self.view.layer.bounds.size.width);
    NSLog(@&quot;Layer Bounds Height: %f&quot;, self.view.layer.bounds.size.height);
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/1.png" alt="1"/></p>

<blockquote>
<p>在这里, 我们看到<strong>layer</strong>的<strong>frame</strong>, <strong>bounds</strong>, <strong>position</strong>和<strong>UIView</strong>的<strong>frame</strong>, <strong>bounds</strong>, <strong>center</strong>都是一致的.</p>

<p>但是在<strong>UIView</strong>里, <strong>frame</strong>, <strong>bounds</strong>, <strong>center</strong>这三个属性只是存取方法罢了, 当<strong>UIView</strong>对<strong>frame</strong>属性进行操作时, 其实是对<strong>CALayer</strong>的<strong>frame</strong>进行操作, 是不能够脱离了<strong>CALayer</strong>的去改变视图的<strong>frame</strong>.</p>

<p><strong>frame</strong>这个属性对于<strong>UIView</strong>和<strong>CALayer</strong>来说, 它是一个比较玄的属性, 它的值是根据<strong>UIView</strong>或者是<strong>CALayer</strong>的<strong>bounds</strong>, <strong>center</strong>/<strong>position</strong>, <strong>transform</strong>计算所得到的一个值, 一旦你去改变了<strong>bounds</strong>, <strong>center</strong>/<strong>position</strong>, <strong>transform</strong>其中一个值, <strong>frame</strong>也会随之而改变, 当然啦, 你去改变<strong>frame</strong>, <strong>bounds</strong>, <strong>center</strong>/<strong>position</strong>, <strong>transform</strong>这三个值也会跟着改变的.</p>

<p><strong><font color=red>PS: 这里还需要提一点, 如果你对</strong>CALayer<strong>进行了</strong>transform<strong>的旋转或者是缩放时,</strong> frame<strong>所显示的宽高与</strong>bounds<strong>的宽高就不会再一样了.</font></strong></p>

<p>直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerTransform {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(20, 20, 100, 100)];
    
    view.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:view];
    
    view.layer.transform = CATransform3DMakeRotation(M_PI_4, 1, 1, 0.5);
    
    NSLog(@&quot;View X: %f&quot;, view.center.x);
    NSLog(@&quot;View Y: %f&quot;, view.center.y);
    NSLog(@&quot;View Frame Width: %f&quot;, view.frame.size.width);
    NSLog(@&quot;View Frame Height: %f&quot;, view.frame.size.height);
    NSLog(@&quot;View Bounds Width: %f&quot;, view.bounds.size.width);
    NSLog(@&quot;View Bounds Height: %f&quot;, view.bounds.size.height);
    NSLog(@&quot;\n&quot;);
    NSLog(@&quot;Layer X: %f&quot;, view.layer.position.x);
    NSLog(@&quot;Layer Y: %f&quot;, view.layer.position.y);
    NSLog(@&quot;Layer Frame Width: %f&quot;, view.layer.frame.size.width);
    NSLog(@&quot;Layer Frame Height: %f&quot;, view.layer.frame.size.height);
    NSLog(@&quot;Layer Bounds Width: %f&quot;, view.layer.bounds.size.width);
    NSLog(@&quot;Layer Bounds Height: %f&quot;, view.layer.bounds.size.height);
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/2.png" alt="2"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_3">AnchorPoint</h3>

<blockquote>
<p><strong>anchorPoint</strong>这个属性名, 也叫作<strong>锚点</strong>, 指的一个<strong>UIView</strong>和<strong>CALayer</strong>相对于父视图的位置参考点, 左上角为<strong>{0, 0}</strong>, 居中为<strong>{0.5, 0.5}</strong>, 右下角为<strong>{1, 1}</strong>, 默认都是位于父视图层的中点, 也就是<strong>{0.5, 0.5}</strong>.</p>

<p>在<strong>UIView</strong>当中, <strong>anchorPoint</strong>属性并没有公开出来, 你只能操作<strong>center</strong>这个值, 间接性的给<strong>anchorPoint</strong>赋值, <strong>CALayer</strong>也可以通过改变<strong>position</strong>来给<strong>anchorPoint</strong>进行赋值, 从而改变<strong>CALayer</strong>的<strong>frame</strong>.</p>

<p>这里还需要提及一点, 如果你改变了<strong>CALayer</strong>的<strong>anchorPoint</strong>, 那么<strong>CALayer</strong>的<strong>frame</strong>也会被改变, 那么<strong>anchorPoint</strong>属性所显示的值再也不是该<strong>CALayer</strong>的中心点, 但<strong>bounds</strong>,<strong>position</strong>这些值并不会被改变.</p>

<p>我们直接来看看Demo吧~</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewAnchorPoint {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];

    view.backgroundColor = [UIColor grayColor];

    NSLog(@&quot;before X: %f&quot;, view.layer.frame.origin.x);
    NSLog(@&quot;before Y: %f&quot;, view.layer.frame.origin.y);
    
    view.layer.anchorPoint = CGPointMake(0.1f, 0.1f);

    NSLog(@&quot;After X: %f&quot;, view.layer.frame.origin.x);
    NSLog(@&quot;After Y:%f&quot;, view.layer.frame.origin.y);

    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/4.png" alt="4"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/5.png" alt="5"/></p>

<blockquote>
<p>一般来讲, 能够用到<strong>anchorPoint</strong>属性的场景, 大多数都是在与图层叠加方面, 不然基本布局就已经够用了, 当然, 这只是在简单页面的基础上来讲而已, 还是看个人需求吧.</p>
</blockquote>

<hr/>

<h3 id="toc_4">Coordinate Systems</h3>

<blockquote>
<p><strong>Coordinate Systems</strong>也叫作坐标系, 和<strong>UIView</strong>一样,<strong>CALayer</strong>也是相对于父图层并且按照层级关系来摆放, 如果父图层的位置发生了变化, 那么子图层也会随之而改变.</p>

<p>但某些情况下, 你想要知道这个图层的绝对位置, 或者是相对于另一个图层的位置时, 你就可以使用CALayer所提供的几个API进行处理了:</p>
</blockquote>

<pre><code class="language-objectivec">    - (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;
    - (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;
    - (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;
    - (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;
</code></pre>

<blockquote>
<p>这些方法，可以采取任何一层的坐标系中所定义的点或矩形，并将其转换到另一个坐标系。</p>
</blockquote>

<h4 id="toc_5">翻转CALayer的几何图层</h4>

<blockquote>
<p>这里再普及一个概念, 我们都知道在<strong>iOS</strong>当中<strong>CALayer</strong>的<strong>position</strong>是在父图层的左上角, 但在<strong>Mac OS</strong>当中, 一般来说是在左下角, 而<strong>Core Animation</strong>为了解决这个问题, 提供了一个<strong>BOOL</strong>属性<strong>geometryFlipped</strong>来适配这两种情况, 它决定了一个图层的坐标是否相对于父图层且垂直翻转, 如果在<strong>iOS</strong>上把<strong>geometryFlipped</strong>设置为<strong>YES</strong>的话, 那么图层的排版就会沿着底部来排版, 而不是我们通常所看到的那样, 包括它的子图层也是如此, 除非你再把子图层里的<strong>geometryFlipped</strong>属性设置为<strong>YES</strong>.</p>

<p>直接看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerGeometryFlipped {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor blueColor];
    view.layer.geometryFlipped = YES;
    
    CALayer *layer = [CALayer layer];
    
    layer.frame = CGRectMake(0, 0, 25, 25);
    layer.backgroundColor = [UIColor redColor].CGColor;
    
    [view.layer addSublayer:layer];
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/6.png" alt="6"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/7.png" alt="7"/></p>

<h4 id="toc_6">Z坐标轴</h4>

<blockquote>
<p>其实<strong>CALayer</strong>除了有<strong>UIView</strong>常规的二维坐标轴之外, 还有一个<strong>Z坐标轴</strong>, 也就是说<strong>CALayer</strong>存在于三维空间当中.</p>

<p>除了我们之前接触过的<strong>position</strong>和<strong>anchorPoint</strong>之外, 还有两个<strong>Z坐标轴</strong>的属性, 叫做<strong>zPosition</strong>和<strong>anchorPointZ</strong>, 且都是<strong>CGFloat</strong>类型.</p>

<p><strong>zPosition</strong>这个属性在通常情况下并不常用, 在后面我们涉及到一些3D转换的内容时才会去使用这个<strong>zPosition</strong>属性, <strong>zPosition</strong>属性除了用来做3D转换之外, 更多是用来改变<strong>CALayer</strong>的显示顺序了.</p>

<p>来看看Demo吧</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewsZPosition {
    
    UIView *greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    greenView.backgroundColor = [UIColor greenColor];
    greenView.layer.zPosition = 1.0f;
    
    UIView *redView = [[UIView alloc] initWithFrame:CGRectMake(150, 150, 100, 100)];
    
    redView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:greenView];
    [self.view addSubview:redView];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/8.png" alt="8"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/9.png" alt="9"/></p>

<hr/>

<h3 id="toc_7">Hit Testing</h3>

<blockquote>
<p>在之前的文章里, 我们知道CALayer并不能处理任何响应链的事件, 所以不能直接去处理触摸事件或者手势, 但是呢, CALayer提供了一些方法可以让你知道你知道你点击了这个CALayer.</p>
</blockquote>

<pre><code class="language-objectivec">- (void)containsPoint;
- (void)hitTest;
</code></pre>

<blockquote>
<p>我们直接来看看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)hitTestingLayer {
    
    _backgroundView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    _backgroundView.backgroundColor = [UIColor grayColor];
    
    _blueLayer = [CALayer layer];
    
    _blueLayer.backgroundColor = [UIColor blueColor].CGColor;
    _blueLayer.frame = CGRectMake(25, 25, 50, 50);
    
    [_backgroundView.layer addSublayer:_blueLayer];
    
    [self.view addSubview:_backgroundView];
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    
    CGPoint point = [[touches anyObject] locationInView:self.view];
    
    CALayer *layer = [self.backgroundView.layer hitTest:point];
    
    UIAlertView *alerView = [[UIAlertView alloc] initWithTitle:@&quot;你点击了屏幕&quot;
                                                       message:@&quot;&quot;
                                                      delegate:nil
                                             cancelButtonTitle:@&quot;确定&quot;
                                             otherButtonTitles:nil, nil];

    if (layer == self.blueLayer) {
        
        alerView.message = @&quot;你点中了蓝色的Layer&quot;;
        
    } else if (layer == self.backgroundView.layer){
        
        alerView.message = @&quot;你点中了灰色的Layer&quot;;
        
    } else {
        alerView.message = @&quot;你点中了其他的Layer&quot;;
    }
    
    [alerView show];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/10.png" alt="10"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/11.png" alt="11"/></p>

<hr/>

<h3 id="toc_8">Automatic Layout</h3>

<blockquote>
<p>所谓的<strong>Automatic Layout</strong>就是我们经常所说的自动布局, 自动布局是苹果在<strong>iOS 6</strong>的时候引入进来的一套布局机制, 但当时好像<strong>Xcode</strong>不够给力, 最终并没有得到很好的运用.</p>

<p>在<strong>Mac OS</strong>当中<strong>CALayer</strong>有一个叫做<strong>layoutManager</strong>的属性, 它可以通过<strong>CALayoutManager</strong>协议和<strong>CAConstraintLayoutManger</strong>类来实现自动布局, 但这个东东在<strong>iOS</strong>上并不能使用, 详细我也不太了解.</p>

<p>再补充多一点, 在我们对<strong>UIView</strong>使用自动布局的时候, 你可以直接使用<strong>UIView</strong>提供的<strong>UIViewAutoresizingMask</strong>和<strong>NSLayoutConstraint</strong>两个API进行布局, 但如果你要对一个<strong>CALayer</strong>进行布局的话, 那么最简单的方式就是使用<strong>CALayerDelegate</strong>提供的<strong>API</strong>:</p>
</blockquote>

<pre><code class="language-objectivec"> - (void)layoutSublayersOfLayer:(CALayer *)layer;
</code></pre>

<blockquote>
<p>当<strong>CALayer</strong>的<strong>bounds</strong>发生了改变或者<strong>- (void)setNeedsLayout;</strong>方法被调用的时候, 上面所提及的<strong>API</strong>就会被调用, 这样子你就可以在上面所提及的<strong>API</strong>里手动去调整<strong>CALayer</strong>的布局.</p>

<p>但这样子会有一个致命的问题, 由于<strong>CALayer</strong>并没有<strong>autoresizingMask</strong>以及<strong>constraints</strong>属性, 所以不能像<strong>UIView</strong>那样自适应屏幕旋转, 这也是为什么绝大多数人选择使用<strong>UIView</strong>进行布局的原因之一.</p>

<p>这里我就不多说了, 自动布局的知识点在谷歌搜一大堆, 有神马<strong>xib</strong>的, <strong>storyboard</strong>的, 还有纯代码的, 但是呢, 纯代码的自动布局我只服<strong><a href="https://github.com/SnapKit/Masonry">Masonry</a></strong>, 也有<strong><a href="https://github.com/SnapKit/SnapKit">Swift</a></strong>版本的, 大家可以自行去了解一下, 使用教程神马的, 在谷歌搜搜也是有一堆的, 这里就不做介绍了~</p>
</blockquote>

<hr/>

<h3 id="toc_9">总结</h3>

<blockquote>
<p>说了那么多, 常规的总结一下, 这次我们更深入的了解了<strong>CALayer</strong>几何图层, 其中包括: </p>

<p><strong>Layout</strong>:<strong>CALayer</strong>的常规布局<br/>
<strong>AnchorPoint</strong>: <strong>CALayer</strong>的锚点<br/>
<strong>Coordinate Systems</strong>: <strong>CALayer</strong>的坐标轴, 其中包括如何翻转<strong>CALayer</strong>的几何图层, 还有就是<strong>Z坐标轴</strong>.<br/>
<strong>Hit Testing</strong>: <strong>CALayer</strong>如何知道用户是否点击该图层<br/>
<strong>Automatic Layout</strong>: 有关于<strong>CALayer</strong>以及<strong>UIView</strong>的自动布局, 以及一个第三方的布局框架</p>
</blockquote>

<hr/>

<h3 id="toc_10">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_11">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  
	      <div class="ds-thread" data-thread-key="14773198375857.html" data-url="https://cainrun.github.io/14773198375857.html" data-title="玩转iOS开发：3.《Core Animation》CALayer的几何图层"></div>
	  

	</div>
</div>        </div>
    		<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="https://cainrun.github.io">Cain</a>    
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
    	</div>
    </div>

  


<script type="text/javascript">
var duoshuoQuery = {short_name:'cainluo'};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
    
<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>