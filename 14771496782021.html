<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	玩转iOS开发：2.《Core Animation》初识CALayer - Cain For iOS
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Cain For iOS" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
				 
				 	<div class="profilepic">
						<img src="asset/icon.png" style="width:160px;">
					</div>
            	
					
					<h1><a href="index.html">Cain For iOS</a></h1>
					<p class="subtitle">指弹吉他演奏爱好者, 摄影爱好者, iOS 开发工程师, 如果您有更好的建议或者其他不明白的地方, 可以联系我QQ: 350116542</p>
					<nav id="main-nav">
						<ul class="main">
						
						  <li id=""><a target="self" href="index.html">Home</a></li>
						
						  <li id=""><a target="_self" href="archives.html">Archives</a></li>
						
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">




<a target="_blank" class="linkedin" href="www.linkedin.com/in/cainluo" title="LinkedIn">LinkedIn</a>



<a target="_blank" class="weibo" href="http://weibo.com/1826190094" title="weibo">Weibo</a>

<a target="_blank" class="github" target="_blank" href="https://github.com/CainRun" title="GitHub">GitHub</a>
<a target="_blank" class="email" href="mailto:zhebushimengfei@qq.com" title="Email">Email</a>

								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">

	<article class="post" itemscope itemtype="http://schema.org/BlogPosting">
		<h1 class="title" itemprop="name">玩转iOS开发：2.《Core Animation》初识CALayer</h1>
		<div class="entry-content" itemprop="articleBody">
			<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前面我们简单介绍了一些图层与视图的关系, 也介绍了<strong>CALayer</strong>以及<strong>UIView</strong>的相同点和区别, 没看过的朋友可以去看看<a href="https://cainrun.github.io/14770254062641.html">《Core Animation》基础概念</a>今天我们就着重的来讲讲<strong>CALayer</strong>.<br/>
<dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p>前面我们已经简单介绍了什么是<strong>CALayer</strong>, <strong>CALayer</strong>主要是用来做什么的, 现在我们来更加深入的了解<strong>CALayer</strong>到底有些什么东西供给我们去使用的.</p>
</blockquote>

<hr/>

<h3 id="toc_2">CALayer的Contents属性</h3>

<blockquote>
<p>在<strong>CALayer</strong>中, 有这么一个<strong>contents</strong>属性, 那么<strong>contents</strong>这个属性是用来做什么的呢? 我们先来看一段官方解释.</p>

<p><strong><font color=blue>An object that provides the contents of the layer. Animatable.</font></strong></p>

<p>从字面上意思来看, 这是一个提供图层内容的对象, 并且是<strong>id</strong>类型, 也就意味着, 我们可以给这个<strong>contents</strong>属性赋任意的值, 毕竟是<strong>id</strong>类型嘛, 但在实际操作中, 是行不通的, 为什么? </p>

<p>这里就要牵扯到<strong>Mac OS</strong>了, 因为在<strong>Mac OS</strong>当中, 给<strong>CALayer</strong>中的<strong>contents</strong>属性赋值, 无论是<strong>CGImage</strong>还是<strong>NSImage</strong>, 都能得到对应的效果, 而在<strong>iOS</strong>当中, 只能赋值<strong>CGImage</strong>, 或许到了这里, 你会觉得挺简单的, 但呵呵了, 这里还要牵扯到指针的问题(个人对指针有些晕).</p>

<p>实际上, 我们给<strong>contents</strong>属性赋<strong>CGImage</strong>的时候, 真正赋值的是<strong>CGImageRef</strong>, 它是指向<strong>CGImage</strong>的指针, 用过<strong>UIImage</strong>的朋友应该会发现,<strong>UIImage</strong>当中有一个<strong>CGImage</strong>的属性, 这个属性的返回值就是<strong>CGImageRef</strong>.</p>

<p>某些童鞋会说, 既然是<strong>CGImageRef</strong>类型的话, 那直接赋值给<strong>contents</strong>不就好了么, 其实并不是滴, 直接这么赋值会报编译错误滴, 为什么?? </p>

<p>因为<strong>CGImageRef</strong>并不是一个真正的<strong>Cocoa</strong>对象, 它是属于<strong>Core Foundation</strong>里的东西(什么是<strong>Core Foundation</strong>? 嘿嘿, 自行百度去吧~~), 那么我们就没办法给<strong>contents</strong>赋值吗? 肯定不是啦, 我们可以通过一些关键字进行赋值, 就能够得到对应的效果了, 代码如下:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
}
</code></pre>

<blockquote>
<p>这里提一点哈, 这个关键字在<strong>非ARC内存管理机制</strong>中是不需要加滴, 但是呢, 特么的, 你为啥不用<strong>ARC</strong>? 估计连你自己都会这么问你自己了.</p>

<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/1.png" alt="1"/></p>

<blockquote>
<p>看完效果图之后, 我们再看看它的层级结构, 你就会发现和我们使用的<strong>UIImageView</strong>完全一模一样, 不信? 我给你们加个UIImageView看看~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/2.png" alt="2"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/3.png" alt="3"/></p>

<blockquote>
<p>虽然我们并不是通过使用<strong>UIImageView</strong>来实现加载图片的, 但我们可以通过<strong>Layer</strong>层给<strong>UIView</strong>进行加载图片, 酱紫的话, 大家是不是对苹果如何封装<strong>UIImageView</strong>有了一个思路呢?</p>
</blockquote>

<hr/>

<h3 id="toc_3">CALayer的ContentGravity属性</h3>

<blockquote>
<p>不知道你们有没有发现, 我们所展示的图片有一些变形, 如果是用<strong>UIImageView</strong>的话, 我们可以直接设置<strong>contentModel</strong>这个属性, 使得图片正常显示, 但如果是在<strong>CALayer</strong>呢? </p>

<p>当然<strong>CALayer</strong>也有一个类似<strong>contentModel</strong>的属性, 它叫做<strong>contentGravity</strong>, 虽然名字有些差别, 但是使用效果都是差不多的~~</p>

<p>进入头文件之后我们会看到<strong>contentGravity</strong>可以赋值的选项有:</p>

<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill</li>
</ul>

<p>现在我们就来改改工程里的代码:</p>
</blockquote>

<pre><code class="language-objectivec">    layerView.layer.contentsGravity = kCAGravityResizeAspect;
</code></pre>

<blockquote>
<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/4.png" alt="4"/></p>

<blockquote>
<p>酱紫图片显示正确啦~~貌似<strong>UIImageView</strong>的<strong>contentModel</strong>也就是这么实现的~</p>
</blockquote>

<hr/>

<h3 id="toc_4">CALayer的ContentsScale属性</h3>

<blockquote>
<p>其实我在想, 我是不是不应该把<strong>CALayer</strong>里的所有属性都拿出来讲一讲? 只是简单讲一些重要的好了, 接下来的就是<strong>contentsScale</strong>.</p>

<p><strong>contentsScale</strong>这个属性主要是定义图层的像素和视图比例大小, 默认情况是<strong>1.0</strong>, 而且是<strong>CGFloat</strong>类型.</p>

<p>但如果你的<strong>CALayer</strong>已经设置了<strong>contentsGravity</strong>, 那么再设置<strong>contentsScale</strong>, 效果就是没多大影响, 或者直接说压根就没影响吧, 如果你只是想着单纯的放大缩小<strong>CALayer</strong>, 可以直接使用<strong>transform</strong>和<strong>affineTransForm</strong>实现你想要的效果, 后续会详细讲解<strong>transforms</strong>.</p>

<p>当然放大缩小肯定也不是<strong>contentsScale</strong>属性的主要作用, 这里就需要解释一下<strong>contentsScale</strong>: </p>

<p><strong>contentsScale</strong>主要是支持Retina机制的一部分, 它是用来判断绘制图层时应该需要创建多大的空间, 和需要显示图片的拉伸度,<strong>UIView</strong>也有一个类似的属性, 叫做<strong>contentScaleFactor</strong>, 只是我们非常少的去使用罢了.</p>

<p>这个时候我们来改改工程里的代码, 让<strong>contentsScale</strong>呈现效果: </p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
    
    layerView.layer.contentsGravity = kCAGravityCenter;
    layerView.layer.contentsScale = image.scale;
}
</code></pre>

<blockquote>
<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_5">CALayer的MaskToBounds属性</h3>

<blockquote>
<p>看完了<strong>contentsScale</strong>属性, 现在我们继续来看<strong>maskToBounds</strong>属性.</p>

<p>我们先来看一段官方文字介绍: </p>

<p><strong><font color=blue>A Boolean indicating whether sublayers are clipped to the layer’s bounds. Animatable.</font></strong></p>

<p>看完之后, 我们知道这个属性是一个<strong>BOOL</strong>类型, 问你如果子图层超出了视图层, 是否剪切掉, 如果你设置为<strong>YES</strong>, 那就剪切掉了, 默认为<strong>NO</strong>.</p>

<p>就拿我们刚刚的工程作为一个事例来讲, 那张图片肯定是超过了视图层的, 如果我们把<strong>maskToBounds</strong>属性设置为<strong>YES</strong>, 效果就不一样了:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
    
    layerView.layer.contentsGravity = kCAGravityCenter;
    layerView.layer.contentsScale = image.scale;
    layerView.layer.masksToBounds = YES;
}
</code></pre>

<blockquote>
<p>效果图:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/6.png" alt="6"/></p>

<hr/>

<h3 id="toc_6">CALayer的ContentsRect属性</h3>

<blockquote>
<p><strong>CALayer</strong>有一个属性叫做<strong>contentsRect</strong>, 它是可以根据输入的坐标轴来显示区域块的图层, 而<strong>frame</strong>,<strong>bounds</strong>则是以点来计算的, 在这里它们有一些区别.</p>

<p>还有一个注意点, <strong>contentsRect</strong>的坐标轴默认是<strong>{0, 0, 1, 1}</strong>, 单位坐标一般指定的是<strong>0~1</strong>之间, 如果小于这个数, 或者是大于这个数, 哼哼, 你自己试试看吧~</p>

<p>说到这里, 应该会有人有些疑惑, 神马是点? 难道和像素不一样的么? 那就先来普及一下先吧(这里我是搜到的一些比较中肯的说法)~</p>
</blockquote>

<p></br></p>

<blockquote>
<p>点: </p>

<ul>
<li>在<strong>iOS</strong>和<strong>Mac OS</strong>中最常见的坐标体系。</li>
<li>点就像是虚拟的像素, 也被称作逻辑像素。</li>
<li>在标准设备上, 一个点就是一个像素, 但是在<strong>Retina</strong>设备上, 一个点等于<strong>2*2</strong>个像素。</li>
<li><strong>iOS</strong>用点作为屏幕的坐标测算体系就是为了在<strong>Retina</strong>设备和普通设备上能有一致的视觉效果。</li>
</ul>
</blockquote>

<p></br></p>

<blockquote>
<p>像素:</p>

<ul>
<li>物理像素坐标并不会用来屏幕布局, 但是仍然与图片有相对关系。 </li>
<li><strong>UIImage</strong>是一个屏幕分辨率解决方案, 所以指定点来度量大小。</li>
<li>但是一些底层的图片表示如<strong>CGImage</strong>就会使用像素, 所以你要清楚在<strong>Retina</strong>设备和普通设备上, 他们表现出来了不同的大小。</li>
</ul>
</blockquote>

<p></br></p>

<blockquote>
<p>单位: </p>

<ul>
<li>对于与图片大小或是图层边界相关的显示, 单位坐标是一个方便的度量方式, 当大小改变的时候, 也不需要再次调整。</li>
<li>单位坐标在<strong>OpenGL</strong>这种纹理坐标系统中用得很多,<strong>Core Animation</strong>中也用到了单位坐标。</li>
</ul>
</blockquote>

<p></br></p>

<blockquote>
<p>这里我们还是继续拿刚刚的工程来演示: </p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
    
    layerView.layer.contentsGravity = kCAGravityCenter;
    layerView.layer.contentsScale = image.scale;
    layerView.layer.masksToBounds = YES;
    layerView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5);
}
</code></pre>

<blockquote>
<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/7.png" alt="7"/></p>

<blockquote>
<p>补充一些额外的知识点:</p>

<p><strong>contentsRect</strong>在<strong>App</strong>当中, 还有一个更好玩的用法叫做<strong>image sprites</strong>, 如果你有游戏开发经验的话, 你肯定对<strong>image sprites</strong>不陌生, 甚至是非常熟练的使用, 可以使图片独立的变更在屏幕上显示的位置.</p>

<p>但如果我们抛开游戏开发来说的话, 在我们日常生活当中, 微博就是一个经典的代表, 把图片拼接成一张大图片, 然后再分享出去, 这里使用的就是<strong>contentsRect</strong>, 这样子的好处就是可以减少内存的使用, 载入的时间, 还有渲染的性能等等.</p>

<p>这里我就不做演示了, 感兴趣的童鞋可以 到网上找找资料.</p>
</blockquote>

<hr/>

<h3 id="toc_7">CALayer的ContentsCenter属性</h3>

<blockquote>
<p>讲到这里, 已经算是<strong>CALayer</strong>最后的一个属性了, 它叫做<strong>contentsCenter</strong>, 它的意思比较拗口, 它是一个<strong>CGRect</strong>, 且定义了一个固定的边框和一个图层上可拉伸的区域.</p>

<p>如果你只是单单改变<strong>contentsCenter</strong>的值, 并不会影响到<strong>CALayer</strong>的显示效果, 要同时去改变这个图层的大小, 才能看到效果.</p>

<p>我们还是直接看代码吧, 在我们原先的项目上添加一个方法, 并且加多一个<strong>UIView</strong>类:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    /**
     *  Contents
     */
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
    
    /**
     *  ContentsGravity
     */
    layerView.layer.contentsGravity = kCAGravityCenter;
    
    /**
     *  ContentsScale
     */
    layerView.layer.contentsScale = image.scale;
    
    /**
     *  MasksToBounds
     */
    layerView.layer.masksToBounds = YES;
    
    /**
     *  contentsRect
     */
    layerView.layer.contentsRect = CGRectMake(0, 0, 1.1, 1.1);
    
    
    [self addImage:[UIImage imageNamed:@&quot;bear&quot;] withContensRect:CGRectMake(0.25, 0.25, 0.5, 0.5)];
}

- (void)addImage:(UIImage *)image withContensRect:(CGRect)rect {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
    
    view.layer.contents = (__bridge id _Nullable)(image.CGImage);
    view.layer.contentsCenter = rect;
    
    [self.view addSubview:view];
}
</code></pre>

<blockquote>
<p>效果图:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/8.png" alt="8"/></p>

<blockquote>
<p>补充一个知识点, 如果你是使用Storyboard或者是xib的话, 你可以在右侧的栏目看到<strong>contentsCenter</strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/9.png" alt="9"/></p>

<hr/>

<h3 id="toc_8">CALayer的Delegate</h3>

<blockquote>
<p>降到这里, 基本上就已经介绍完了<strong>CALayer</strong>, 但还有一点也是需要提一提的, <strong>CALayer</strong>除了使用<strong>contents</strong>赋值<strong>CGImage</strong>来显示图层之后, 还可以使用<strong>Core Graphics</strong>去进行绘制, 在<strong>UIView</strong>就可以看到这个方法, 叫做<strong>-drawRect:</strong>.</p>

<p><strong>-drawRect:</strong>方法默认没有去实现, 因为在<strong>UIView</strong>中,<strong>backing image</strong>并不是必须的, 但如果你去调用<strong>-drawRect:</strong>方法, 那么UIView就会给你生成一个新的<strong>backing image</strong>, 而这个<strong>backing image</strong>的像素尺寸等于视图大小乘以<strong>contentsScale</strong>的值.</p>

<p>这里需要注意一个点, 如果你的视图里不需要创建一个<strong>backing image</strong>的话, 千万不要去写一个空的<strong>-drawRect:</strong>方法, 这样子就会对CPU与内存造成浪费, 这也是苹果官方建议的.</p>

<p>我们先来解释一下<strong>-drawRect:</strong>方法的实现原理:</p>

<ul>
<li>当<strong>-drawRect:</strong>被调用,<strong>UIView</strong>会创建一个新的<strong>backing image</strong>.</li>
<li>会使用<strong>Core Graphics</strong>对<strong>backing image</strong>进行描绘.</li>
<li>然后这个描绘好的<strong>backing image</strong>会被缓存起来, 等到它需要被更新的时候, 就会去使用.</li>
</ul>

<p>当然, 我们自己也可以手动去调用, 比如去调用<strong>-setNeedsDisplay:</strong>, 那么被重新绘制的<strong>backing image</strong>就会立马显示出来了.</p>

<p>总而言之, <strong>-drawRect:</strong>看似是<strong>UIView</strong>的方法, 但实际上都是在内部对CALayer进行了重绘以及缓存的操作.</p>

<p>还有, <strong>CALayer</strong>也有一个<strong>delegate</strong>的属性, 而且是<strong>id</strong>类型, 并实现<strong>CALayerDelegate</strong>协议, 当<strong>CALayer</strong>需要一个特定内容时, 就会从代理方法里去请求, 由于<strong>CALayerDelegate</strong>是一个非正式的协议, 所以并没有神马属性给你引用, 直接调用代理方法就可以了.</p>

<p>当需要被重绘的时候, <strong>CALayer</strong>就会去调用:</p>
</blockquote>

<pre><code class="language-objectivec">    -(void)displayLayer:(CALayer *)layer;
</code></pre>

<blockquote>
<p>如果你还想再重绘的时候设置一下<strong>contents</strong>的话, 那么就要在这个方法里去实现, 不然在别的方法里就没法做到了.</p>

<p>但如果没有实现以上的方法时, 那么就会去调用:</p>
</blockquote>

<pre><code class="language-objectivec">    - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
</code></pre>

<blockquote>
<p>在调用这个方法之前, <strong>CALayer</strong>会创建一个适合尺寸的<strong>backing image</strong>, 当然, 尺寸肯定是由<strong>bounds</strong>和<strong>contentsScale</strong>决定的, 还有一个<strong>Core Graphics</strong>绘制的上下文, 未绘制<strong>backing image</strong>做准备, 等的就是<strong>ctx</strong>的传入.</p>

<p>说了那么多我们直接用代码演示吧~</p>
</blockquote>

<pre><code class="language-objectivec">- (void)createNewLayerWithSuperView {
    
    // Background View
    UIView *backgroundView = [[UIView alloc] initWithFrame:CGRectMake(220, 0, 100, 100)];
    backgroundView.backgroundColor = [UIColor whiteColor];
    
    [self.view addSubview:backgroundView];
    
    // Blue Layer
    CALayer *blueLayer = [CALayer layer];
    
    blueLayer.frame = CGRectMake(25, 25, 50, 50);
    blueLayer.backgroundColor = [UIColor blueColor].CGColor;
    
    // Set Layer Delegate
    blueLayer.delegate = self;
    
    // Set Layer contentsScale
    blueLayer.contentsScale = [UIScreen mainScreen].scale;
    
    [backgroundView.layer addSublayer:blueLayer];
    
    [blueLayer display];
}

- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {
    
    CGContextSetLineWidth(ctx, 5);
    CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
    CGContextStrokeEllipseInRect(ctx, layer.bounds);
}
</code></pre>

<blockquote>
<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/10.png" alt="10"/></p>

<blockquote>
<p>看到效果图代码之后, 有两点我们是需要注意一下的:</p>

<ul>
<li>不同的<strong>CALayer</strong>在不同的<strong>UIView</strong>视图中使用, 是不会自动去重载它的内容的, 所以在事例当中, 我们用<strong>blueLayer</strong>调用了<strong>display</strong>这个方法.</li>
<li>在事例当中, 我们并没有对<strong>blueLayer</strong>设置<strong>masksToBounds</strong>属性, 但所绘制的那个圆仍然被裁剪了一些, 这个是因为我们在使用<strong>CALayerDelegate</strong>的时候, 并没有让需要描绘的<strong>backing image</strong>支持超出边界外的支持.</li>
</ul>

<p>聊到这里, 虽然我们知道了<strong>CALayerDelegate</strong>, 但在实际开发当中, 我们基本上非常非常少去接触它, 因为当<strong>UIView</strong>创建<strong>backing image</strong>的时候, 就会默认把<strong>CALayerDelegate</strong>设置为它自己, 同时也会提供一个<strong>- (void)displayLayer:(CALayer *)layer;</strong>的实现, 所以基本上不会遇到什么问题.</p>

<p>当你使用有<strong>backing image</strong>的<strong>UIView</strong>时, 你也不必实现下面两个方法</p>
</blockquote>

<pre><code class="language-objectivec">    - (void)displayLayer:(CALayer *)layer;
    - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
</code></pre>

<blockquote>
<p>因为<strong>UIView</strong>提供了一个<strong>- (void)drawRect:(CGRect)rect;</strong>的方法, 只要你实现了这个方法, 那么剩下的东西<strong>UIView</strong>都是全部帮你完成.</p>
</blockquote>

<hr/>

<h3 id="toc_9">总结一下</h3>

<blockquote>
<p>不得不说, 这次的内容有些多, 还是来总结一下:</p>

<ul>
<li><strong>contents</strong>是给<strong>CALayer</strong>设置内容的一个属性</li>
<li><strong>ContentGravity</strong>是给<strong>CALayer</strong>设置内容的显示, 类似<strong>UIView</strong>的<strong>contentModel</strong>.</li>
<li><strong>contentsScale</strong>定义图层的像素和视图比例大小, 默认大小为<strong>1.0f</strong>, 并且是CGFloat类型.</li>
<li><strong>maskToBounds</strong>是一个<strong>BOOL</strong>类型, 默认为<strong>NO</strong>, 如果设置为<strong>YES</strong>, 则会裁剪掉超出视图的部分.</li>
<li><strong>contentsRect</strong>是一个坐标轴, 默认是<strong>CGRectMake(0, 0, 1, 1)</strong>, 输入对应的坐标轴, 可以让<strong>CALayer</strong>显示所输入坐标轴的区域内容.</li>
<li><strong>cntentsCenter</strong>是用来定义一个固定的边框和一个图层上可拉伸的区域.</li>
<li><strong>delegate</strong>是用来定义CALayerDelegate对象, 当UIView创建CALayer的时候, 默认就会实现, 并且提供一个<strong>- (void)displayLayer:(CALayer *)layer;</strong>方法的实现.</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_10">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_11">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

		</div>
	</article>
	<div class="share-comment">
	 

	  

	  
	      <div class="ds-thread" data-thread-key="14771496782021.html" data-url="https://cainrun.github.io/14771496782021.html" data-title="玩转iOS开发：2.《Core Animation》初识CALayer"></div>
	  

	</div>
</div>        </div>
    		<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="https://cainrun.github.io">Cain</a>    
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
    	</div>
    </div>

  


<script type="text/javascript">
var duoshuoQuery = {short_name:'cainluo'};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
  </script>
    
<script src="asset/chart/all-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"></div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({TeX: { equationNumbers: { autoNumber: "AMS" } }});</script>

</body>
</html>