<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Cain For iOS]]></title>
  <link href="https://cainrun.github.io/atom.xml" rel="self"/>
  <link href="https://cainrun.github.io/"/>
  <updated>2017-06-29T12:51:29+08:00</updated>
  <id>https://cainrun.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS中的Socket编程(二)]]></title>
    <link href="https://cainrun.github.io/14987134210457.html"/>
    <updated>2017-06-29T13:17:01+08:00</updated>
    <id>https://cainrun.github.io/14987134210457.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">接着讲</h3>

<p>在之前的那篇文章, 我们了解了一些关于<code>Socket</code>的基础知识, 如果没有去看的朋友, 可以去看看<a href="https://cainrun.github.io/14986613643920.html">玩转iOS开发：iOS中的Socket编程(一)</a>.</p>

<p>那么现在我们继续来讲讲剩下的一丢丢知识, 然后就开始来写我们的代码~</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">建立TCP连接</h3>

<p>上一讲也说了, <code>Socket</code>是基于<code>TCP/IP</code>上的封装, 如果要了解<code>Socket</code>的连接, 就要从<code>TPC/IP</code>的连接入手.</p>

<p>我们日夜不分离的手机之所以能联网, 也是因为手机的底层实现了<code>TCP/IP</code>协议, 可以让手机通过<code>WiFi</code>, <code>4G</code>等无线网络进行通信.</p>

<p>建立起一个<code>TCP</code>连接, 需要通过三次的验证, 我们这里称为<code>三次握手</code>:</p>

<ul>
<li>第一次握手: 由客户端发送一个叫做<code>SYN(SYN=J)</code>包到服务器, 并且进入<code>SYN_SEND</code>状态, 然后就翘着二郎腿等服务器回应.</li>
<li>第二次握手: 服务器接收到了<code>SYN</code>包, 必须确认客户端的<code>SYN(ACK=J+1)</code>, 同时也会发送一个<code>SYN(SYN=K)</code>包, 也就是<code>SYN+ACK</code>, 此时轮到服务器跷二郎腿, 并且进入<code>SYN_RECV</code>状态.</li>
<li>第三次握手: 接收到了服务器发来的<code>SYN+ACK</code>包, 并向服务器发送确认包<code>ACK(ACK=K+1)</code>, 发完之后, 客户端和服务器就会收起二郎腿并且进入<code>ESTABLISHED</code>状态, 完成了三次握手</li>
</ul>

<p>大概的情况就是酱紫:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/Socket%E7%BC%96%E7%A8%8B(%E4%BA%8C)/1.png" alt="1"/></p>

<p>这里注意一下, 在进行握手的时候, 所传送的包并不包含数据.</p>

<p>只有在完成三次握手之后, 客户端和服务器才会正式开始传输数据, 一般在<code>TCP</code>连接建立成功后, 除非有一方主动关闭连接之前, <code>TCP</code>连接是会一直保持下去的, 比如我们的<code>微信</code>, <code>QQ</code>这些即时聊天<code>App</code>.</p>

<hr/>

<h3 id="toc_2">关闭TCP连接</h3>

<p>刚刚说完了如何建立起<code>TCP</code>的连接, 现在我们来看看怎么关闭.</p>

<p>客户端和服务器都可以发起关闭<code>TCP</code>连接的请求, 但是需要通过四次验证, 我们这里称为<code>四次挥手</code>, 这里我们演示由客户端发起关闭<code>TCP</code>连接: </p>

<ul>
<li>第一次挥手: 客户端会发送一个<code>FIN</code>的报文给服务器之后就会进入等待服务器的响应.</li>
<li>第二次挥手: 服务器接收到了<code>FIN</code>之后, 并确认是由客户端发起的, 同时也会发送一条<code>ACK=X+1</code>的报文.</li>
<li>第三次挥手: 等到客户端接受到<code>ACK</code>报文之后, 服务器关闭了与客户端的连接, 会发送一条<code>FIN</code>的报文给客户端.</li>
<li>第四次挥手: 客户端接收到了由服务器发送过来的<code>FIN</code>报文, 就会关闭与服务端的连接, 并且发送<code>ACK</code>给服务器.</li>
</ul>

<p>关系图:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/Socket%E7%BC%96%E7%A8%8B(%E4%BA%8C)/2.png" alt="2"/></p>

<p>有人或许有疑问说为啥<code>TCP</code>建立连接的时候是三次握手, 而断开连接的时候却是四次挥手呢?</p>

<p>因为连接时服务端收到了客户端的<code>SYN</code>连接请求的报文后, 可以直接发送<code>SYN+ACK</code>报文, 其中的<code>ACK</code>报文是用来响应, <code>SYN</code>报文是用来同步的.</p>

<p>而当关闭连接时, 服务端收到<code>FIN</code>报文后, 很可能并不会马上就关闭<code>Socket</code>连接, 所以只能先回复一个<code>ACK</code>报文, 告诉客户端, 你发的<code>FIN</code>报文我收到了, 只有等到服务器的所有报文发送完了, 服务端才会发送<code>FIN</code>报文, 所以才需要四次挥手.</p>

<hr/>

<h3 id="toc_3">HTTP连接</h3>

<p>本来并不打算把<code>HTTP/HTTPS</code>也讲了, 但既然都说到这, 还是补上吧.</p>

<p><code>HTTP</code>是一个超文本传输协议, 全名叫做<code>Hyper Text Transfer Protocol</code>, 是<code>Web</code>互联网的基础, 也是我们手机联网常用的协议之一, 顺便说说, <code>HTTP</code>协议是建立在<code>TCP</code>协议之上的一种应用.</p>

<p>用过<code>HTTP</code>请求的都知道, <code>HTTP</code>最显著的一个特点就是客户端每次发送的网络请求都需要服务端的响应, 在请求结束后, 会主动的关闭连接.</p>

<p>由于建立连接到关闭连接是<code>一次性连接</code>, 所以<code>HTTP/HTTPS</code>会被称为<code>短连接</code>, 如果要保持长期在线的话, 需要不停的像服务器发送请求, 如果服务器长时间没有接收到客户端的请求, 就会认为客户端<code>下线</code>了, 反过来, 如果客户端长时间没有接收到服务器的响应, 则认为<code>网络断开</code>.</p>

<p>在<code>HTTP 1.0</code>中, 客户端的每次请求都要求建立一次单独的连接, 在处理完本次请求后, 就自动释放连接. 而<code>HTTP 1.1</code>中则可以在一次连接中处理多个请求，并且多个请求可以重叠进行, 不需要等待一个请求结束后再发送下一个请求, 现在最新的<code>HTTP 2.0</code>是兼容<code>HTTP 1.1</code>的, 虽然说是新版, 但我个人感觉好像是优化版本, 只是提高了<code>Web</code>的性能.</p>

<hr/>

<h3 id="toc_4">HTTPS连接</h3>

<p><code>HTTPS</code>全名叫做<code>Hyper Text Transfer Protocol over Secure Socket Layer</code>, 是<code>HTTP</code>的安全版本, 主要是在<code>HTTP</code>加了一层<code>SSL</code>, 所以加密的时候就要用到<code>SSL</code>加密.</p>

<p><code>HTTPS</code>存在于<code>HTTP</code>与<code>TCP</code>之间, <code>HTTP</code>是以明文发送的, 不提供任何方式的数据加密, 所以非常容易受到攻击, 因为<code>HTTP</code>协议不方便用来传输敏感信息, 但<code>HTTPS</code>比较麻烦, 因为需要去申请一个<code>CA</code>证书. </p>

<p><code>HTTP</code>和<code>HTTPS</code>的区别:</p>

<ul>
<li><code>HTTP</code>是超文本传输协议, 信息是明文传输, <code>HTTPS</code>则是具有安全性的<code>SSL</code>加密传输协议.</li>
<li><code>HTTP</code>和<code>HTTPS</code>使用的是完全不同的连接方式, 用的端口也不一样, 前者是80, 后者是443.</li>
<li><code>HTTP</code>的连接很简单, 是无状态的, <code>HTTPS</code>协议是由<code>HTTP + SSL</code>协议构建的可进行加密传输、身份认证的网络协议.</li>
</ul>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/Socket%E7%BC%96%E7%A8%8B(%E4%BA%8C)/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_5">Socket与HTTP的区别</h3>

<p>虽然说<code>Socket</code>和<code>HTTP</code>都是基于<code>TCP</code>, 但通常情况下<code>Socket</code>连接就是<code>TCP</code>连接, 一旦建立了<code>Socket</code>连接, 双方就可以相互发送数据, 直到双方连接断开为止.</p>

<p>但在实际应用中，客户端到服务器之间的通信防火墙默认会关闭长时间处于非活跃状态的连接, 从而而导致<code>Socket</code>连接断连，因此需要通过轮询告诉网络，该<code>Socket</code>连接处于活跃状态。</p>

<p>而<code>HTTP</code>刚刚也说了, 它的连接方式是<code>请求 -&gt; 响应</code>, 不仅要在请求的时候需要先建立好连接, 而且需要客户端向服务器发送请求后, 服务器才能回复数据.</p>

<hr/>

<h3 id="toc_6">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS中的Socket编程(一)]]></title>
    <link href="https://cainrun.github.io/14986613643920.html"/>
    <updated>2017-06-28T22:49:24+08:00</updated>
    <id>https://cainrun.github.io/14986613643920.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Socket的解释</h3>

<p><code>Socket</code>翻译过来中文称为<code>套接字</code>, 这里我找到了一段比较官方的解释<code>Socket</code>是什么东西: </p>

<blockquote>
<p><code>Socket</code>是通信的基石，是支持<code>TCP/IP</code>协议的网络通信的基本操作单元，包含进行网络通信必须的五种信息：<code>连接使用的协议</code>，<code>本地主机的IP地址</code>，<code>本地进程的协议端口</code>，<code>远地主机的IP地址</code>，<code>远地进程的协议端口</code>。</p>
</blockquote>

<p>在实际当中, 肯定是不止一个<code>TCP/IP</code>或者是一个应用程序进程在传输数据, 为了可以区分开来, 系统提供了一套<code>API</code>, 方便<code>TCP/IP</code>与应用程序交互, 一般把这个称为<code>Socket API</code>.</p>

<p>酱紫应用层可以和传输层通过这个<code>Socket API</code>, 区分来自不同的应用程序进程或者是网络通信, 使得数据可以并发传输.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">Socket的C/S端</h3>

<p><code>Socket</code>的使用其实也没有我们想象中那么难, 只是这里需要有一个前提条件, 因为建立<code>Socket</code>通信是至少需要一对<code>套接字</code>, 其中一个是运行在我们的客户端上, 称为<code>Client Socket</code>, 还有一个是运行在服务器上, 称为<code>Service Socket</code>.</p>

<p><code>Socket</code>之间的连接过程分为三个过程: </p>

<ul>
<li>服务器监听</li>
<li>客户端请求</li>
<li>连接确认</li>
</ul>

<p><code>Socket</code>同时支持<code>TCP</code>和<code>UDP</code>两种传输协议, 啥意思呢?</p>

<p>当<code>Socket</code>使用<code>TCP</code>协议通信的时候, <code>Socket</code>就是一个<code>TCP</code>的连接, 那么如果<code>Socket</code>使用的是<code>UDP</code>协议通信, 那么这时候的<code>Socket</code>就是<code>UDP</code>连接.</p>

<p>如果要有图的话, 大概就这样了:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/Socket%E7%BC%96%E7%A8%8B(%E4%B8%80)/1.png" alt="1"/></p>

<hr/>

<h3 id="toc_2">网络的协议</h3>

<p>既然降到<code>Socket</code>, 那么就要说说网络里面的协议, 这里就要普及一下网络里面的到底都有啥, 首先我们要知道, 在网络里面一共有<code>七层协议</code>.</p>

<p>从上往下分的话:</p>

<ul>
<li>应用层</li>
<li>表达层</li>
<li>会话层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/Socket%E7%BC%96%E7%A8%8B(%E4%B8%80)/2.png" alt="2"/></p>

<p>但我们通常会把底下三层(<code>网络层</code>, <code>数据链路层</code>, <code>物理层</code>)统称为<code>媒体层</code>, 一般都是专门搞网络的网络工程师大神们研究的对象.</p>

<p>而上面四层(<code>传输层</code>, <code>会话层</code>, <code>表示层</code>, <code>应用层</code>)被称为<code>主机层</code>, 也是广大用户所面向和关心的内容.</p>

<p>说到协议, 我们就不得不提一下<code>HTTP</code>:</p>

<ul>
<li><code>HTTP</code>协议: 它是对应着<code>应用层</code>.</li>
<li><code>TCP</code>协议: 它是对应着<code>传输层</code>.</li>
<li><code>IP</code>协议: 则对应着<code>网络层</code>.</li>
</ul>

<p>而<code>HTTP</code>协议是基于<code>TCP</code>连接的, 所以三者根本就没啥可比性.</p>

<ul>
<li><code>TCP/IP</code>协议: 属于传输层协议, 主要解决数据如何在网络中传输.</li>
<li><code>HTTP</code>协议: 属于应用层, 主要解决如何包装数据.</li>
</ul>

<p>而<code>Socket</code>是<code>应用层</code>与<code>TCP/IP</code>协议族通信中间的软件抽象层, 是它的一组接口.</p>

<hr/>

<h3 id="toc_3">TCP/IP五层模型</h3>

<p>既然都提到了<code>TCP/IP</code>这个协议, 那么就来讲讲, <code>TCP/IP</code>里的五层模型.</p>

<p>这里面的五层模型分别为:</p>

<ul>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>数据链路层</li>
<li>物理层</li>
</ul>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/Socket%E7%BC%96%E7%A8%8B(%E4%B8%80)/3.png" alt="3"/></p>

<p>那么我们日常生活中所接触到的网络器材有哪些? 分别处于哪个模型?</p>

<ul>
<li>物理层: 中继器, 集线器, 双绞线</li>
<li>数据链路层: 以太网交换机(Modem), 网卡(网卡有一半是工作在物理层)</li>
<li>网络层: 路由器, 三层交换机</li>
<li>传输层: 四层交换机, 路由器(也有一些特殊的路由器在传输层中工作)</li>
</ul>

<p>其中<code>TCP/IP</code>的<code>应用层</code>比较特殊, 它是包含了<code>会话层</code>, <code>表达层</code>, <code>应用层</code>等功能, 这里要说一点, <code>TCP/IP</code>协议并不能在传输层总是保证可靠的传输数据包, 但七层模型可以做到.</p>

<p><code>TCP/IP</code>还提供了另一种传输模式, 叫做<code>UDP(用户数据报协议)</code>, 但这种协议不能保证可靠的数据包传输.</p>

<p>这里再解释一下:</p>

<ul>
<li><code>TCP</code>: 面向连接, 提供可靠的数据传输, 用于传输大量数据, 使用数据流模式, 速度慢, 建立连接时开销较大</li>
<li><code>UDP</code>: 非面向连接, 传输不可靠, 用于传输少量的数据, 速度快</li>
</ul>

<p>总的来说<code>TCP</code>是一个数据流的模式协议, 而<code>UDP</code>是一种数据报模式的协议.</p>

<p>刚刚说了<code>Socket</code>是基于<code>TCP/IP</code>协议上的抽象, 也就是说<code>Socket</code>只是对<code>TCP/IP</code>的封装, 本身是没有协议的, 只有通过<code>Socket API</code>, 我们才能够使用<code>TCP/IP</code>协议.</p>

<p>大概的关系图就是酱紫吧:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/Socket%E7%BC%96%E7%A8%8B(%E4%B8%80)/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_4">总结</h3>

<p>这篇文章虽然不涉及任何的代码, 但都是一些必备的基础知识, 如果想更详细的了解或者是找更官方的文档, 可以去看看苹果爸爸提供的<a href="https://developer.apple.com/library/content/documentation/NetworkingInternetWeb/Conceptual/NetworkingOverview/Introduction/Introduction.html">Networking Overview</a>这篇文章.</p>

<hr/>

<h3 id="toc_5">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：NSURLSession讲解(三)]]></title>
    <link href="https://cainrun.github.io/14986211698053.html"/>
    <updated>2017-06-28T11:39:29+08:00</updated>
    <id>https://cainrun.github.io/14986211698053.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">前言</h3>

<p>虽然前面两讲都是说了<code>NSURLSession</code>的一些理论上的知识, 但我们现在起码对<code>NSURLSession</code>有个大概的了解, 并不会像一开始的那样, 一脸懵逼的看着, 这个请求是什么鬼, 那个方法是什么鬼, <code>Task</code>是什么东西, 如果没有去看的朋友们可以去看看前面两讲<a href="https://cainrun.github.io/14980521480137.html">玩转iOS开发：NSURLSession讲解(一)</a>和 <a href="https://cainrun.github.io/14981091675323.html">玩转iOS开发：NSURLSession讲解(二)</a>, 大神就随意啦.</p>

<p>这里的工程是仿照<a href="https://www.raywenderlich.com">RayWenderlich</a><code>(需要翻墙)</code>的一篇文章<a href="https://www.raywenderlich.com/158106/urlsession-tutorial-getting-started">URLSession Tutorial: Getting Started</a>, 喜欢看原文或者是<code>Swift</code>的朋友也可以去看看, 我这个是<code>Objective-C</code>版本的.</p>

<p><strong>注意: 本工程是在<code>Xcode 9 beta 2</code>, <code>iOS 11</code>的环境下运行的.</strong></p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">搭建界面</h3>

<p>这里我要说明一下, 原文里的界面是使用<code>Storyboard</code>来搭建的, 我这里是使用代码和<a href="https://github.com/SnapKit/Masonry">Masonry</a>, 这里再次和大神表示感谢.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%89)/Images/1.png" alt="1"/></p>

<p>搭建好的界面也很简单, 就一个<code>UITableView</code>, <code>UITableViewCell</code>和<code>UISearchBar</code>, 就完事了, 布局的代码都在项目里, 由于个人没有什么艺术细胞, 所以界面略丑, 大家凑合着看吧.</p>

<hr/>

<h3 id="toc_2">项目架构</h3>

<p>为了让大家阅读起来比较方便和清晰, 我这里用了我一向习惯的<code>MVVM</code>架构模式, 虽然文件多了点, 但每个文件的代码都保证在了<code>200</code>行之内, 个人感觉看起来还是比较舒服的.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%89)/Images/2.png" alt="2"/></p>

<hr/>

<h3 id="toc_3">实现下载</h3>

<p>在项目里面有一个<code>QueryService</code>和一个<code>DownloadService</code>, 都是负责管理下载和一些网络请求, 由于代码太多了, 这里我就讲讲思路好了.</p>

<p><code>QueryService</code>: 负责实现用<code>UISearchBar</code>的搜索网络请求, 当<code>UISearchBar</code>输入关键字的时候, 通过指定的<code>URL</code>和<code>Query</code>拼接成一条有效的搜索链接, 并且通过<code>NSURLSessionDataTask</code>进行网络请求, 成功后会进行数据的解析, 并且通过<code>SearchModel</code>进行组装, 然后添加到一个<code>NSMutableArray</code>对象里, 最后<code>UITableView</code>会通过这个<code>NSMutableArray</code>作为数据源来刷新整个<code>UITableView</code>.</p>

<p><code>DownloadService</code>: 负责实现<code>UITableViewCell</code>通过<code>DownloadModel</code>点击开始下载, 暂停, 恢复下载, 取消下载等等操作.</p>

<p>当然这里我们还需要实现一个叫做<code>NSURLSessionDownloadDelegate</code>和 <code>NSURLSessionDelegate</code>两个协议, 分别实现:</p>

<pre><code class="language-objectivec">// 下载完成后的操作方法
- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
didFinishDownloadingToURL:(NSURL *)location;

// 正在下载时的操作方法
- (void)URLSession:(NSURLSession *)session
      downloadTask:(NSURLSessionDownloadTask *)downloadTask
      didWriteData:(int64_t)bytesWritten totalBytesWritten:(int64_t)totalBytesWritten
totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite;

// 后台下载完成后的方法
- (void)URLSessionDidFinishEventsForBackgroundURLSession:(NSURLSession *)session;
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%89)/Images/3.png" alt="3"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%89)/Images/4.png" alt="4"/></p>

<p>这里面的实现可以去<code>SearchSessionDelegate</code>里面看看, 这里就不详细多说了.</p>

<p>整个项目的核心内容就在这里了, 更详细的细节, 大家可以去项目里自己看看哈, 这里就不浪费大家的时间了.</p>

<p>最终的效果:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%89)/Images/5.gif" alt="5"/></p>

<hr/>

<h3 id="toc_4">总结</h3>

<p>最后唠叨两句, 由于我这个只是<code>Demo</code>, 里面存在的<code>Bug</code>, 还有不完善的封装请大家多多见谅, 这里顺便推两个优秀的开源下载管理器<a href="https://github.com/Heikowi/HWIFileDownload">HWIFileDownload</a>, <a href="https://github.com/thibaultCha/TCBlobDownload">TCBlobDownload</a>.</p>

<p>如果有童鞋想自己封装一个的话, 也可以去看看这几篇文章<a href="http://www.cnblogs.com/machao/p/5864251.html">MCDownloadManager ios文件下载管理器</a>, <a href="http://www.cocoachina.com/ios/20160530/16496.html">手把手教你封装下载管理器</a>, 还有这个经验贴<a href="http://mobilev5.github.io/2016/03/13/meeting-common-urldownloader/">iOS通用下载管理器-HJMURLDownloader</a>.</p>

<p>祝大家学习愉快.</p>

<hr/>

<h3 id="toc_5">工程地址:</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-NetWork/tree/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%89)">https://github.com/CainRun/iOS-NetWork/tree/master/NSURLSession讲解(三)</a></p>

<hr/>

<h3 id="toc_6">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：NSURLSession讲解(二)]]></title>
    <link href="https://cainrun.github.io/14981091675323.html"/>
    <updated>2017-06-22T13:26:07+08:00</updated>
    <id>https://cainrun.github.io/14981091675323.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">继续观看知识</h3>

<p>接着上一篇文章继续, 如果没看过的朋友可以去看看<a href="https://cainrun.github.io/14980521480137.html">玩转iOS开发：NSURLSession讲解(一)</a>, 不然的话会不知头不知尾, 那么接来下继续讲.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">开始网络请求</h3>

<p>之前也说过了, <code>NSURLSession</code>本身是不会进行网络请求的, 那如果我们要用<code>GET</code>或者是<code>POST</code>请求咋搞呢? 直接来看代码吧:</p>

<p><code>GET</code>请求:</p>

<pre><code class="language-objectivec">    // 获取共享的单例Session对象
    NSURLSession *urlSession = [NSURLSession sharedSession];
    
    // 请求的URL地址, 我这里拿百度图片的, 而且这里我并没有兼容HTTP, 要兼容HTTP请求的, 可以到工程项目里配置
    NSURL *url = [NSURL URLWithString:@&quot;https://image.baidu.com/search/index?tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=%E5%9B%BE%E7%89%87&quot;];
    
    // 通过上面的URL地址来创建NSURLSessionDataTask对象, 并且在completionHandler:打印一下所获取到的Data数据
    NSURLSessionDataTask *dataTask = [urlSession dataTaskWithURL:url
                                               completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                   
                                                   NSLog(@&quot;请求的数据为: %@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);
                                               }];
    
    // 开始执行任务
    [dataTask resume];
</code></pre>

<p><code>POST</code>请求:</p>

<pre><code class="language-objectivec">    // 获取共享的单例Session对象
    NSURLSession *urlSession = [NSURLSession sharedSession];
    
    // 创建一个NSURL对象
    NSURL *url = [NSURL URLWithString:@&quot;https://image.baidu.com/search/index?&quot;];
    
    // 创建一个NSMutableURLRequest对象, 并设置HTTPMethod的请求方式和HTTPBody的请求内容.
    NSMutableURLRequest *urlRequest = [NSMutableURLRequest requestWithURL:url];
    
    urlRequest.HTTPMethod = @&quot;POST&quot;;
    urlRequest.HTTPBody   = [@&quot;tn=baiduimage&amp;ps=1&amp;ct=201326592&amp;lm=-1&amp;cl=2&amp;nc=1&amp;ie=utf-8&amp;word=%E5%9B%BE%E7%89%87&quot; dataUsingEncoding:NSUTF8StringEncoding];
    
    // 通过NSURLRequest对象创建一个NSURLSessionDataTask, 并在completionHandler:回调方法里NSLog一下我们所请求到的数据.
    NSURLSessionDataTask *dataTask = [urlSession dataTaskWithRequest:urlRequest
                                                   completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        
                                                       NSLog(@&quot;请求的数据为: %@&quot;, [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]);
                                                   }];
    
    // 开始执行任务
    [dataTask resume];
</code></pre>

<hr/>

<h3 id="toc_2">上传文件</h3>

<p>刚刚我们简单的讲了一下<code>GET</code>和<code>POST</code>这两种常用的请求方式, 现在我们来看看上传文件的方法, 上传也有几种方法, 我们一个个来看看:</p>

<p>根据指定的本地文件地址来上传:</p>

<pre><code class="language-objectivec">    // 创建一个NSURLRequest对象, 注意, 这里要有一个明确的上传地址, 不然你要往哪里上传咧?
    NSURLRequest *urlRequest = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;上传地址&quot;]];
   
    // 本地文件的NSURL
    NSURL *fileURL = [NSURL URLWithString:@&quot;本地文件地址&quot;];
    
    // 通过NSURLRequest对象来创建一个NSURLSessionUploadTask, 配置好File的URL, 还可以在completionHandler: 回调里看看我们是否成功上传.
    NSURLSessionUploadTask *uploadTask = [[NSURLSession sharedSession] uploadTaskWithRequest:urlRequest
                                                                                    fromFile:fileURL
                                                                           completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                                               
                                                                               NSLog(@&quot;上传信息: %@&quot;, [NSJSONSerialization JSONObjectWithData:data
                                                                                                                                  options:kNilOptions
                                                                                                                                    error:nil]);
                                               }];
    
    // 开始执行任务
    [uploadTask resume];
</code></pre>

<p>根据指定的NSData对象来上传:</p>

<pre><code class="language-objectivec">    // 创建一个NSURLRequest对象
    NSURLRequest *urlRequest = [NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;上传地址&quot;]];
    
    // 创建一个NSData对象, 这里我就不详细写了, 因为我没有可以上传的服务器
    NSData *fileData = [NSData data];
    
    // 通过NSURLRequest对象来创建一个NSURLSessionUploadTask, 配置好NSData对象, 还可以在completionHandler: 回调里看看我们是否成功上传.
    NSURLSessionUploadTask *uploadTask = [[NSURLSession sharedSession] uploadTaskWithRequest:urlRequest
                                                                                    fromData:fileData
                                                                           completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                                               
                                                                               NSLog(@&quot;上传信息: %@&quot;, [NSJSONSerialization JSONObjectWithData:data
                                                                                                                                  options:kNilOptions
                                                                                                                                    error:nil]);
                                                                    }];
                                                                    
    // 执行任务
    [uploadTask resume];
</code></pre>

<p>以数据流的方式去上传, 老司机们都说这种方式挺不错的, 因为好处就是大小不限制.</p>

<pre><code class="language-objectivec">    // 初始化一个上传地址
    NSString *urlString = @&quot;上传地址&quot;;
    
    // 如果在上传的的URL地址出现特殊字符的话, 我们这里就要做一下特殊处理
    urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]];
    
    NSURL *url = [NSURL URLWithString:urlString];
    
    // 创建一个NSMutableURLRequest对象
    NSMutableURLRequest *urlRequest = [NSMutableURLRequest requestWithURL:url];
    
    // 网络请求方式设置为POST
    urlRequest.HTTPMethod = @&quot;POST&quot;;
    
    // 创建一个NSData对象, 并且设置好上传文件的地址
    NSData *fileData = [NSData dataWithContentsOfFile:@&quot;文件的路径&quot;];
    
    // 通过指定的URLRequest和FildData来创建NSURLSessionUploadTask, 并且可以在completionHandler:方法里获取是否上传成功
    NSURLSessionUploadTask *uploadTask = [[NSURLSession sharedSession] uploadTaskWithRequest:urlRequest
                                                                                    fromData:fileData
                                                                           completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        
                                                                               if (error) {
                                                                                   
                                                                                   NSLog(@&quot;上传发生了错误: %@&quot;, error);
                                                                                   
                                                                                   return;
                                                                               }
                                                                               
                                                                               NSLog(@&quot;上传你成功：%@&quot;,[[NSString alloc] initWithData:data
                                                                                                                       encoding:NSUTF8StringEncoding]);
                                                                           }];
    
    // 执行任务
    [uploadTask resume];
</code></pre>

<p>使用表单方式来进行上传, 这里我们需要先自定义两个方法:</p>

<pre><code class="language-objectivec">// 传入文件的路径, 文件名, 上传的需要更改的文件名
- (NSData *)getHTTPBodyWithFilePath:(NSString *)filePath
                           fileName:(NSString *)fileName
                           restName:(NSString *)restName {
    
    NSMutableData *data = [NSMutableData data];
    
    NSURLResponse *response = [self getLocalFileResponse:filePath];
    
    // 文件类型：MIMEType  文件的大小：expectedContentLength  文件名字：suggestedFilename
    NSString *fileType = response.MIMEType;
    
    // 如果没有传入上传后文件名称,采用本地文件名!
    if (restName == nil) {
        restName = response.suggestedFilename;
    }
    
    // 表单拼接
    NSMutableString *headerString =[NSMutableString string];
    
    [headerString appendFormat:@&quot;--%@\r\n&quot;,@&quot;boundary&quot;];
    
    // name：表单控件名称  filename：上传文件名
    [headerString appendFormat:@&quot;Content-Disposition: form-data; name=%@; filename=%@\r\n&quot;, fileName, restName];
    [headerString appendFormat:@&quot;Content-Type: %@\r\n\r\n&quot;,fileType];
    
    [data appendData:[headerString dataUsingEncoding:NSUTF8StringEncoding]];
    
    // 文件内容
    NSData *fileData = [NSData dataWithContentsOfFile:filePath];
    
    [data appendData:fileData];
    
    NSMutableString *footerStrM = [NSMutableString stringWithFormat:@&quot;\r\n--%@--\r\n&quot;,@&quot;boundary&quot;];
    
    [data appendData:[footerStrM  dataUsingEncoding:NSUTF8StringEncoding]];
    
    NSLog(@&quot;dataStr=%@&quot;,[[NSString alloc] initWithData:data
                                              encoding:NSUTF8StringEncoding]);
    
    return data;
}

/// 获取响应，主要是文件类型和文件名
- (NSURLResponse *)getLocalFileResponse:(NSString *)urlString {
    
    urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]];
    
    // 本地文件请求
    NSURL *url = [NSURL fileURLWithPath:urlString];
    
    NSURLRequest *request = [NSURLRequest requestWithURL:url];
    
    __block NSURLResponse *localResponse = nil;
    
    // 使用信号量实现NSURLSession同步请求
    dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
    
    [[[NSURLSession sharedSession] dataTaskWithRequest:request
                                     completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                         
                                         localResponse = response;
                                         
                                         dispatch_semaphore_signal(semaphore);
                                         
                                     }] resume];
    
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    
    return  localResponse;
}
</code></pre>

<p>现在我们就来开始拼接表单, 并且上传文件:</p>

<pre><code class="language-objectivec">    // 初始化一个上传地址
    NSString *urlString = @&quot;上传地址&quot;;
    
    // 如果在上传的的URL地址出现特殊字符的话, 我们这里就要做一下特殊处理
    urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLFragmentAllowedCharacterSet]];
    
    NSURL *url = [NSURL URLWithString:urlString];
    
    // 创建一个NSMutableURLRequest对象
    NSMutableURLRequest *urlRequest = [NSMutableURLRequest requestWithURL:url];
    
    // 网络请求方式设置为POST
    urlRequest.HTTPMethod = @&quot;POST&quot;;
    
    NSString *contentType = [NSString stringWithFormat:@&quot;multipart/form-data; boundary=%@&quot;, @&quot;boundary&quot;];
    
    [urlRequest setValue:contentType
      forHTTPHeaderField:@&quot;Content-Type&quot;];
    
    // 创建一个NSData对象, 并且设置好上传文件的地址
    NSData *fileData = [self getHTTPBodyWithFilePath:@&quot;/Users/lifengfeng/Desktop/test.jpg&quot;
                                            fileName:@&quot;file&quot;
                                            restName:@&quot;newName.png&quot;];
    
    urlRequest.HTTPBody = fileData;
    
    [urlRequest setValue:[NSString stringWithFormat:@&quot;%lu&quot;, fileData.length]
      forHTTPHeaderField:@&quot;Content-Length&quot;];
    
    // 通过指定的URLRequest来创建NSURLSessionUploadTask, 并且可以在completionHandler:方法里获取是否上传成功, 由于我们在URLRequest已经添加了Data数据, 所以这里的FileData可以忽略不理
    NSURLSessionUploadTask *uploadTask = [[NSURLSession sharedSession] uploadTaskWithRequest:urlRequest
                                                                                    fromData:nil
                                                                           completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
        
                                                                               if (error) {
                                                                                   
                                                                                   NSLog(@&quot;上传发生了错误: %@&quot;, error);
                                                                                   
                                                                                   return;
                                                                               }
                                                                               
                                                                               NSLog(@&quot;上传你成功：%@&quot;,[[NSString alloc] initWithData:data
                                                                                                                       encoding:NSUTF8StringEncoding]);
                                                                           }];
    
    // 执行任务
    [uploadTask resume];
</code></pre>

<hr/>

<h3 id="toc_3">下载文件</h3>

<p><code>NSURLSessionDownloadTask</code>也是我们常用到的<code>Task</code>, 这里就说说怎么用来下载文件吧:</p>

<pre><code class="language-objectivec">    // 创建一个文件下载的地址
    NSString *urlString = @&quot;文件下载地址&quot;;
    
    // 处理特殊的字符
    urlString = [urlString stringByAddingPercentEncodingWithAllowedCharacters:[NSCharacterSet URLQueryAllowedCharacterSet]];
    
    NSURL *url = [NSURL URLWithString:urlString];
    
    
    NSURLRequest *urlRequest = [NSURLRequest requestWithURL:url];
    
    NSURLSession *urlSession = [NSURLSession sharedSession];
    
    NSURLSessionDownloadTask *downloadTask = [urlSession downloadTaskWithRequest:urlRequest
                                                               completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                                   
                                                                   if(error) {
                                                                       
                                                                       NSLog(@&quot;download error:%@&quot;,error);
                                                                       
                                                                       return;
                                                                   }
                                                                   
                                                                   //location:下载任务完成之后,文件存储的位置，这个路径默认是在tmp文件夹下!
                                                                   //只会临时保存，因此需要将其另存
                                                                   
                                                                   NSLog(@&quot;location:%@&quot;, location.path);
                                                                   
                                                                   //如果你是用模拟器测试，为了方便可以将保存路径设置为Mac桌面
                                                                   // NSString *filePath = [NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES) lastObject];
                                                                   
                                                                   NSString *filePath = @&quot;文件的保存地址&quot;;
                                                                   
                                                                   NSError *fileError;
                                                                   
                                                                   [[NSFileManager defaultManager] copyItemAtPath:location.path
                                                                                                           toPath:filePath
                                                                                                            error:&amp;fileError];
                                                                   
                                                                   if(fileError){
                                                                       
                                                                       NSLog(@&quot;file save error: %@&quot;,fileError);
                                                                   } else {
                                                                       
                                                                       NSLog(@&quot;file save success&quot;);
                                                                   }
                                                               }];

    // 开始下载
    [downloadTask resume];
</code></pre>

<p><code>NSURLSessionStreamTask</code>这里就不说了, 因为我也有没有怎么去用</p>

<hr/>

<h3 id="toc_4">APP的传输安全(ATS)</h3>

<p>从<code>iOS 9</code>和<code>Mac OS 10.11</code>开始, 苹果爸爸就想把所有网络请求都全部改为<code>HTTPS</code>(<a href="https://tools.ietf.org/html/rfc2818">RFC 2818</a>), 但由于一下子转变肯定是不太可能的, 所以就有一个名为<code>ATS</code>的安全特性.</p>

<p>在新建项目里面, 我们会发没法正常的发送<code>HTTP</code>请求, 这就是<code>ATS</code>搞的鬼, 我们需要在工程里面设置一下, 详细怎么设置去找度娘吧.</p>

<p>如果你想了解更多的资料, 那就去苹果爸爸的官方文档看看<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247">Information Property List Key Reference</a>中的<a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33">NSAppTransportSecurity</a>.</p>

<hr/>

<h3 id="toc_5">总结</h3>

<p>顺便说多一句, 这里的<code>NSURLSessionStreamTask</code>就不讲解了, 用到的机会也不多, 以后有机会再另外开一章节来说说吧.</p>

<p>同样这次依然是没有项目, 大家自己去拷贝代码吧.</p>

<hr/>

<h3 id="toc_6">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：NSURLSession讲解(一)]]></title>
    <link href="https://cainrun.github.io/14980521480137.html"/>
    <updated>2017-06-21T21:35:48+08:00</updated>
    <id>https://cainrun.github.io/14980521480137.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">NSURLSession</h3>

<p>在2013年的时候, 苹果推出了<code>iOS 7</code>, 这个版本的<code>iOS</code>被称为革命性的<code>iOS</code>, 而我们以前所用到的<code>NSURLConnection</code>这个网络库也被苹果爸爸给重构, 并且重新命名为<code>NSURLSession</code>.</p>

<p>现在在<code>GitHub</code>里用的最多的两个库<a href="https://github.com/AFNetworking/AFNetworking">AFNetworking</a>, <a href="https://github.com/rs/SDWebImage">SDWebImage</a>都是用了<code>NSURLSession</code>.</p>

<p>这里就不废话了, 直接来知识点吧.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">网络通信</h3>

<p>关于<code>Session</code>的意思, 我这里找到一段比较古方的解释:</p>

<blockquote>
<p><code>Session</code>翻译为中文意思是会话，我们知道，在七层网络协议中有<code>物理层-&gt;数据链路层-&gt;网络层-&gt;传输层-&gt;会话层-&gt;表示层-&gt;应用层</code>，那我们可以将<code>NSURLSession</code>类理解为会话层，用于管理网络接口的创建、维护、删除等等工作，我们要做的工作也只是会话层之后的层即可，底层的工作<code>NSURLSession</code>已经帮我们封装好了.</p>
</blockquote>

<p>看到这我们就很激动, 因为底层的东西不需要我们去管理, 这就轻松多了.</p>

<hr/>

<h3 id="toc_2">NSURLSession的分支</h3>

<p>我们都知道苹果爸爸用<code>NSURLSession</code>代替了<code>NSURLConnection</code>, 那么<code>NSURLSession</code>里面到底有什么呢?</p>

<p><code>NSURLSession</code>父类:</p>

<ul>
<li>NSURLSession</li>
<li>NSURLSessionConfiguration</li>
</ul>

<p><code>NSURLSessionTask</code>子类:</p>

<ul>
<li>NSURLSessionDataTask</li>
<li>NSURLSessionUploadTask</li>
<li>NSURLSessionDownloadTask</li>
<li>NSURLSessionStreamTask (iOS 9后才支持)</li>
</ul>

<p>他们的主要关系: </p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%80)/Images/1.png" alt="1"/></p>

<p><code>NSURLSessionTask</code>子类的继承关系:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%80)/Images/2.png" alt="2"/></p>

<p><code>NSURLSessionDataTask</code>: 主要使用在请求一些比较简单的数据, 比如我们常用的<code>JSON</code>数据.</p>

<p><code>NSURLSessionDownloadTask</code>: 这个主要使用在进行一些文件的下载, 它可以针对一些大文件的网络请求做更多的处理, 比如获取下载进度, 文件的断点续传等等牛逼事情.</p>

<p><code>NSURLSessionUploadTask</code>: 这个和上面那个<code>task</code>对应, 主要是给服务器发送文件数据所使用的.</p>

<p><code>NSURLSessionStreamTask</code>: 提供<code>TCP/IP</code>的一个链接入口, 方便进行传输.</p>

<hr/>

<h3 id="toc_3">使用NSURLSession</h3>

<p>不要以为看完了上面就可以直接拿来和服务器交互了啦, 因为<code>NSURLSession</code>本身是不会进行请求, 需要通过创建对应的<code>task</code>, 然后配置完之后, 再去调用<code>resume()</code>方法才能够进行tongxin.</p>

<p>这里有一个好消息就是同意个<code>NSURLSession</code>是可以创建多个<code>task</code>, 并且这些<code>task</code>的<code>cache</code>和<code>cookie</code>都是共享的.</p>

<p>使用<code>NSURLSession</code>的步骤:</p>

<ol>
<li>创建<code>NSURLSession</code>对象</li>
<li>使用<code>NSURLSession</code>创建对应的<code>task</code></li>
<li>最后一步就是调用<code>resume()</code>方法, 开始请求.</li>
</ol>

<p>创建<code>NSURLSession</code>对象有三种方法, 这里就不创建工程里, 直接贴代码吧:</p>

<p>第一种:</p>

<pre><code class="language-objectivec">// 获取一个共享的单例会话对象
    NSURLSession *urlSession = [NSURLSession sharedSession];
</code></pre>

<p>第二种:</p>

<pre><code class="language-objectivec">// 用NSURLSessionConfiguration获取一个特定的NSURLSession
NSURLSession *urlSession = [NSURLSession sessionWithConfiguration:&lt;#(nonnull NSURLSessionConfiguration *)#&gt;];
</code></pre>

<p>第三种:</p>

<pre><code class="language-objectivec">// 用NSURLSessionConfiguration获取一个特定的NSURLSession, 并且设置好代理对象, 和代理的队列
    NSURLSession *urlSession = [NSURLSession sessionWithConfiguration:&lt;#(nonnull NSURLSessionConfiguration *)#&gt;
                                                             delegate:&lt;#(nullable id&lt;NSURLSessionDelegate&gt;)#&gt;
                                                        delegateQueue:&lt;#(nullable NSOperationQueue *)#&gt;]

</code></pre>

<hr/>

<h3 id="toc_4">配置NSURLSession</h3>

<p>刚刚我们也提到, <code>NSURLSession</code>是没法直接进行请求的, 所以我们需要去配置一下, 这里也有三种配置的方法.</p>

<p>第一种:</p>

<pre><code class="language-objectivec">// NSURLSessionConfiguration的默认配置, 这种配置会把缓存数据存储到磁盘上
@property (class, readonly, strong) NSURLSessionConfiguration *defaultSessionConfiguration;

NSURLSession *urlSession = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];
</code></pre>

<p>第二种:</p>

<pre><code class="language-objectivec">// NSURLSessionConfiguration的第二种配置, 这种配置不会把数据持久化, 也就是说不会存储到磁盘上
@property (class, readonly, strong) NSURLSessionConfiguration *ephemeralSessionConfiguration;

NSURLSession *urlSession = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration ephemeralSessionConfiguration]];
</code></pre>

<p>第三种:</p>

<pre><code class="language-objectivec">// 这个配置可以允许程序在后台进行上传和下载的操作, 给定一个Identifier可以在系统关闭应用之后重启, 根据给定的`Identifier`终止正在下载或者上传操作, 但如果是用户手动关闭了应用, 系统就会取消所有后台传输的会话, 官方建议, 如果要时候后台操作的话, 把discretionary属性设置成为YES, 可以获得更好地性能.
+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier NS_AVAILABLE(10_10, 8_0);

NSURLSession *urlSession = [NSURLSession sessionWithConfiguration:[NSURLSessionConfiguration backgroundSessionConfigurationWithIdentifier:@&quot;backgroundSessionConfiguration&quot;]];
</code></pre>

<hr/>

<h3 id="toc_5">使用NSURLSession创建Task</h3>

<p>刚刚我们也说了, <code>NSURLSession</code>是有三个子类的<code>Task</code>, 所以这里我们也要分开来说说.</p>

<p><code>NSURLSessionDataTask</code>:</p>

<pre><code class="language-objectivec">// 通过指定的NSURL来创建一个NSURLSessionDataTask
NSURLSessionDataTask *dataTask = [urlSession dataTaskWithURL:[NSURL URLWithString:@&quot;&quot;]];

// 通过指定的NSURL对象来创建, 并同时执行完对应的任务后通过completionHandler:返回NSURLSessionDataTask
NSURLSessionDataTask *dataTask = [urlSession dataTaskWithURL:[NSURL URLWithString:@&quot;&quot;]
                                           completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                           }];

// 通过指定的NSURLRequest对象来创建一个NSURLSessionDataTask
NSURLSessionDataTask *dataTask = [urlSession dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]];

// 通过指定的NSURLRequest对象来创建, 并同时执行完对应的任务后通过completionHandler:返回NSURLSessionDataTask
NSURLSessionDataTask *dataTask = [urlSession dataTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]
                                               completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                   }];
</code></pre>

<h2 id="toc_6"></h2>

<p><code>NSURLSessionUploadTask</code>:</p>

<pre><code class="language-objectivec">// 通过指定的NSURLRequest对象来创建一个NSURLSessionUploadTask
NSURLSessionUploadTask *uploadTask = [urlSession uploadTaskWithStreamedRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]];

// 通过指定的NSURLRequest对象来创建一个NSURLSessionUploadTask, 并且指定上传时所需的数据源
NSURLSessionUploadTask *uploadTask = [urlSession uploadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]
                                                              fromData:[NSData data]];

// 通过指定的NSURLRequest对象来创建一个NSURLSessionUploadTask, 并且指定上传时所需的文件源
NSURLSessionUploadTask *uploadTask = [urlSession uploadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]
                                                              fromFile:[NSURL URLWithString:@&quot;&quot;]];

// 通过指定的NSURLRequest对象来创建, 指定上传时所需的文件源, 并且同时执行完对应的任务后通过completionHandler:来返回NSURLSessionUploadTask
NSURLSessionUploadTask *uploadTask = [urlSession uploadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]
                                                              fromFile:[NSURL URLWithString:@&quot;&quot;]
                                                     completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                     }];

// 通过指定的NSURLRequest对象来创建, 指定上传时所需的数据源, 并且同时执行完对应的任务后通过completionHandler:来返回NSURLSessionUploadTask
NSURLSessionUploadTask *uploadTask = [urlSession uploadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]
                                                              fromData:[NSData data]
                                                     completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                     }];
</code></pre>

<h2 id="toc_7"></h2>

<p><code>NSURLSessionDownloadTask</code>:</p>

<pre><code class="language-objectivec">// 通过指定的NSURL对象来创建一个NSURLSessionDownloadTask
NSURLSessionDownloadTask *downloadTask = [urlSession downloadTaskWithURL:[NSURL URLWithString:@&quot;&quot;]];

// 通过指定的NSURL对象来创建一个NSURLSessionDownloadTask, 并同时执行完对应的任务后通过completionHandler:返回NSURLSessionDownloadTask
NSURLSessionDownloadTask *downloadTask = [urlSession downloadTaskWithURL:[NSURL URLWithString:@&quot;&quot;]
                                                       completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {    
                                                       }];

// 通过指定的NSURLRequest对象来创建一个NSURLSessionDownloadTask
NSURLSessionDownloadTask *downloadTask = [urlSession downloadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]];

// 通过指定的NSURLRequest对象来创建一个NSURLSessionDownloadTask, 并同时执行完对应的任务后通过completionHandler:返回NSURLSessionDownloadTask
NSURLSessionDownloadTask *downloadTask = [urlSession downloadTaskWithRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;&quot;]]
                                                           completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {                                                             
                                                           }];

// 通过指定的NSData对象来创建一个NSURLSessionDownloadTask, 这个NSData对象是之前下载失败或者是停止下载了的数据, 这就是我们常说的断点续传
NSURLSessionDownloadTask *downloadTask = [urlSession downloadTaskWithResumeData:[NSData data]];

// 通过指定的NSData对象来创建一个NSURLSessionDownloadTask, , 并同时执行完对应的任务后通过completionHandler:返回NSURLSessionDownloadTask, 同时也是支持断点续传
NSURLSessionDownloadTask *downloadTask = [urlSession downloadTaskWithResumeData:[NSData data]
                                                              completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
                                                              }];
</code></pre>

<p><code>NSURLSessionStreamTask</code>:</p>

<pre><code class="language-objectivec">// 通过一个指定的NSNetService对象来创建NSURLSessionStreamTask
NSURLSessionStreamTask *streamTask = [urlSession streamTaskWithNetService:[[NSNetService alloc] init]];

// 通过一个指定的IP地址, 端口号来创建一个NSURLSessionStreamTask
NSURLSessionStreamTask *streamTask = [urlSession streamTaskWithHostName:@&quot;192.168.1.1&quot;
                                                                   port:8888];
</code></pre>

<hr/>

<h3 id="toc_8">NSURLSessionDelegate</h3>

<p>刚刚讲完了三种<code>Task</code>, 这里补充一下, 就是说我们无论会用哪一种<code>Task</code>, 我们都可以指定对应的代理, 这里有一张<code>NSURLSession</code>代理关系图:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-NetWork/master/NSURLSession%E8%AE%B2%E8%A7%A3(%E4%B8%80)/Images/3.png" alt="3"/></p>

<table>
<thead>
<tr>
<th style="text-align: center">代理类</th>
<th style="text-align: center">作用</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">NSURLSessionDelegate</td>
<td style="text-align: center">作为其他代理的最基类, 定义了最基础的网络请求代理方法</td>
</tr>
<tr>
<td style="text-align: center">NSURLSessionTaskDelegate</td>
<td style="text-align: center">定义了网络请求任务的代理方法</td>
</tr>
<tr>
<td style="text-align: center">NSURLSessionDownloadDelegate</td>
<td style="text-align: center">定义了下载任务的代理方法, 比如获取下载进度</td>
</tr>
<tr>
<td style="text-align: center">NSURLSessionDataDelegate</td>
<td style="text-align: center">定义了上传任务或普通数据任务的代理方法</td>
</tr>
<tr>
<td style="text-align: center">NSURLSessionStreamDelegate</td>
<td style="text-align: center">这个代理方法是继承于<code>NSURLSessionTaskDelegate</code>, 提供一个TCP/IP的链接代理方法.</td>
</tr>
</tbody>
</table>

<p>详细大家都会用代理方法, 这里就不介绍了.</p>

<hr/>

<h3 id="toc_9">执行任务</h3>

<p>刚刚说完了那么多东西, 最后就差执行任务了:</p>

<pre><code class="language-objectivec">[task resume];
</code></pre>

<p>酱紫就完事啦, 如果还想了解更多的话, 可以去看看苹果爸爸的<a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">官方文档</a>.</p>

<hr/>

<h3 id="toc_10">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/10.Siri%20Intents%20UI">https://github.com/CainRun/iOS-10-Characteristic/tree/master/10.Siri%20Intents%20UI</a></p>

<hr/>

<h3 id="toc_11">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Siri Kit Intents Extension UI》]]></title>
    <link href="https://cainrun.github.io/14978567639492.html"/>
    <updated>2017-06-19T15:19:23+08:00</updated>
    <id>https://cainrun.github.io/14978567639492.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Siri Kit Intents Extension UI</h3>

<p>之前我们讲了<code>Siri Kit Intents Extension</code>, 但并没有去讲到<code>UI</code>的方面, 这次我们把最后一丢丢给讲完把.</p>

<p>这里所用的工程还是之前的, 如果不懂得朋友, 可以去看看的那篇<a href="https://cainrun.github.io/14977885999456.html">文章</a>, 里面也有工程的下载地址.</p>

<p>这里的工程是<code>Objective-C</code>版本的, 如果要看<code>Swift</code>版本, 可以到<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/10%20-%20Siri%20Intents%20UI">这里</a>去查看.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">定制UI</h3>

<p>这里就不扯那么多废话了, 我们可以在<code>SiriKitIntentsExtensionUI</code>文件夹里找到<code>MainInterface.storyboard</code>文件, 在这里布置我们想要的<code>UI</code>:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/10.Siri%20Intents%20UI/Images/1.png" alt="1"/></p>

<p>然后和<code>Controller</code>关联起来:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/10.Siri%20Intents%20UI/Images/2.png" alt="2"/></p>

<hr/>

<h3 id="toc_2">具体实现</h3>

<p>回到我们的<code>IntentViewController.m</code>文件, 在<code>- (void)configureWithInteraction:(INInteraction *)interaction<br/>
                         context:(INUIHostedViewContext)context<br/>
                      completion:(void (^)(CGSize))completion;</code>方法里开始写我们的代码: </p>

<pre><code class="language-objectivec">    // 截取发送消息的Intent
    INSendMessageIntent *intent = (INSendMessageIntent *)(interaction.intent);
    
    // 获取用户信息
    NSString *name = [[intent.recipients lastObject] displayName];
    NSString *content = intent.content;
    NSString *icon = [UserList checkUserWithName:name].userIcon;

    // 展示自己与接收人的头像
    self.userImageIcon.image = [UIImage imageNamed:@&quot;icon3&quot;];
    self.toUserImageIcon.image = [UIImage imageNamed:icon];
    
    // 改变标题
    self.sectionTitleLabel.text = [NSString stringWithFormat:@&quot;与\&quot;%@\&quot;对话&quot;, name];
    
    // 发送的消息内容
    self.messageContentLabel.text = content;
    
    // 隐藏或显示控件
    self.sectionTitleLabel.hidden      = !name.length;
    self.messageContentLabel.hidden    = !content.length;
    self.messageBackgroundImage.hidden = !content.length;
    self.toUserImageIcon.hidden        = !self.toUserImageIcon.image;
    
    if (completion) {
            completion(CGSizeMake([self desiredSize].width, 150));
    }
</code></pre>

<p>效果: </p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/10.Siri%20Intents%20UI/Images/3.png" alt="3"/></p>

<p>虽然<code>UI</code>已经展示了, 但特么好像有些多啊, 这里我们需要添加多一个协议, 并且是写一个协议的方法:</p>

<pre><code class="language-objectivec">@interface IntentViewController () &lt;INUIHostedViewSiriProviding&gt;

@end

- (BOOL)displaysMessage {
    return YES;
}
</code></pre>

<p>效果:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/10.Siri%20Intents%20UI/Images/4.png" alt="4"/></p>

<p>这里我们需要注意一点, 打开工程的配置, 看到<code>SiriKitIntentsExtension</code>和<code>SiriKitIntentsExtensionUI</code>的<code>Copy Bundle Resources</code>有没有链接<code>Assets.xcassets</code>, 如果没有链接上的话, 那就会造成本地图片没法展示:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/10.Siri%20Intents%20UI/Images/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_3">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/10.Siri%20Intents%20UI">https://github.com/CainRun/iOS-10-Characteristic/tree/master/10.Siri%20Intents%20UI</a></p>

<hr/>

<h3 id="toc_4">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Siri Kit》]]></title>
    <link href="https://cainrun.github.io/14977885999456.html"/>
    <updated>2017-06-18T20:23:19+08:00</updated>
    <id>https://cainrun.github.io/14977885999456.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Siri</h3>

<p>众所周知<code>Siri</code>是苹果爸爸内置在<code>iOS</code>系统的一个语音助手, 自从在2011年的<code>iPhone 4s</code>问世之后, <code>Siri</code>就一直受关注.</p>

<p>但好景不长, 随着<code>Siri</code>的功能和权限太弱了, 慢慢就被人遗忘, 起码我身边用<code>iPhone</code>的小伙伴都会把<code>Siri</code>给关掉, 按照他们的说法就是可以省电...我也是醉了.</p>

<p>几年过去后, <code>Siri</code>终于迎接来了春天, 随着<code>iOS 10</code>的推出, 终于给开发者们开放了<code>Siri Kit</code>, 也开放了<code>Siri Intents Extension</code>, 国内用的最快的<code>App</code>依然还是<code>BAT</code>巨头的产品, 比如<code>QQ</code>.</p>

<p>这里的工程是<code>Objective-C</code>版本, 想看<code>Swift</code>版本的, 可以到<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/09%20-%20Siri%20Intents">这里</a>去查看.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">Siri的服务类型</h3>

<p>这里我简单的举一下<code>Siri</code>目前支持的一些种类, 更加详细的文档请看<a href="https://developer.apple.com/documentation/sirikit?language=objc">官方文档</a>.</p>

<table>
<thead>
<tr>
<th style="text-align: center">Siri服务类型</th>
<th style="text-align: left">Intent种类</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">VoIP语音 - VoIP calling</td>
<td style="text-align: left">INStartVideoCallIntent、INStartAudioCallIntent</td>
</tr>
<tr>
<td style="text-align: center">消息 - Messaging</td>
<td style="text-align: left">INSendMessageIntent</td>
</tr>
<tr>
<td style="text-align: center">支付 - Payments</td>
<td style="text-align: left">INSendPaymentIntent、INRequestPaymentIntent</td>
</tr>
<tr>
<td style="text-align: center">图片 - Photos</td>
<td style="text-align: left">INSearchForPhotosIntent</td>
</tr>
<tr>
<td style="text-align: center">健身 - Workouts</td>
<td style="text-align: left">INEndWorkoutIntent、INPauseWorkoutIntent 、INStartWorkoutIntent 、 INResumeWorkoutIntent 、INCancelWorkoutIntent</td>
</tr>
<tr>
<td style="text-align: center">骑行预约 - Ride booking</td>
<td style="text-align: left">INRequestRideIntent、INGetRideStatusIntent、 INListRideOptionsIntent、 INGetRideStatusIntent</td>
</tr>
<tr>
<td style="text-align: center">汽车状态 - Car commands</td>
<td style="text-align: left">INSetCarLockStatusIntent、INGetCarPowerLevelStatusIntent、INActivateCarSignalIntent</td>
</tr>
<tr>
<td style="text-align: center">车载系统 - CarPlay</td>
<td style="text-align: left">INSetAudioSourceInCarIntent、INSetClimateSettingsInCarIntent</td>
</tr>
<tr>
<td style="text-align: center">预定餐厅 - Restaurant reservations</td>
<td style="text-align: left">INBookRestaurantReservationIntent</td>
</tr>
</tbody>
</table>

<hr/>

<h3 id="toc_2">New Project</h3>

<p>创建新工程的项目这里我就忽略了, 直接来看添加<code>Siri Intents Extension</code>:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/2.png" alt="2"/></p>

<p>这里注意一下, 我们要把<code>Include UI Extension</code>也要勾上, 但这个东西会专门开一篇文章去讲解.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/3.png" alt="3"/></p>

<p>创建好之后, 我们可以看到<code>Siri Intents Extension</code>和之前我们遇到的<code>Extension</code>不太一样:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/4.png" alt="4"/></p>

<p>还有就是, 我们打开<code>Siri Intents Extension</code>的<code>Info.plist</code>文件看到<code>IntentsSupported</code>和<code>IntentsRestrictedWhileLocked</code>, 那有什么用呢?</p>

<ul>
<li><p>IntentsSupported: 我们项目需要支持的<code>Siri Intents</code>就放到这里, 比如我们在工程里看到的<code>INSendMessageIntent</code>, <code>INSearchForMessagesIntent</code>, <code>INSetMessageAttributeIntent</code>.</p></li>
<li><p>IntentsRestrictedWhileLocked: 在锁屏状态下需要锁定的<code>Siri Intents</code>就放到这里, 比如我们在工程里看到的<code>INSendMessageIntent</code>.</p></li>
</ul>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_3">SiriKit的流程</h3>

<p>关于<code>SiriKit</code>的流程这里我就拷贝一下官方的说法:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/6.png" alt="6"/></p>

<p><code>Siri</code>和<code>Maps</code>通过<code>Intents extension</code>的扩展方式和我们的应用进行交互，其中，类型为<code>INExtension</code>的对象扮演着<code>Intents extension</code>扩展中直接协同<code>Siri</code>对象共同响应用户请求的关键角色。当我们实现了<code>Intents extension</code>扩展并产生了一个<code>Siri</code>请求事件时，一个典型的<code>Intent</code>事件的处理过程中总共有这三个步骤<code>Resolve</code>、<code>Confirm</code>和<code>Handle</code>：</p>

<ul>
<li><code>Resolve</code>阶段。在<code>Siri</code>获取到用户的语音输入之后，生成一个<code>INIntent</code>对象，将语音中的关键信息提取出来并且填充对应的属性。这个对象在稍后会传递给我们设置好的<code>INExtension</code>子类对象进行处理，根据子类遵循的不同服务<code>protocol</code>来选择不同的解决方案。</li>
<li><code>Confirm</code>阶段。在上一个阶段通过<code>handler(for intent:)</code>返回了处理<code>intent</code>的对象，此阶段会依次调用<code>confirm</code>打头的实例方法来判断<code>Siri</code>填充的信息是否完成。匹配的判断结果包括<code>Exactly one match</code>、<code>Two or more matches</code>以及<code>No match</code>三种情况。这个过程中可以让<code>Siri</code>向用户征求更具体的参数信息。</li>
<li>在<code>confirm</code>方法执行完成之后，<code>Siri</code>进行最后的处理阶段，生成答复对象，并且向此<code>intent</code>对象确认处理结果然后执显示结果给用户看。</li>
</ul>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/7.png" alt="7"/></p>

<hr/>

<h3 id="toc_4">交互名单</h3>

<p>这里我们首先要创建一个名单, 用来模拟一下发送消息的场景:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/8.png" alt="8"/></p>

<p>这里还有一个<code>NSString</code>的类别, 用来转换拼音的:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/9.png" alt="9"/></p>

<hr/>

<h3 id="toc_5">精确匹配和模糊匹配</h3>

<p>回到我们的<code>IntentHandler.m</code>文件, 这里我们要开始写代码了, 我们需要些一个精确的用户名称匹配和一个模糊的用户名称匹配:</p>

<pre><code class="language-objectivec">    // 遍历待匹配选项
    for (INPerson *recipient in recipients) {
        
        // Implement your contact matching logic here to create an array of matching contacts
        NSMutableArray&lt;INPerson *&gt; *matchingContacts = [NSMutableArray array];
        
        // 待匹配的名称
        NSString *recipientName = recipient.displayName;
        NSString *recipientNamePinYin = [recipientName cl_PinYin];
        
        // 精确的匹配到列表里的用户
        UserList *user = [UserList checkUserWithName:recipientName];
        
        if (user) {
            
            NSLog(@&quot;匹配到精确用户:%@&quot;, user);
    
            // 创建一个匹配成功的用户
            INPersonHandle *personHandle = [[INPersonHandle alloc] initWithValue:user.userAddress
                                                                            type:INPersonHandleTypeEmailAddress];
            INImage *iconImage = [INImage imageNamed:user.userIcon];
            
            INPerson *person = [[INPerson alloc] initWithPersonHandle:personHandle
                                                       nameComponents:nil
                                                          displayName:recipientName
                                                                image:iconImage
                                                    contactIdentifier:nil
                                                     customIdentifier:nil
                                                              aliases:nil
                                                       suggestionType:INPersonSuggestionTypeSocialProfile];
            
            // 把匹配成功的用户记录下来
            [matchingContacts addObject:person];
        }
        
        // 如果没有精确匹配到用户, 则用模糊匹配
        if (matchingContacts.count == 0) {
            
            NSLog(@&quot;没有匹配到精确用户:%@&quot;, user);

            for (UserList *user in [UserList userList]) {
                
                // 匹配用户的名称
                NSString *userName = user.userName;
                NSString *userNamePinYin = [userName cl_PinYin];
                
                if ([recipientName containsString:userName] || [recipientNamePinYin containsString:userNamePinYin]) {
                    
                    //  创建一个匹配成功的用户
                    INPersonHandle *personHandle = [[INPersonHandle alloc] initWithValue:user.userAddress
                                                                                    type:INPersonHandleTypeEmailAddress];
                    
                    INImage *iconImage = [INImage imageNamed:user.userIcon];
                    
                    INPerson *person = [[INPerson alloc] initWithPersonHandle:personHandle
                                                               nameComponents:nil
                                                                  displayName:userName
                                                                        image:iconImage
                                                            contactIdentifier:nil
                                                             customIdentifier:nil
                                                                      aliases:nil
                                                               suggestionType:INPersonSuggestionTypeSocialProfile];
                    
                    //  记录匹配的用户
                    [matchingContacts addObject:person];
                }
            }
        }
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/10.png" alt="10"/></p>

<hr/>

<h3 id="toc_6">注意</h3>

<p>注意一下, 虽然我们代码写好了, 但我们还是需要看看工程里有没有添加<code>-ObjC</code></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/11.png" alt="11"/></p>

<p>还有就是<code>Siri Intents Extension</code>和<code>Siri Intents Extension UI</code>里有没有链接好<code>NSString+PinYin.m</code>和<code>UserList.m</code>:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/12.png" alt="12"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/13.png" alt="13"/></p>

<p>不然就会发生<code>&quot;_OBJC_CLASS_$_UserList&quot;, referenced from:</code>错误了.</p>

<p>在运行之前一定要到<code>设置 -&gt; Siri -&gt; 开启Siri</code>才可以使用, 这里我是用模拟器, 所以没法试着发邮件出去:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/14.png" alt="14"/></p>

<p>但是发消息还是<code>ok</code>得, 效果:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/15.png" alt="15"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/16.png" alt="16"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/9.Siri%20Intents/Images/17.png" alt="17"/></p>

<hr/>

<h3 id="toc_7">总结</h3>

<p>最后我们来看看额外的一篇文章, 就是企鹅公司是肿么给QQ适配<code>SiriKit</code>的一些思路<a href="http://www.cnblogs.com/oc-bowen/p/5949020.html">QQ适配 SiriKit</a>.</p>

<hr/>

<h3 id="toc_8">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/9.Siri%20Intents">https://github.com/CainRun/iOS-10-Characteristic/tree/master/9.Siri%20Intents</a></p>

<hr/>

<h3 id="toc_9">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Speech》]]></title>
    <link href="https://cainrun.github.io/14976719349322.html"/>
    <updated>2017-06-17T11:58:54+08:00</updated>
    <id>https://cainrun.github.io/14976719349322.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">语音识别</h3>

<p>之前在看锤子的发布会的时候, 看到了一个很屌的事情就是讯飞的语音识别杠杠的, 可以根据人说的语句来输入文字, 而且错别率很低, 业界都说<code>666</code>.</p>

<p>好在苹果爸爸也不认输, 也有个原生的语音识别框架<code>Speech</code>, 废话少说了, 我们直接来看看<code>Speech</code>框架.</p>

<p>我这里是<code>Objective-C</code>版本, 如果想看<code>Swift</code>版本的话, 可以到<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/08%20-%20Speech">这里</a>去看.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">New Project</h3>

<p>怎么创建新项目这里就不多说了, 直接上项目架构图:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/8.Speech/Images/1.png" alt="1"/></p>

<hr/>

<h3 id="toc_2">配置项目</h3>

<p>由于现在苹果越来越注重用户的隐私, 就连最简单的请求使用麦克风, 摄像头都需要经过用户的允许, 这里我们就需要配置一下这些请求:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/8.Speech/Images/2.png" alt="2"/></p>

<p>请求麦克风</p>

<ul>
<li>Privacy - Microphone Usage Description</li>
</ul>

<p>请求语音识别系统</p>

<ul>
<li>Privacy - Speech Recognition Usage Description</li>
</ul>

<p>里面的提示文字就根据大家的喜爱来自行编写吧, 还有更多的请求这里就不写了, 有需要的朋友可以自行去查资料把.</p>

<hr/>

<h3 id="toc_3">SpeechLogic</h3>

<p>我这里新建了一个类, 专门用来管理<code>Speech</code>, 由于我用不上<code>Speech</code>这个框架, 这里我就随便封装了, 用到上的朋友可以自行另外封装哈.</p>

<p>方法, 属性都已经在文件里备注好了, 自行查看就好了.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/8.Speech/Images/3.png" alt="3"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/8.Speech/Images/4.png" alt="4"/></p>

<p><code>UI</code>界面也很简单, 这里就更加不用去解释了</p>

<hr/>

<h3 id="toc_4">开始语音识别</h3>

<p>由于我没能在模拟器上面实现, 这里我就用了另外的方法, 有些蛋疼:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/8.Speech/Images/5.gif" alt="5"/></p>

<p>苹果爸爸的语音识别, 不只是能够识别人的语音, 还可以读取音频文件:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/8.Speech/Images/6.gif" alt="6"/></p>

<hr/>

<h3 id="toc_5">总结</h3>

<p>我这里讲的东西比较少, 有兴趣的朋友可以去看看<a href="https://my.oschina.net/u/2340880/blog/751442">Speech框架API解释</a>, 或者是苹果爸爸的<a href="https://developer.apple.com/reference/speech">官方文档</a>, <a href="https://developer.apple.com/videos/play/wwdc2016/509/">WWDC 2016 Speech十分钟视频</a>以及我在Github上看到的<a href="https://github.com/suifengqjn/IOS10Speech">iOS 10 Speech项目</a>, 这些都是挺不错的资料, 方便大家去学习.</p>

<hr/>

<h3 id="toc_6">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/8.Speech">https://github.com/CainRun/iOS-10-Characteristic/tree/master/8.Speech</a></p>

<hr/>

<h3 id="toc_7">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Measurement》]]></title>
    <link href="https://cainrun.github.io/14975320210226.html"/>
    <updated>2017-06-15T21:07:01+08:00</updated>
    <id>https://cainrun.github.io/14975320210226.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">单位换算</h3>

<p>单位换算其实在iOS开发中, 一直是一个问题, 虽然在大部分<code>App</code>里不一定会遇到换算, 但在一些专业级的App里, 比如导航, 测量, 计算, 汽车辅助类等<code>App</code>就蛋疼了, 因为官方并没有提供这类的<code>API</code>, 基本上都是自己写, 或者是集成第三方库.</p>

<p>苹果爸爸为了再一次完善<code>API</code>, 在<code>Foundation</code>库里加了这么一个叫做<code>Measurement</code>的库, 就是为了解决单位换算的问题.</p>

<p>这里的项目是<code>Objective-C</code>版本的, 如果喜欢<code>Swift</code>版本的话, 可以到<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/07%20-%20Measurement">这里</a>去查看.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">创建项目</h3>

<p>由于这里要讲的东西很简单, 我就不过多的复杂化直接看代码好了:</p>

<pre><code class="language-objectivec">    // 初始化一个秒数的基数
    NSMeasurement *seconds = [[NSMeasurement alloc] initWithDoubleValue:666
                                                                       unit:NSUnitDuration.seconds];
    
    // 转换为分钟
    NSMeasurement *minutes = [seconds measurementByConvertingToUnit:NSUnitDuration.minutes];
    
    // 转换为小时
    NSMeasurement *hours   = [seconds measurementByConvertingToUnit:NSUnitDuration.hours];

    NSString *secondsString = [NSString stringWithFormat:@&quot;%.2f 秒&quot;, seconds.doubleValue];
    NSString *minutesString = [NSString stringWithFormat:@&quot;%.2f 分钟&quot;, minutes.doubleValue];
    NSString *hoursString   = [NSString stringWithFormat:@&quot;%.2f 小时&quot;, hours.doubleValue];
</code></pre>

<p><code>UI</code>的代码我就不贴上来了, 大伙可以去项目里自己去看看, 整体效果就酱紫:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/7.Measurement/Images/1.png" alt="1"/></p>

<hr/>

<h3 id="toc_2">支持换算单位的类型</h3>

<table>
<thead>
<tr>
<th style="text-align: center">单位类型</th>
<th style="text-align: center">单位</th>
</tr>
</thead>

<tbody>
<tr>
<td style="text-align: center">NSDimension</td>
<td style="text-align: center">维度</td>
</tr>
<tr>
<td style="text-align: center">NSUnitAcceleration</td>
<td style="text-align: center">每秒/平方米</td>
</tr>
<tr>
<td style="text-align: center">NSUnitAngle</td>
<td style="text-align: center">角度</td>
</tr>
<tr>
<td style="text-align: center">NSUnitArea</td>
<td style="text-align: center">平方米</td>
</tr>
<tr>
<td style="text-align: center">NSUnitConcentrationMass</td>
<td style="text-align: center">每克/升</td>
</tr>
<tr>
<td style="text-align: center">NSUnitDispersion</td>
<td style="text-align: center">百万分之</td>
</tr>
<tr>
<td style="text-align: center">NSUnitDuration</td>
<td style="text-align: center">秒</td>
</tr>
<tr>
<td style="text-align: center">NSUnitElectricCharge</td>
<td style="text-align: center">库仑</td>
</tr>
<tr>
<td style="text-align: center">NSUnitElectricCurrent</td>
<td style="text-align: center">安培</td>
</tr>
<tr>
<td style="text-align: center">NSUnitElectricPotentialDifference</td>
<td style="text-align: center">伏</td>
</tr>
<tr>
<td style="text-align: center">NSUnitElectricResistance</td>
<td style="text-align: center">欧姆</td>
</tr>
<tr>
<td style="text-align: center">NSUnitEnergy</td>
<td style="text-align: center">焦耳</td>
</tr>
<tr>
<td style="text-align: center">NSUnitFrequency</td>
<td style="text-align: center">赫兹</td>
</tr>
<tr>
<td style="text-align: center">NSUnitFuelEfficiency</td>
<td style="text-align: center">升/每100公里</td>
</tr>
<tr>
<td style="text-align: center">NSUnitLength</td>
<td style="text-align: center">米</td>
</tr>
<tr>
<td style="text-align: center">NSUnitIlluminance</td>
<td style="text-align: center">公斤</td>
</tr>
<tr>
<td style="text-align: center">NSUnitPower</td>
<td style="text-align: center">美国瓦茨</td>
</tr>
<tr>
<td style="text-align: center">NSUnitPressure</td>
<td style="text-align: center">牛顿/每平方米</td>
</tr>
<tr>
<td style="text-align: center">NSUnitSpeed</td>
<td style="text-align: center">秒/米</td>
</tr>
<tr>
<td style="text-align: center">NSUnitTemperature</td>
<td style="text-align: center">开尔文</td>
</tr>
<tr>
<td style="text-align: center">NSUnitVolume</td>
<td style="text-align: center">升</td>
</tr>
</tbody>
</table>

<hr/>

<h3 id="toc_3">总结</h3>

<p>苹果爸爸在这个库里提供了<code>170</code>多种不同的单位换算, 我这里只是用了一丢丢, 更多的方法有待各位去挖掘, 如果想了解更多的话, 可以去看看<a href="https://developer.apple.com/videos/play/wwdc2016/238/">WWDC 2016</a>的视频讲解.</p>

<hr/>

<h3 id="toc_4">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/7.Measurement">https://github.com/CainRun/iOS-10-Characteristic/tree/master/7.Measurement</a></p>

<hr/>

<h3 id="toc_5">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Notification Content Extensions》]]></title>
    <link href="https://cainrun.github.io/14974988224036.html"/>
    <updated>2017-06-15T11:53:42+08:00</updated>
    <id>https://cainrun.github.io/14974988224036.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Notification Content Extensions</h3>

<p>在之前我们就讲过苹果爸爸在<code>iOS 10</code>推出了一个新的<code>UserNotification</code>框架, 但苹果爸爸的野心不小, 不单单推出框架那么简单, 而且连<code>Extension</code>都给你搞了一个, 哼哼, 我看还有谁~</p>

<p>这里所演示的项目是和之前一样的, 如果找不到的盆友可以到<a href="https://cainrun.github.io/14973700585982.html">这里</a>去看看.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">添加Notification Extension</h3>

<p>回到我们的项目, 拷贝一份新的, 然后添加<code>Notification Extension</code>:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/6.Notification%20Content%20Extension/Images/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/6.Notification%20Content%20Extension/Images/2.png" alt="2"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/6.Notification%20Content%20Extension/Images/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_2">配置Notification Extension Info</h3>

<p>添加完<code>Extension</code>之后, 我们需要来配置一下<code>Info.plist</code>文件, 这里我们要添加点东西:</p>

<ul>
<li>UNNotificationExtensionDefaultContentHidden

<ul>
<li>设置成为YES</li>
</ul></li>
<li>UNNotificationExtensionCategory

<ul>
<li>和我们之前项目的<code>AppDelegate.m</code>文件所添加的<code>Category</code>保持一致, 我这里是<code>reminder</code></li>
</ul></li>
<li>UNNotificationExtensionInitialContentSizeRatio

<ul>
<li>这个东东我改为0.5</li>
</ul></li>
</ul>

<p>修改完成后的结果:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/6.Notification%20Content%20Extension/Images/4.png" alt="4"/></p>

<p>来通知的效果:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/6.Notification%20Content%20Extension/Images/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_3">自定义一个小方法</h3>

<p>上面的东西都搞定了之后, 那么接下来就是要自定义一个小方法:</p>

<pre><code class="language-objectivec">- (void)addShakeAnimation {
    
    CAKeyframeAnimation *frameAnimation = [CAKeyframeAnimation animation];

    frameAnimation.keyPath        = @&quot;transform.translation.x&quot;;
    frameAnimation.duration       = 1;
    frameAnimation.repeatCount    = MAXFLOAT;
    frameAnimation.values         = @[@-20.0, @20.0, @-20.0, @20.0, @-10.0, @10.0, @-5.0, @5.0, @0.0];
    frameAnimation.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionLinear];
    
    [self.view.layer addAnimation:frameAnimation
                           forKey:@&quot;shake&quot;];
}

- (void)removeShakeAnimation {
    
    [self.view.layer removeAnimationForKey:@&quot;shake&quot;];
}
</code></pre>

<ul>
<li><p>addShakeAnimation添加摇摆动画的方法</p></li>
<li><p>removeShakeAnimation删除摇摆动画的方法</p></li>
</ul>

<p>效果:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/6.Notification%20Content%20Extension/Images/6.gif" alt="6"/></p>

<hr/>

<h3 id="toc_4">- didReceiveNotificationResponse:completionHandler:方法</h3>

<p>在<code>Notification Extension</code>里, 有这么一个方法叫做: <code>- didReceiveNotificationResponse:completionHandler:</code>, 这个方法可以获取通知里的<code>Action</code>事件, 我这里是这么写的:</p>

<pre><code class="language-objectivec">- (void)didReceiveNotificationResponse:(UNNotificationResponse *)response
                     completionHandler:(void (^)(UNNotificationContentExtensionResponseOption))completion {
    
    if ([response.actionIdentifier isEqualToString:@&quot;cancel&quot;]) {
        
        UNNotificationRequest *request = response.notification.request;
        
        NSArray *identifiers = @[request.identifier];
        
        // 根据标识符删除等待通知
        [[UNUserNotificationCenter currentNotificationCenter] removePendingNotificationRequestsWithIdentifiers:identifiers];
        
        // 根据标识符删除发送通知
        [[UNUserNotificationCenter currentNotificationCenter] removeDeliveredNotificationsWithIdentifiers:identifiers];
        
        self.label.text = @&quot;点击了取消按钮&quot;;
        
        // 删除动画效果
        [self removeShakeAnimation];
        
        // 不隐藏通知页面
        completion(UNNotificationContentExtensionResponseOptionDoNotDismiss);
        
    } else {
        
        // 隐藏通知页面
        completion(UNNotificationContentExtensionResponseOptionDismiss);
    }
}
</code></pre>

<p>如果不懂这个动画应用的话, 我在度娘里看到了一篇文章, 可以来看看<a href="http://www.tuicool.com/articles/jeYfIv">IOS 核心动画之CAKeyframeAnimation</a></p>

<p>整体的运行效果:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/6.Notification%20Content%20Extension/Images/7.gif" alt="7"/></p>

<hr/>

<h3 id="toc_5">总结</h3>

<p>文章里只是简单的讲解, 如果还想了解更多的话, 可以自行去查看<a href="https://developer.apple.com/videos/play/wwdc2016/708/">WWDC 2016</a>的视频讲解.</p>

<hr/>

<h3 id="toc_6">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/6.Notification%20Content%20Extension">https://github.com/CainRun/iOS-10-Characteristic/tree/master/6.Notification%20Content%20Extension</a></p>

<hr/>

<h3 id="toc_7">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《UserNotifications》]]></title>
    <link href="https://cainrun.github.io/14973700585982.html"/>
    <updated>2017-06-14T00:07:38+08:00</updated>
    <id>https://cainrun.github.io/14973700585982.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UserNotifications</h3>

<p><code>Notification</code>在<code>iOS</code>以来发展以来都是一个非常重要的功能之一, 各类<code>App</code>都需要通过通知来推送消息, 不然怎么告诉用户, <code>App</code>来消息推送啦, 或者有什么安排事项到点要告诉你了, 这些都是需要推送的.</p>

<p>但我们都知道, 在之前的消息推送里, 无论是<code>UI</code>还是内容, 都是非常的死, 不够人性化, 好在苹果爸爸也看到了这一点, 在<code>iOS 10</code>就改善了这个东西.</p>

<p>同样我这里也是<code>Objective-C</code>版本, 喜欢看<code>Swift</code>版本的可以到<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/05%20-%20User%20Notifications">这里</a>去看.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">UNUserNotification Of iOS 10</h3>

<p>那么在<code>iOS 10</code>苹果爸爸推出了<code>UNUserNotification</code>这套框架, 除去了以前那套硬邦邦的通知之外, 我们可以额外给通知添加一些<code>Action Button</code>, 或者是一些不一样的内容, 说那么多废话, 直接来看项目吧.</p>

<hr/>

<h3 id="toc_2">创建项目</h3>

<p>新工程和我们以前创建的一毛一样, 这里就不过多的演示了, 文章后面有项目地址, 大家可以自行去看.</p>

<p>我们来看看<code>AppDelegate.m</code>文件:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/2.png" alt="2"/></p>

<p>这里要自己写代码的地方我都标上去了, 如果还是看不懂, 那我就真的没办法了...</p>

<p>再来看看<code>NotificationController.m</code>文件, 这里我们直接忽略掉<code>UI</code>的布局, 因为这不是重点:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/3.png" alt="3"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/4.png" alt="4"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/5.png" alt="5"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/6.png" alt="6"/></p>

<p>由于这里没有仔细的去封装代码, 所以看起来有些臃肿, 这个大家就不要喷了....</p>

<p>对了, 我想起一个坑, 在我导入<code>MP4</code>文件的时候, 我发现文件的<code>Path</code>居然为<code>nil</code>, 于是乎<code>Google</code>了一下, 发现是我傻缺了, 忘记在这里点一下:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/7.png" alt="7"/></p>

<p>关于怎么添加一些<code>Action Button</code>, 项目里面没有弄, 这里给大家贴句代码吧:</p>

<pre><code class="language-objectivec">UNTextInputNotificationAction *inputAction = [UNTextInputNotificationAction
                                                  actionWithIdentifier:@&quot;inputAction&quot;
                                                  title:@&quot;输入&quot;
                                                  options:UNNotificationActionOptionForeground
                                                  textInputButtonTitle:@&quot;发送&quot;
                                                  textInputPlaceholder:@&quot;随便说说&quot;];

    UNNotificationAction *goodbyeAction = [UNNotificationAction actionWithIdentifier:@&quot;goodbyeAction&quot;
                                                                               title:@&quot;再见&quot;
                                                                             options:UNNotificationActionOptionForeground];

    UNNotificationAction *cancelAction = [UNNotificationAction actionWithIdentifier:@&quot;cancelAction&quot;
                                                                              title:@&quot;取消&quot;
                                                                            options:UNNotificationActionOptionDestructive];


    UNNotificationCategory *category = [UNNotificationCategory categoryWithIdentifier:@&quot;inputCategory&quot; actions:@[inputAction,goodbyeAction,cancelAction] intentIdentifiers:@[] options:UNNotificationCategoryOptionCustomDismissAction];

    [[UNUserNotificationCenter currentNotificationCenter] setNotificationCategories:@[category]];
</code></pre>

<hr/>

<h3 id="toc_3">一切就绪</h3>

<p>一切就绪之后, 我们就运行来看看:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/8.png" alt="8"/></p>

<p>这是一个正常通知:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/9.png" alt="9"/></p>

<p>这是添加了<code>Image</code>的通知:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/10.png" alt="10"/></p>

<p>这是添加了一个<code>Video</code>的通知, 重点是还可以播放:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/5.UserNotifications/Images/11.png" alt="11"/></p>

<hr/>

<h3 id="toc_4">注意!!!</h3>

<p>虽然说苹果爸爸在<code>UNUserNotification</code>有了些花样, 但这里还是需要注意一点, 这是有限制的, 不然这也太不苹果了, 那么是什么限制呢? 可以点进去这里看看<a href="https://developer.apple.com/documentation/usernotifications/unnotificationattachment?language=objc">UNUserNotification类型文件限制</a>, 一旦超出了, 出现什么问题, 我就母鸡了.</p>

<p>再搜这篇文章的时候, 突然发现了有大神总结了<a href="http://www.jianshu.com/p/9b720efe3779">WWDC2016笔记</a>, 大家有需要可以去看看~~</p>

<hr/>

<h3 id="toc_5">总结</h3>

<p>文章里只是简单的讲解, 如果还想了解更多的话, 可以自行去查看<a href="https://developer.apple.com/videos/play/wwdc2016/707/">WWDC 2016</a>的视频讲解.</p>

<hr/>

<h3 id="toc_6">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/5.UserNotifications">https://github.com/CainRun/iOS-10-Characteristic/tree/master/5.UserNotifications</a></p>

<hr/>

<h3 id="toc_7">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《UIViewPropertyAnimator》]]></title>
    <link href="https://cainrun.github.io/14972802953896.html"/>
    <updated>2017-06-12T23:11:35+08:00</updated>
    <id>https://cainrun.github.io/14972802953896.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">UIViewPropertyAnimator</h3>

<p>我们之前在做基础动画效果的时候, 基本上的代码都是:</p>

<pre><code class="language-objectivec">    [UIView animateWithDuration:1
                          delay:0
                        options:UIViewAnimationOptionCurveEaseInOut
                     animations:^{
                         
                         // Do Something
                     } completion:^(BOOL finished) {
                         
                         // Do Something
                     }];
</code></pre>

<p>一般都会自己去封装一下, 免得大串代码在这里恶心....</p>

<p>但现在不用了咯, 自从苹果爸爸在<code>iOS 10</code>推出了一个框架<code>UIViewPropertyAnimator</code>, 可以更简洁的去省略很多代码, 我这里是<code>Objective-C</code>版本的, 如果想要看<code>Swift</code>版本, 可以到这里去看<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/04%20-%20UIViewPropertyAnimator">Swift版本</a></p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">创建项目</h3>

<p>废话就少说了, 直接看代码吧:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/1.png" alt="1"/></p>

<p>对外开放的方法有:<br/>
<img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/2.png" alt="2"/></p>

<p>用<code>UIViewPropertyAnimator</code>运行动画的代码:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/3.png" alt="3"/></p>

<p>效果:<br/>
<img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/4.gif" alt="4"/></p>

<p>看完之后估计很多人都会说, 这个有什么的, 之前的那个<code>API</code>也可以搞定, 那我们就继续往下看看吧.</p>

<hr/>

<h3 id="toc_2">为什么要用UIViewPropertyAnimator</h3>

<p>这里我找到了一段比较官方的说法:</p>

<blockquote>
<p><code>UIViewPropertyAnimator</code> 的 <code>API</code> 设计得很完善，可扩展性也很好。它<code>cover</code>了传统 <code>UIView animation</code>动画的绝大部分功能，并且大大增强了你对动画过程的掌控能力。具体来说，你可以在动画过程中任意时刻暂停，可以随后再选择继续，甚至还能在动画过程中动态改变动画的属性（例如，本来动画终点在屏幕左下角的，可以在动画过程中把终点改到右上角）。</p>
</blockquote>

<p>看完介绍之后, 到底是不是酱紫呢, 我们来加一句代码看看:</p>

<pre><code class="language-objectivec">    // 添加多一个渐渐消失的动画
    [propertyAnimator addAnimations:^{
        self.basicsView.alpha = 0;
    }];
</code></pre>

<p>效果:<br/>
<img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/5.gif" alt="5"/></p>

<p>除了这个, 如果要添加动画完成后的处理, 甚至是在动画进行中的一些操作也是可以的:</p>

<pre><code class="language-objectivec">    [propertyAnimator addCompletion:^(UIViewAnimatingPosition finalPosition) {
        
        NSLog(@&quot;动画结束咯&quot;);
    }];
    
    [propertyAnimator addCompletion:^(UIViewAnimatingPosition finalPosition) {
        
        switch (finalPosition) {
                
            case UIViewAnimatingPositionStart:
                
                NSLog(@&quot;动画开始了&quot;);
                
                break;
                
            case UIViewAnimatingPositionCurrent:
                
                NSLog(@&quot;动画结束咯&quot;);

                break;
                
            case UIViewAnimatingPositionEnd:
                
                NSLog(@&quot;正在执行动画&quot;);

                break;
            default:
                break;
        }
    }];
</code></pre>

<hr/>

<h3 id="toc_3">添加个拖拽器</h3>

<p><code>UIViewPropertyAnimator</code>不只是可以写好了规定的动画, 也可以和其他控件一起配合使用, 比如<code>UISlider</code>, 为了方便, 我就把<code>UIViewPropertyAnimator *propertyAnimator</code>设置成一个全局属性:</p>

<pre><code class="language-objectivec">@property (nonatomic, strong) UIViewPropertyAnimator *propertyAnimator;
</code></pre>

<p>然后开始实现我们的拖拽动画:</p>

<pre><code class="language-objectivec">- (void)addSliderWithSuperView {
    
    self.propertyAnimator = [[UIViewPropertyAnimator alloc] initWithDuration:5
                                                                       curve:UIViewAnimationCurveEaseIn
                                                                  animations:^{
                                                                                         
                                                                      [self.basicsView moveViewToBottmRight];
                                                                  }];

    UISlider *slider = [[UISlider alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, 40)];
    
    [slider addTarget:self
               action:@selector(sliderValueChanged:)
     forControlEvents:UIControlEventValueChanged];
    
    [self.basicsView addSubview:slider];
}

- (void)sliderValueChanged:(UISlider *)slider {
    
    self.propertyAnimator.fractionComplete = slider.value;
}
</code></pre>

<p>效果图:<br/>
<img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/6.gif" alt="6"/></p>

<hr/>

<h3 id="toc_4">反向动画</h3>

<p>如果你觉得就酱紫结束了, 那就太没意思了:</p>

<pre><code class="language-objectivec">/**
 反向动画
 */
- (void)viewAnimationCurveEaseInOut {
    
    UIButton *resetButton = [[UIButton alloc] initWithFrame:CGRectMake((self.view.frame.size.width / 2) - 100, 100, 200, 50)];
    
    [resetButton setTitleColor:[UIColor blackColor]
                      forState:UIControlStateNormal];
    [resetButton setTitle:@&quot;开始反向动画&quot;
                 forState:UIControlStateNormal];
    [resetButton addTarget:self
                    action:@selector(resetButtonAction)
          forControlEvents:UIControlEventTouchUpInside];
    
    [self.view addSubview:resetButton];
    
    self.propertyAnimator = [[UIViewPropertyAnimator alloc] initWithDuration:3
                                                                       curve:UIViewAnimationCurveEaseInOut
                                                                  animations:^{
                                                                      
                                                                      [self.basicsView moveViewToBottmRight];
                                                                  }];
    [self.propertyAnimator startAnimation];
}

/**
 按钮点击事件
 */
- (void)resetButtonAction {
    
    self.propertyAnimator.reversed = YES;
}
</code></pre>

<p>效果:<br/>
<img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/7.gif" alt="7"/></p>

<hr/>

<h3 id="toc_5">UISpringTimingParameters</h3>

<p>这里还可以配合着<code>UISpringTimingParameters</code>来使用:</p>

<pre><code class="language-objectivec">- (void)springTimingParameters {
    
    weakSelf(weakSelf);

    UISpringTimingParameters *springTimingParameters = [[UISpringTimingParameters alloc] initWithDampingRatio:0.3
                                                                                              initialVelocity:CGVectorMake(0, 0)];
    
    self.propertyAnimator = [[UIViewPropertyAnimator alloc] initWithDuration:4
                                                            timingParameters:springTimingParameters];
    
    [self.propertyAnimator addAnimations:^{
        
                            [weakSelf.basicsView moveViewToBottmRight];
    } delayFactor:3.0];
    
    [self.propertyAnimator startAnimation];
}
</code></pre>

<p>效果:<br/>
<img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/8.gif" alt="8"/></p>

<hr/>

<h3 id="toc_6">UICubicTimingParameters</h3>

<p>这里也可以配合着<code>UICubicTimingParameters</code>来玩耍~~</p>

<pre><code class="language-objectivec">/**
 UICubicTimingParameters 动画
 */
- (void)cubicTimingParameters {
    
    weakSelf(weakSelf);

    UICubicTimingParameters *cubicTimingParameters = [[UICubicTimingParameters alloc] initWithControlPoint1:CGPointMake(0.05, 0.95)
                                                                                              controlPoint2:CGPointMake(0.15, 0.95)];
    
    self.propertyAnimator = [[UIViewPropertyAnimator alloc] initWithDuration:4
                                                            timingParameters:cubicTimingParameters];
    
    
    [self.propertyAnimator addAnimations:^{
        
        [weakSelf.basicsView moveViewToBottmRight];
    } delayFactor:0.25];
    
    [self.propertyAnimator startAnimation];
}
</code></pre>

<p>效果:<br/>
<img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/4.UIViewPropertyAnimator/Images/9.gif" alt="9"/></p>

<p>大概就介绍到这里吧, 更复杂的玩法就有待各位大神去慢慢挖掘了~~</p>

<hr/>

<h3 id="toc_7">总结</h3>

<p>文章里只是简单的讲解, 如果还想了解更多的话, 可以自行去查看<a href="https://developer.apple.com/videos/play/wwdc2016/216/">WWDC 2016</a>的视频讲解.</p>

<hr/>

<h3 id="toc_8">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/4.UIViewPropertyAnimator">https://github.com/CainRun/iOS-10-Characteristic/tree/master/4.UIViewPropertyAnimator</a></p>

<hr/>

<h3 id="toc_9">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Xcode Extension》]]></title>
    <link href="https://cainrun.github.io/14972357977664.html"/>
    <updated>2017-06-12T10:49:57+08:00</updated>
    <id>https://cainrun.github.io/14972357977664.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Xcode Extension</h3>

<p>做<code>macOS</code>, <code>watchOS</code>, <code>tvOS</code>, <code>iOS</code>开发, 最离不开的工具就是<code>Xcode</code>, 但<code>Xcode</code>真的让我们又爱又恨, 虽然有很多强大的功能, 但细节方面真的很难<code>Care</code>到, 于是乎<a href="http://alcatraz.io">Alcatraz</a>诞生了, 在当时火的不要不要的, 只要是老司机都会装一个.</p>

<p>但现在苹果爸爸貌似看到了开发者的需求, 所以现在给<code>Xcode</code>加了一个功能, 就是<code>Xcode Extension</code>.</p>

<p>严格来说这不是<code>iOS</code>的东西, 但又刚刚好是随着<code>iOS 10</code>一起出来的, 想了想, 还是集合在这里吧.</p>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">创建项目</h3>

<p>这里我们需要创建的是<code>macOS</code>的项目:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/1.png" alt="1"/></p>

<p>然后在项目的<code>General</code>里找到添加<code>Extension</code>的选项:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/2.png" alt="2"/></p>

<p>选择<code>Xcode Editor Extension</code>:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/3.png" alt="3"/></p>

<p>这就是<code>Xcode Extension</code>啦:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/4.png" alt="4"/></p>

<p>顺便说说, 我在这个<code>info.plist</code>改了一下参数:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_2">注意</h3>

<p>这里有一个小坑, 注意要给我们<code>Xcode Extension</code>申请一个证书, 两边都要申请哦.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/6.png" alt="6"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/7.png" alt="7"/></p>

<p>不然就会报-67050错误:</p>

<pre><code class="language-vim">IDESourceEditorExtension: Xcode Source Editor Extension does not meet code signing requirement: me.ocean.XcodeExt.XcodeExtTest ((null)), Error Domain=DVTSecErrorDomain Code=-67050 &quot;code failed to satisfy specified code requirement(s)&quot; UserInfo={NSLocalizedDescription=code failed to satisfy specified code requirement(s)}
</code></pre>

<p>这里还有一个诡异的错误代码4097, 但我<code>clean</code>了一下工程之后就消失了, 大家注意注意.</p>

<pre><code class="language-vim">Hub connection error Error Domain=NSCocoaErrorDomain Code=4097
</code></pre>

<hr/>

<h3 id="toc_3">代码代码!!!</h3>

<p>这里我就随手写两句代码好了, <code>Xcode</code>的扩展还是靠各位大神去发挥想象, 我以后再掺和咯.</p>

<pre><code class="language-objectivec">    XCSourceTextBuffer *textBuffer = invocation.buffer;
    XCSourceTextRange *insertPointRange = textBuffer.selections[0];
    
    NSInteger startLine = insertPointRange.start.line;
    
    [textBuffer.lines insertObject:@&quot;这是什么鬼👻&quot; atIndex:startLine];
</code></pre>

<hr/>

<h3 id="toc_4">运行</h3>

<p>一切就绪之后, 我们就运行, 然后选择为<code>Xcode</code>添加插件:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/8.png" alt="8"/></p>

<p>等待运行完成之后, 会弹出一个灰色的<code>Xcode</code>:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/9.png" alt="9"/></p>

<p>这时不用理会, 我们回到正常的<code>Xcode</code>, 然后找到<code>Editor</code>, 点击它, 我们就会发现插件在这里啦:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/3.Xcode%20Extensions/Images/10.png" alt="10"/></p>

<p>但这里多说一句, 当我们停止运行之后, 插件又会不见了的, 这个需要大家自行去打包然后发布出来~~这里就不多说了, 详细大家去参考<a href="https://github.com/qfish/XAlign">XAlign</a>吧</p>

<hr/>

<h3 id="toc_5">总结</h3>

<p>文章里只是简单的讲解, 如果还想了解更多的话, 可以自行去查看<a href="https://developer.apple.com/videos/play/wwdc2016/414/">WWDC 2016</a>的视频讲解.</p>

<hr/>

<h3 id="toc_6">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/3.Xcode%20Extensions">https://github.com/CainRun/iOS-10-Characteristic/tree/master/3.Xcode%20Extensions</a></p>

<hr/>

<h3 id="toc_7">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Thread Sanitizer》]]></title>
    <link href="https://cainrun.github.io/14971830645415.html"/>
    <updated>2017-06-11T20:11:04+08:00</updated>
    <id>https://cainrun.github.io/14971830645415.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">Thread Sanitizer(TSan)</h3>

<blockquote>
<p><code>Thread Sanitizer</code>这个怎么翻译呢...其实我想了很久, <code>线程洗手液</code>? <code>线程清扫车</code>? 感觉都不太对....于是乎还是不翻译了, 我们只要知道这个东西是用来解决线程问题的就哦了, 我这个是<code>Objective-c</code>版本的, 如果你们喜欢<code>Swift</code>版本的话, 可以去找找<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/02%20-%20Thread%20Sanitizer">Swift版本</a></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">使用场景</h3>

<p>那么在什么时候会用到这个<code>Thread Sanitizer</code>呢? 其实就是在我们精心开发好一个App之后, 发现有断断续续不停的小Bug, 然后会导致<code>Crash</code>等问题, 你又没法找到的时候, 就可以用这个东西试试看啦.</p>

<p>那一般会在什么情况下会发生呢? 我找到了一段比较官方的文字, 大家凑合着看看吧.</p>

<blockquote>
<p>通常， 这些都是多个线程同时访问内存中的同一段地址造成的。相信线程问题是许多开发人员的噩梦。它们难以跟踪，因为错误只发生在某些条件下，所以确定问题的根本原因可能是非常棘手的。通常的原因是所谓的“race condition”。</p>

<p>当两个线程并发访问同一个变量，并且至少有一个访问是写时，会发生数据竞争。</p>
</blockquote>

<hr/>

<h3 id="toc_2">Thread Sanitizer(TSan)可以检查的类型错误</h3>

<p>虽然说<code>Thread Sanitizer</code>这个工具很牛逼, 但也不是万能的, 它只能够检测出以下几种错误.</p>

<ul>
<li>Use of uninitialized mutexes</li>
<li>Thread leaks (missing phread_johin)</li>
<li>Unsafe calls in signal handlers (ex:malloc)</li>
<li>Unlock from wrong thread</li>
<li>Data race</li>
</ul>

<hr/>

<h3 id="toc_3">打开Thread Sanitizer工具</h3>

<p><code>Thread Sanitizer</code>工具是在工程里的<code>Edit Scheme</code> -&gt; <code>Diagnostics</code>打开, <br/>
并不像<code>Instruments</code>那样在<code>Developer Tools</code>里打开.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/2.Thread%20Sanitizer/Images/1.png" alt="1"/></p>

<hr/>

<h3 id="toc_4">创建项目</h3>

<p>一切所有的东西, 都要从代码入手, 这里我们也是一样, 写一个小小的<code>Demo</code>来演示演示, <code>UI</code>略丑, 大家凑合着看吧....代码的话, 在工程里自行去翻查吧~</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/2.Thread%20Sanitizer/Images/2.png" alt="2"/></p>

<p>里面的布局代码也没有什么好看的, 这里直接用的是<code>Masonry</code>, 感谢<code>Masonry</code>作者的无私奉献~~</p>

<hr/>

<h3 id="toc_5">运算逻辑</h3>

<p>这里我就不写那么大的数额了, 就取十位数哦了(别说我小气), </p>

<p>这里的存入逻辑灰常的简单, 计算完结果之后就传入进去:</p>

<pre><code class="language-objectivec">- (void)setMoneyInTheBank {
    
    NSString *amount = [NSString stringWithFormat:@&quot;总额: ¥%ld&quot;, self.bankView.amount + 10];
    
    [self.bankView changeLabelContentWithString:amount];
}
</code></pre>

<p>本来接着要去写取得逻辑, 但这里想到一个情况, 快速的按存和取, 那就会发生刚刚在文章开头所说的数据竞争问题, 这里经过思考后, 发现要使用一丢丢多线程的技巧.</p>

<pre><code class="language-objectivec">- (void)getMoneyOfBanek {
    
    dispatch_async(dispatch_queue_create(&quot;com.threadsanitizer.ThreadSanitizer&quot;, nil), ^{
        
        if (self.amount &lt;= 0) {
            NSLog(@&quot;你都没钱啦, 怎么取?&quot;);
            
            return;
        }
        
        // 这是让线程先休息一秒先~
        sleep(1);
        
        dispatch_async(dispatch_get_main_queue(), ^{
            
            NSString *amount = [NSString stringWithFormat:@&quot;总额: ¥%ld&quot;, self.amount -= 10];

            [self.bankView changeLabelContentWithString:amount];
        });
    });
}
</code></pre>

<p>写完之后, 然后运行, 狂点存和取, 然后就会出现下面酱紫的画面:</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/2.Thread%20Sanitizer/Images/3.png" alt="3"/></p>

<p>是不是很容易就找出问题的所在呢?</p>

<blockquote>
<p>原理的话, 大概就和你吃饭一样, 先咽下第一口再咽下第二口, 不然一起咽下, 就会呛着了.</p>
</blockquote>

<p>顺便说说: </p>

<ul>
<li>TSan 是一个检查 Runtime Issues 的工具 (不支持静态检查)</li>
<li>只能运行在语言版本3编写的Swift代码上 (Objective-C也可兼容)，</li>
<li>只能在64位macOS 或 64位模拟器上运行 (所有真机设备都不可以用来调试)。</li>
</ul>

<hr/>

<h3 id="toc_6">总结</h3>

<p>文章里只是简单的讲解, 如果还想了解更多的话, 可以自行去查看<a href="https://developer.apple.com/videos/play/wwdc2016/412/">WWDC 2016</a>的视频讲解.</p>

<hr/>

<h3 id="toc_7">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/2.Thread%20Sanitizer">https://github.com/CainRun/iOS-10-Characteristic/tree/master/2.Thread%20Sanitizer</a></p>

<hr/>

<h3 id="toc_8">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Message Extension》]]></title>
    <link href="https://cainrun.github.io/14969899245168.html"/>
    <updated>2017-06-09T14:32:04+08:00</updated>
    <id>https://cainrun.github.io/14969899245168.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">说点废话</h3>

<blockquote>
<p>中途因为发生了点事, 所以有一段时间没有写博文了, 现在开始开始慢慢写回, 写的风格也改了一些, 大家不懂得可以去各大博客, 论坛, 等等地方翻翻资料, 如果一定要找我问问题的话, 麻烦先用红包来打一下我, 祝大家学习愉快.</p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">Message</h3>

<p><code>Message</code>是苹果爸爸在<code>iOS 10</code>开放给开发者的库, 虽然说是新的库, 但和在<code>iOS 8</code>所使用的方式差不多, 就是<code>Extension</code>, 我们都知道<code>iOS</code>是封闭系统, 所以就不用抱着会和<code>Android</code>那样的开发.</p>

<p>作为<code>Extension</code>有什么好处咧, 按照官方的说法就是, 既可以保证系统的安全, 又可以独立于<code>App</code>之外, 不必绑定父应用程序的一部分.</p>

<p>这里注明一下, 我这个是<code>Objective-C</code>版本的, 如果要找<code>Swift</code>版本的话, 可以到这里去<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/01%20-%20Messages">Swift-Message</a>.</p>

<hr/>

<h3 id="toc_2">创建项目</h3>

<p>创建<code>Message</code>很简单, 打开<code>Xcode -&gt; New Project -&gt; iMessage Application</code>就搞定了.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/1.Message/Images/1.png" alt="1"/></p>

<p>创建完之后, 我们就可以看到一个<code>MessageViewController</code>, 这个是苹果爸爸一开始就给我们弄好的控制器, 我们只需要在上面弄我们所需要的东西就好.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/1.Message/Images/2.png" alt="2"/></p>

<hr/>

<h3 id="toc_3">两个重要的方法</h3>

<p>这里有两个重要的方法是我们必须知道的</p>

<pre><code class="language-objectivec">// 当我们即将打开Message Extension的时候, 就会调用这个方法
- (void)willBecomeActiveWithConversation:(MSConversation *)conversation;
</code></pre>

<pre><code class="language-objectivec">// 当我们即将操作Message Extension的时候, 就会调用这个方法, 可以选择不同的样式, 然后决定你的Message Extension的显示方式
-
(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;
</code></pre>

<hr/>

<h3 id="toc_4">添加新的控制器</h3>

<p>为了可扩展性和低耦合, 我打算把整个<code>Message Extension</code>拆的非常零散, 这个时候就需要好几个<code>Controller</code>去分别管理它们自己的业务逻辑了.</p>

<p>这里顺便加一个第三方的库<code>Masonry</code>, 感谢<code>Masonry</code>作者的无私奉献~~</p>

<p>我这个<code>Demo</code>里一共有三个自己创建的控制器, 分别是<code>MessageStartController</code>, <code>MessageFinishController</code>, <code>MessageChangeController</code></p>

<p>由于只是简单的演示, 所以这边就不弄的那么复杂了, 详细的代码自己可以去看看, 也很简单.</p>

<hr/>

<h3 id="toc_5">MessagesViewController</h3>

<p>回到我们的<code>MessagesViewController</code>, 这里主要讲讲我的代码:</p>

<pre><code class="language-objectivec">/**
 Configure ChildController

 @param presentationStyle MSMessagesAppPresentationStyle
 @param conversation MSConversation
 */
- (void)configureChildViewControllerWithPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle
                                             conversation:(MSConversation *)conversation {
    
    // 清除所有的自控制器
    for (UIViewController *childController in self.childViewControllers) {
        
        [childController willMoveToParentViewController:nil];
        [childController.view removeFromSuperview];
        [childController removeFromParentViewController];
    }
    
    switch (presentationStyle) {
        case MSMessagesAppPresentationStyleCompact:
            
            self.childViewController = [self createMessageStartController];
            
            break;
        case MSMessagesAppPresentationStyleExpanded:{
            
            MSMessage *message = conversation.selectedMessage;
            
            if (message) {
                
                self.childViewController = [self createChangeControllerWithConversation:conversation];

            } else {
                self.childViewController = [self createFinishControllerWithConversation:conversation];
            }
        }
            break;
        default:
            break;
    }
    
    // 添加子控制器
    [self addChildViewController:self.childViewController];
    
    [self.view addSubview:self.childViewController.view];
    
    [self.childViewController.view mas_makeConstraints:^(MASConstraintMaker *make) {
        (void)make.edges;
    }];
    
    [self.childViewController didMoveToParentViewController:self];
}
</code></pre>

<p>之前也说过, 为了灵活性和低耦合, 上面那个方法就是用来添加和删除子控制器的.</p>

<pre><code class="language-objectivec">- (void)willBecomeActiveWithConversation:(MSConversation *)conversation {
    
    [self configureChildViewControllerWithPresentationStyle:self.presentationStyle
                                               conversation:conversation];
}

-(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle {

    [self configureChildViewControllerWithPresentationStyle:presentationStyle
                                               conversation:self.activeConversation];
}
</code></pre>

<p>上面这两个方法就是在<code>Message Extension</code>在切换不同样式的时候, 去调用<code>configureChildViewControllerWithPresentationStyle:</code>方法, 来达到在不同样式下可以切换不同的子控制器.</p>

<pre><code class="language-objectivec">/**
 Configure Message Start Controller

 @return UIViewController
 */
- (UIViewController *)createMessageStartController {
    
    MessageStartController *childController = [[MessageStartController alloc] init];
    
    [childController setMessageStartBloack:^(UIButton *sender){
        
        [self requestPresentationStyle:MSMessagesAppPresentationStyleExpanded];
    }];
    
    return childController;
}

/**
 Configure Message Finish Controller
 
 @return UIViewController
 */
- (UIViewController *)createFinishControllerWithConversation:(MSConversation *)conversation {
    
    MessageFinishController *finishController = [[MessageFinishController alloc] init];
    
    [finishController setMessageFinishBloack:^(UIButton *sender){
        
        MSSession *session = [[MSSession alloc] init];
        
        NSString *player = [NSString stringWithFormat:@&quot;%@ - 是否要发送这条内容?&quot;, conversation.localParticipantIdentifier];
        
        [self insertMessageWithCaption:player
                               session:session
                                 image:[UIImage ms_getImageForView:self.view]
                          conversation:conversation];
        
        [self dismiss];
    }];
    
    return finishController;
}

/**
 Configure Message Change Controller
 
 @return UIViewController
 */
- (UIViewController *)createChangeControllerWithConversation:(MSConversation *)conversation {
    
    MessageChangeController *changeViewController = [[MessageChangeController alloc] init];
    
    [changeViewController setMessageChangeBloack:^(UIButton *sender){
        
        MSMessage *message = conversation.selectedMessage;
        
        if (message) {
            
            MSSession *session = [message session];
            
            NSString *player = [NSString stringWithFormat:@&quot;%@ - 是否要发送更改后的内容?&quot;, conversation.localParticipantIdentifier];
            
            [self insertMessageWithCaption:player
                                   session:session
                                     image:[UIImage ms_getImageForView:self.view]
                              conversation:conversation];
        }
        
        [self dismiss];
    }];
    
    return changeViewController;
}
</code></pre>

<p>上面这三个方法就是用来配置<code>MessageStartController</code>, <code>MessageFinishController</code>, <code>MessageChangeController</code>三个控制器.</p>

<hr/>

<h3 id="toc_6">重点</h3>

<p>这里需要重点讲一个方法:</p>

<pre><code class="language-objectivec">/**
 把内容插入到Message中

 @param caption NSString
 @param session MSSession
 @param image UIImage
 @param conversation MSConversation
 */
- (void)insertMessageWithCaption:(NSString *)caption
                         session:(MSSession *)session
                           image:(UIImage *)image
                    conversation:(MSConversation *)conversation {
    
    MSMessage *message = [[MSMessage alloc] initWithSession:session];
    MSMessageTemplateLayout *templateLayout = [[MSMessageTemplateLayout alloc] init];
    
    templateLayout.caption = caption;
    templateLayout.image = image;
    
    message.layout = templateLayout;
    message.URL = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;];
    
    [conversation insertMessage:message
              completionHandler:nil];
}

</code></pre>

<p>这个方法, 可以把我们想要内容插入到<code>Message Extension</code>中, 然后发送出去.</p>

<hr/>

<h3 id="toc_7">最终效果</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/1.Message/Images/3.gif" alt="3"/></p>

<hr/>

<h3 id="toc_8">总结</h3>

<p>文章里只是简单的讲解, 如果还想了解更多的话, 可以自行去查看<a href="https://developer.apple.com/videos/play/wwdc2016/224/">WWDC 2016</a>的视频讲解.</p>

<hr/>

<h3 id="toc_9">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/1.Message">https://github.com/CainRun/iOS-10-Characteristic/tree/master/1.Message</a></p>

<hr/>

<h3 id="toc_10">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：7.《Core Animation》Implicit Animations]]></title>
    <link href="https://cainrun.github.io/14807833712288.html"/>
    <updated>2016-12-04T00:42:51+08:00</updated>
    <id>https://cainrun.github.io/14807833712288.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在上一篇文章<a href="https://cainrun.github.io/14790557329421.html">《Core Animation》CALayer的Specialized Layers</a>中, 我们了解了<strong>CALayer</strong>的许多子类特性, 可以为我们在遇到一些特殊的开发需求中提供一定的帮助, 既然我们这次学的的<strong>Core Animation</strong>, 那怎么会和动画不挂钩呢? 这次让我们来初体验一下.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>Implicit Animations</strong>也称为隐式动画, 啥? 什么叫做隐式动画? 百度去吧~~哈哈哈(后面会讲解的), 这些问题就不在这里做解释了, 还是进入主题才比较重要.</p>
</blockquote>

<hr/>

<h3 id="toc_2">Transactions</h3>

<blockquote>
<p>其实在<strong>Core Animation</strong>中, 动画效果并不需要我们去手动打开, 因为系统默认就是<strong>Open</strong>状态, 相反过来, 如果我们不需要动画的话, 我们需要手动的去关闭.<br/>
<dr/><br/>
如果我们用一个<strong>CALayer</strong>的一个动画属性, 并且尝试去改变它, 这个效果并不会马上就显示出来, 因为它要从一个默认值平滑的过度到一个新的值, 而这些所有的内部操作我们都不需要去理会, 因为系统默认就是这么做的.<br/>
<dr/><br/>
我们可以先来看个<strong>Demo</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)transactionsColor {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0,
                                                            100,
                                                            self.view.frame.size.width,
                                                            self.view.frame.size.width)];
    
    view.backgroundColor = [UIColor grayColor];
    
    [self.view addSubview:view];
    
    UIButton *button = [[UIButton alloc] init];
    
    button.center = CGPointMake(self.view.frame.size.width / 2, 50);
    button.bounds = CGRectMake(0, 0, 100, 50);
    button.backgroundColor = [UIColor blueColor];
    
    [button setTitle:@&quot;改变颜色&quot;
            forState:UIControlStateNormal];
    [button addTarget:self
               action:@selector(changeLayerColor)
     forControlEvents:UIControlEventTouchUpInside];
    
    [view addSubview:button];
    
    self.colorLayer  = [CALayer layer];
    self.colorLayer.position = CGPointMake(view.frame.size.width / 2, view.frame.size.height / 2);
    self.colorLayer.bounds = CGRectMake(0, 0, 150, 150);
    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    
    [view.layer addSublayer:self.colorLayer];
}

- (void)changeLayerColor {
    
    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                      green:greenColor
                                                       blue:blueColor
                                                      alpha:1.0f].CGColor;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/1.gif" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/2.png" alt="2"/></p>

<blockquote>
<p>看完这个<strong>Demo</strong>其实就已经知道神马叫做隐式动画了, 所谓的隐式动画就是我们没有给它指定任何的动画类型, 仅仅只是改变某个属性, 当然<strong>Core Animation</strong>也是支持显示动画, 不然我们就没那么多的兴趣来学习<strong>Core Animation</strong>了~<br/>
<dr/><br/>
那么当我们去改变一个属性的时候, <strong>Core Animation</strong>是如何去判断动画类型还有动画的持续时间呢? 这个问题其实也很简单, 动画的执行时间取决于<strong>Transactions</strong>的设置, 而动画类型是取决于<strong>CALayer</strong>的行为.<br/>
<dr/><br/>
其实<strong>Transactions</strong>实际上是<strong>Core Animation</strong>用来包含一堆属性动画集合的机制, 任何用指定<strong>Transactions</strong>去改变可以做动画效果的图层属性都不会马上发生变化, 而是需要<strong>Transactions</strong>在提交的一瞬间, 才会开始用一个动画效果过渡到新设置的值.<br/>
<dr/><br/>
而<strong>Transactions</strong>是需要通过<strong>CATransaction</strong>这个类来进行管理的, 奇怪的是, <strong>CATransaction</strong>这个类并不是管理一个简单的<strong>Transactions</strong>, 而是管理了一堆我们不能访问的<strong>Transactions</strong>, 由于<strong>CATransaction</strong>并没有属性和实例化方法, 也不能用<strong>+ (instancetype)alloc;</strong>和<strong>- (instancetype)init;</strong>方法来创建它, 只有它所提供的<strong>+ (void)begin;</strong>和<strong>+ (void)commit;</strong>来控制.<br/>
<dr/><br/>
虽然我们再上面的<strong>Demo</strong>里没有设置动画时间, 但<strong>Core Animation</strong>会在每一个<strong>run looop</strong>周期中自动开始一次新的<strong>Transactions</strong>, 即使我们不手动的去调用<strong>[CATransaction begin];</strong>, 但在每一次<strong>run loop</strong>的循环中, 被修改的属性都会集中起来, 然后统一做一次0.25秒的动画, 这个是系统默认的.<br/>
<dr/><br/>
说了那么多, 我们实际上来改改修改颜色的那个代码块, 让它有一个显示动画的效果:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)changeLayerColorAgain {
    
    [CATransaction begin];
    [CATransaction setAnimationDuration:2.0f];
    
    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                      green:greenColor
                                                       blue:blueColor
                                                      alpha:1.0f].CGColor;
    
    [CATransaction commit];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/3.gif" alt="3"/></p>

<blockquote>
<p>看起来的效果让人觉得是真的有动画效果了, 如果大家在之前就已经用过<strong>UIView</strong>来做过动画的话, 那么大家应该对这个动画模式不会感觉到陌生, 因为<strong>UIView</strong>就有两个类似的方法, <strong>+ (void)beginAnimations:(nullable NSString *)animationID context:(nullable void *)context;</strong>和<strong>+ (void)commitAnimations;</strong>, 其实这两个这两个方法也是因为在内部设置了<strong>CATransaction</strong>的原因.<br/>
<dr/><br/>
在<strong>iOS 4</strong>的时候, 苹果就已经对<strong>UIView</strong>添加了一种基于<strong>Block</strong>的动画方法, <strong>+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (<sup>)(void))animations</sup> NS_AVAILABLE_IOS(4_0);</strong>, 用起来更加的方便, 但实际上是做同样的事情, 但使用这种方法就可以避免<strong>+ (void)begin;</strong>和<strong>+ (void)commit;</strong>匹配的问题造成一些蛋疼的事情.</p>
</blockquote>

<hr/>

<h3 id="toc_3">Completion Blocks</h3>

<blockquote>
<p>这里我们就使用一下基于<strong>UIView</strong>的<strong>Block</strong>动画方法, 我们可以在动画结束之后再对这个图层进行一些操作, 当然这里还是基于上面的<strong>Demo</strong>来做演示:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)changeLayerColorWithCompletion {
    
    [CATransaction begin];
    [CATransaction setAnimationDuration:2.0f];
    
    [CATransaction setCompletionBlock:^{
        CGAffineTransform transform = self.colorLayer.affineTransform;
        
        transform = CGAffineTransformRotate(transform, M_PI_4);
        
        self.colorLayer.affineTransform = transform;
    }];
    
    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                      green:greenColor
                                                       blue:blueColor
                                                      alpha:1.0f].CGColor;
    
    [CATransaction commit];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/4.gif" alt="4"/></p>

<hr/>

<h3 id="toc_4">Layer Actions</h3>

<blockquote>
<p>开始的时候我们就用一个<strong>Demo</strong>来进行演示:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addLayerView {
    
    self.layerView = [[UIView alloc] init];
    self.layerView.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);
    self.layerView.bounds = CGRectMake(0, 0, 150, 150);
    self.layerView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:self.layerView];
    
    UIButton *button = [[UIButton alloc] init];
    
    button.center = CGPointMake(self.view.frame.size.width / 2, 200);
    button.bounds = CGRectMake(0, 0, 100, 50);
    button.backgroundColor = [UIColor blueColor];
    
    [button setTitle:@&quot;改变颜色&quot;
            forState:UIControlStateNormal];
    
    [button addTarget:self
               action:@selector(changeLayerViewColor)
     forControlEvents:UIControlEventTouchUpInside];
    
    [self.view addSubview:button];
}

- (void)changeLayerViewColor {
    
    [CATransaction begin];
    [CATransaction setAnimationDuration:2.0f];
    
    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.layerView.layer.backgroundColor = [UIColor colorWithRed:redColor
                                                           green:greenColor
                                                            blue:blueColor
                                                           alpha:1.0f].CGColor;
    
    [CATransaction commit];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/5.gif" alt="5"/></p>

<blockquote>
<p>看完这个<strong>Demo</strong>, 有很多人肯定会有疑问, 为啥没有了之前的那个平滑过渡效果呢? 好像是被干掉了, 这是啥回事?<br/>
<dr/><br/>
其实我们可以仔细想一想, 如果<strong>UIView</strong>里的属性都有动画特性的话, 那我们去修改这些属性时, 肯定会注意到的, 可为啥<strong>UIKit</strong>要把这个隐式动画给禁止呢?<br/>
<dr/><br/>
我们都知道<strong>Core Animation</strong>通常会对<strong>CALayer</strong>所有的可做动画的属性都赋予了动画特性, 但在<strong>UIView</strong>中就不一样了, 它会默认把所关联在一起的<strong>CALayer</strong>的这个特性给关闭掉, 这里就要了解一下隐式动画是如何实现的.<br/>
<dr/><br/>
当我们改变<strong>CALayer</strong>属性时, <strong>CALayer</strong>自动应用的动画, 我们可以成为<strong>CALayer</strong>的行为, 每当<strong>CALayer</strong>的属性被修改的时候, 它会去调用<strong>- (nullable id<CAAction>)actionForKey:(NSString *)event;</strong>这个方法去传递属性的名称, 然后就会去执行如下几步:</p>

<ul>
<li>首先<strong>CALayer</strong>会去检测它是否有<strong>Delegate</strong>, 并且看看这个<strong>Delegate</strong>有没有实现<strong>CALayerDelegate</strong>协议里的<strong>- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;</strong>方法, 如果有, 就直接调用并返回结果.</li>
<li>如果<strong>CALayer</strong>没有<strong>Delegate</strong>的话, 或者<strong>Delegate</strong>没有实现<strong>- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;</strong>方法, 那么图层就会接着去检查包含属性名称对应的<strong>CALayer</strong>行为所映射的<strong>Actions</strong>字典.</li>
<li>如果<strong>Actions</strong>字典没有包含对应的属性, 那么图层接着会在它的<strong>style</strong>字典里接着搜索属性名.</li>
<li><p>最后, 在<strong>style</strong>里也找不到对应的行为, 那么图层就会直接调用<strong>+ (nullable id<CAAction>)defaultActionForKey:(NSString *)event;</strong>实现系统所提供的每个属性的默认行为.<br/>
<dr/><br/>
如果一轮完整的搜索结束之后, <strong>- (nullable id<CAAction>)actionForKey:(NSString *)event;</strong>返回为空的话, 那么肯定不会有动画效果, 如果返回<strong>CAAction</strong>协议对应的对象, <strong>CALayer</strong>会拿这个结果去对比先前和当前的值, 并且做一个动画效果.<br/>
<dr/><br/>
知道这个原理之后, 我们就知道<strong>UIKit</strong>是肿么把隐式动画给禁止掉了:</p></li>
<li><p>每一个<strong>UIView</strong>对它所关联的图层都是充当一个<strong>Delegate</strong>对象, 并且提供了<strong>- (nullable id<CAAction>)actionForKey:(NSString *)event;</strong>的实现方法.</p></li>
<li><p>当不在一个动画块的实现中, 那么<strong>UIView</strong>就会对所有<strong>CALayer</strong>的行为返回<strong>nil</strong>, 如果在动画的<strong>Block</strong>范围之内, <strong>UIView</strong>就会返回一个非空的值.<br/>
<dr/><br/>
这里我们简单的<strong>Log</strong>一下结果:</p></li>
</ul>
</blockquote>

<pre><code class="language-objectivec">- (void)checkViewAction {
    
    UIView *layerView = [[UIView alloc] init];
    
    layerView.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);
    layerView.bounds = CGRectMake(0, 0, 150, 150);
    layerView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:layerView];
    
    NSLog(@&quot;Before: %@&quot;, [layerView actionForLayer:layerView.layer
                                            forKey:@&quot;backgroundColor&quot;]);
    
    [UIView beginAnimations:nil
                    context:nil];
    
    NSLog(@&quot;After: %@&quot;, [layerView actionForLayer:layerView.layer
                                           forKey:@&quot;backgroundColor&quot;]);
    
    [UIView commitAnimations];
}
</code></pre>

<pre><code class="language-vim">2016-12-04 12:45:28.178 7.ImplicitAnimations[57079:2126402] Before: &lt;null&gt;
2016-12-04 12:45:28.179 7.ImplicitAnimations[57079:2126402] After: &lt;CABasicAnimation: 0x6000000327c0&gt;
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/6.png" alt="6"/></p>

<blockquote>
<p>这样子我们就可以知道, 当属性在<strong>Block</strong>之外发生改变, <strong>UIView</strong>会直接通过返回<strong>nil</strong>来禁用隐式动画, 但如果在动画块的范围之内, 就会根据动画的具体类型来返回相应的属性, 这个后续会讲到.<br/>
<dr/><br/>
其实除了通过返回<strong>nil</strong>并不是唯一禁止隐式动画的方法, 我们也可以通过<strong>CATransacition</strong>的<strong>+ (void)setDisableActions:(BOOL)flag;</strong>方法, 通过<strong>flag</strong>来对所有属性打开或者关闭隐式动画, 哪怕你是在<strong>[CATransaction begin];</strong>之后来添加, 也是一样可以关闭的.<br/>
<dr/><br/>
这里还有一个<strong>Demo</strong>, 使用<strong>CATransaction</strong>来实现的一个叫做<strong>推进过渡</strong>动画, 其实说白也就是一个<strong>Push</strong>动画:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)pushAnimation {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0,
                                                            100,
                                                            self.view.frame.size.width,
                                                            self.view.frame.size.width)];
    
    view.backgroundColor = [UIColor grayColor];
    
    [self.view addSubview:view];
    
    UIButton *button = [[UIButton alloc] init];
    
    button.center = CGPointMake(self.view.frame.size.width / 2, 50);
    button.bounds = CGRectMake(0, 0, 100, 50);
    button.backgroundColor = [UIColor blueColor];
    
    [button setTitle:@&quot;改变颜色&quot;
            forState:UIControlStateNormal];
    
    [button addTarget:self
               action:@selector(pushChangeColor)
     forControlEvents:UIControlEventTouchUpInside];
    
    [view addSubview:button];
    
    self.colorLayer  = [CALayer layer];
    self.colorLayer.position = CGPointMake(view.frame.size.width / 2, view.frame.size.height / 2);
    self.colorLayer.bounds = CGRectMake(0, 0, 150, 150);
    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    
    CATransition *transition = [CATransition animation];
    
    transition.type = kCATransitionPush;
    transition.subtype = kCATransitionFromLeft;
    
    self.colorLayer.actions = @{@&quot;backgroundColor&quot;: transition};
    
    [view.layer addSublayer:self.colorLayer];
}

- (void)pushChangeColor {
    
    [CATransaction begin];
    [CATransaction setAnimationDuration:2.0f];

    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                      green:greenColor
                                                       blue:blueColor
                                                      alpha:1.0f].CGColor;
    [CATransaction commit];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/7.gif" alt="7"/></p>

<hr/>

<h3 id="toc_5">Presentation Versus Model</h3>

<blockquote>
<p>其实仔细想想, <strong>CALayer</strong>的属性行为并不太正常, 为何这么说呢, 因为当我们去改变一个图层的属性时, 我们会发现, 这个值的确是立即发生了改变, 但在屏幕上并没有马上生效, 为何呢? 因为我们在设置属性的时候, 并没有直接去调整图层的显示外观, 仅仅只是定义了图层动画结束之后即将要发生改变的外观.<br/>
<dr/><br/>
<strong>Core Animation</strong>在这里充当了一个控制器的角色, 并且根据<strong>Layer Actions</strong>和<strong>Transactions</strong>来更新视图在屏幕上显示的状态.<br/>
<dr/><br/>
在于用户交互的界面中, <strong>CALayer</strong>的行为更像是保存着视图如何去显示和动画的执行数据模型.<br/>
<dr/><br/>
在<strong>iOS</strong>中, 屏幕会以每秒钟重绘60次, 如果动画市场比60分之一秒还要长, 那么在这段时间里, <strong>Core Animation</strong>就会对屏幕上的图层进行重新的组合, 这就意味着<strong>CALayer</strong>除了我们给予的值之外, 还必须要知道当前显示在屏幕上的属性值的记录.<br/>
<dr/><br/>
而每个图层属性的显示值都会被存储在一个叫做<strong>呈现图层</strong>的独立图层当中, 我们可以通过<strong>- (nullable instancetype)presentationLayer;</strong>方法来访问, 而这个所谓的<strong>呈现图层</strong>, 实际上就是模型图层的复制, 但它的好处是它的属性值代表了在任何指定时间当前所显示的外观效果, 通俗点来讲, 就是我们可以通过获取<strong>呈现图层</strong>的值来获取当前屏幕上真正显示出来的值.<br/>
<dr/><br/>
这里需要注意的一点就是, 如果在<strong>呈现图层</strong>仅仅当<strong>CALayer</strong>首次被提交的时候创建, 那么去调用<strong>- (nullable instancetype)presentationLayer;</strong>方法就会返回<strong>nil</strong>.<br/>
<dr/><br/>
这里我们或许还会注意到另一个方法<strong>- (instancetype)modelLayer;</strong>, 如果我们在呈现图层上调用这个方法, 那么就会返回一个它正在呈现所以来的<strong>CALayer</strong>, 而通常在一个图层上调用这个方法, 就会返回<strong>self</strong>.<br/>
<dr/><br/>
在大多数开发的场景下, 我们都不需要直接访问呈现图层, 我们可以通过和模型图层的交互, 来让<strong>Core Animation</strong>更新并且显示, 但在以下两种场景下<strong>呈现图层</strong>就非常有用了, 一个是在同步动画里, 一个是在处理用户交互的时候:</p>

<ul>
<li>如果我们在实现一个基于定时器的动画, 而不仅仅是基于<strong>Transactions</strong>的动画, 这个时候我们就要准确的知道在某一时刻图层显示在什么位置, 这就会对正确的布局起非常大的作用了.</li>
<li>如果我们想让做动画的图层对于用户有交互, 我们可以使用<strong>- (nullable CALayer *)hitTest:(CGPoint)p;</strong>方法来判断指定的图层是否被点击了, 这个时候就会显示更加的友好, 因为<strong>呈现图层</strong>代表了用户当前看到的图层位置, 而不是当动画效果结束之后的位置.
<dr/>
说了那么多, 还是直接上<strong>Demo</strong>比较直接:</li>
</ul>
</blockquote>

<pre><code class="language-objectivec">- (void)presentationVersusModel {
    
    self.colorLayer  = [CALayer layer];
    self.colorLayer.position = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);
    self.colorLayer.bounds = CGRectMake(0, 0, 150, 150);
    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    
    [self.view.layer addSublayer:self.colorLayer];
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    
    CGPoint point = [[touches anyObject] locationInView:self.view];
    
    if ([self.colorLayer.presentationLayer hitTest:point]) {
        
        CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
        CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
        CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
        
        self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                          green:greenColor
                                                           blue:blueColor
                                                          alpha:1.0f].CGColor;
    } else {
        [CATransaction begin];
        [CATransaction setAnimationDuration:4.0f];
        
        self.colorLayer.position = point;
        
        [CATransaction commit];
    }
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/8.gif" alt="8"/></p>

<hr/>

<h3 id="toc_6">总结</h3>

<blockquote>
<p>总结一下:</p>

<ul>
<li><strong>Core Animation</strong>默认是打开动画效果的, 并且默认的动画效果是平滑过渡滴.</li>
<li>我们知道了隐式动画的实现方式.</li>
<li><strong>UIView</strong>关联的图层默认都禁用了隐式动画, 对这种图层做动画的唯一办法就是使用<strong>UIView</strong>的动画函数, 或者是继承与<strong>UIView</strong>并且重写<strong>- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;</strong>方法, 最直接的方法就是直接创建一个显示动画.</li>
<li>对于一个单独存在的图层来讲, 我们可以通过实现图层的<strong>- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;</strong>方法, 或者是提供一个<strong>Actions</strong>的字典来控制隐式动画.</li>
<li>除此之外, 我们来了解了<strong>呈现图层</strong>和<strong>模型图层</strong>, 知道了这两个家伙的一些皮毛.
<dr/>
好了, 这次就到这里了, 谢谢大家~</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_7">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_8">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：6.《Core Animation》CALayer的Specialized Layers]]></title>
    <link href="https://cainrun.github.io/14790557329421.html"/>
    <updated>2016-11-14T00:48:52+08:00</updated>
    <id>https://cainrun.github.io/14790557329421.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在上一篇文章<a href="https://cainrun.github.io/14777052484078.html">《Core Animation》CALayer的Transforms</a>中, 我们了解了二维空间和三维空间的一些布局, 还有就是最简单的旋转, 平移之类的, 再来一些就是混合使用的, 这次我们来换个话题.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>Specialized Layers</strong>讲得是一些专用的一些图层类, 而不是之前所说的一些用于图片, 颜色之类的, 下面让我们来看看吧~</p>
</blockquote>

<hr/>

<h3 id="toc_2">CAShapeLayer</h3>

<blockquote>
<p>在之前的文章里, 我们使用过阴影效果, 并且是不使用<strong>CGPath</strong>情况下去构建形状不同的阴影, 在<strong>CALayer</strong>中, 有一个子类叫做<strong>CAShapeLayer</strong>, 它也是可以做到对应的效果.<br/>
<dr/><br/>
<strong>CAShapeLayer</strong>是一个通过矢量图形来进行绘制的图层子类, 而并不是使用<strong>Bitmap</strong>, 当我们指定对应的颜色, 线宽等属性, 就可以使用<strong>CGPath</strong>来绘制我们想要的形状, 最后<strong>CAShapeLayer</strong>就自动渲染出来了, 当然你也可以使用<strong>Core Graphics</strong>直接对一个<strong>CALayer</strong>进行绘制, 但<strong>CAShapeLayer</strong>要比<strong>Core Graphics</strong>直接操作<strong>CALayer</strong>要好一些, 比如:</p>

<ul>
<li><strong>CAShapeLayer</strong>使用了硬件加速, 绘制同一图形时会比<strong>Core Graphics</strong>渲染的快.</li>
<li><strong>CAShapeLayer</strong>不需要像普通<strong>CALayer</strong>一样创建一个寄宿图形, 所以无论有多大, 都不会占用太多的内存.</li>
<li><strong>CAShapeLayer</strong>和<strong>Core Graphics</strong>不一样, 它并不会被图层边界给裁剪掉.</li>
<li><strong>CAShapeLayer</strong>不会出现像素化, 这可以提现在, 用<strong>CAShapeLayer</strong>做3D变换的时候, 不会和普通的图层一样出现像素化.</li>
</ul>
</blockquote>

<h4 id="toc_3">创建一个CGPath</h4>

<blockquote>
<p>刚刚说了, <strong>CAShapeLayer</strong>可以通过<strong>CGPath</strong>来绘制任意图形, 并且可以设置一些属性, 比如<strong>lineWith</strong>, <strong>lineCap</strong>, <strong>lineJoin</strong>.<br/>
<dr/><br/>
我们绘制这个图形的时候, 不一定要闭合, 图层路径也不是绝对, 可以在一个图层上绘制多个不同的图形, 当然, 如果你要想用不同的颜色风格来绘制N个图形, 那你就要准备好多个<strong>Layer</strong>了.<br/>
<dr/><br/>
<strong>CAShapeLayer</strong>是属于<strong>CGPathRef</strong>类型, 但在实际开发中, 我们是用<strong>UIBezierPath</strong>来创建图层路径的, 这样子我们就不用考虑人工释放<strong>CGPath</strong>了, 下面让我们来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)createPath {
    
    UIBezierPath *path = [[UIBezierPath alloc] init];
    
    [path moveToPoint:CGPointMake(175, 100)];
    [path addQuadCurveToPoint:CGPointMake(100, 500)
                 controlPoint:CGPointMake(250, 600)];
    
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.strokeColor = [UIColor blueColor].CGColor;
    shapeLayer.fillColor = [UIColor clearColor].CGColor;
    shapeLayer.lineWidth = 10;
    shapeLayer.lineJoin = kCALineJoinRound;
    shapeLayer.lineCap = kCALineCapRound;
    shapeLayer.path = path.CGPath;
    
    [self.view.layer addSublayer:shapeLayer];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/1.png" alt="1"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/2.png" alt="2"/></p>

<h4 id="toc_4">圆角</h4>

<blockquote>
<p>之前我们在之前的文章里, 有提到过把一个视图剪切成圆角, 用的就是<strong>CALayer</strong>的<strong>cornerRadius</strong>属性, 而<strong>CAShapeLayer</strong>类也可以提供同样的功能, 虽然代码多了一些, 但也多了一些灵活, 它可以指定单独的指定每个角.<br/>
<dr/><br/>
我们创建圆角矩形其实就是人工绘制单独的直线和弧度, 但在<strong>UIBezierPath</strong>中有提供自动绘制圆角矩形的方法, 直接看代码:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewRoundedCorners {
    
    CGRect rect = CGRectMake(130, 130, 100, 100);
    CGSize radii = CGSizeMake(10, 10);
    
    UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft | UIRectCornerTopLeft;
    
    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect
                                               byRoundingCorners:corners
                                                     cornerRadii:radii];
    
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    
    shapeLayer.path = path.CGPath;
    
    [self.view.layer addSublayer:shapeLayer];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/3.png" alt="3"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_5">CATextLayer</h3>

<blockquote>
<p>如果我们想在一个图层里显示文字, 我们可以借助和<strong>UILabel</strong>一样的方式, 使用<strong>Core Graphics</strong>在图层上写入内容, 但如果要越过<strong>UILabel</strong>这些控件, 直接在图层上显示文字的话, 我们就要为每个显示文字的图层创建一个图层代理的类, 并且判断哪个图层需要显示哪个字符串, 如果再加一些字体, 颜色一些乱七八糟的东西, 那就蛋疼的不要不要的.<br/>
<dr/><br/>
好在<strong>CALayer</strong>里有一个子类, 叫做<strong>CATextLayer</strong>, 它几乎都包含了<strong>UILabel</strong>的所有绘制特性, 而且还额外提供了一些新特性, 并且在渲染的速度上, 要比<strong>UILabel</strong>快的多, 偷偷说个事, 在<strong>iOS 6</strong>之前, <strong>UILabel</strong>其实是通过<strong>WebKit</strong>来实现绘制的, 所以那时候<strong>iOS</strong>在渲染文字的时候会有非常大的性能问题, 但<strong>CATextLayer</strong>使用的是<strong>Core Text</strong>, 两者之前完全不同一个概念.<br/>
<dr/><br/>
说那么多废话, 直接上代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)catextLayer {
    
    UIView *labelView = [[UIView alloc] initWithFrame:CGRectMake(30, 100, 300, 300)];
    
    labelView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:labelView];
    
    CATextLayer *textLayer = [CATextLayer layer];
    textLayer.frame = labelView.bounds;
    
    [labelView.layer addSublayer:textLayer];
    
    textLayer.foregroundColor = [UIColor blackColor].CGColor;
    textLayer.alignmentMode = kCAAlignmentJustified;
    textLayer.wrapped = YES;
    
    UIFont *font = [UIFont systemFontOfSize:15];
    
    CFStringRef fontName = (__bridge CFStringRef)font.fontName;
    CGFontRef fontRef = CGFontCreateWithFontName(fontName);
    
    textLayer.font = fontRef;
    textLayer.fontSize = font.pointSize;
    
    CGFontRelease(fontRef);
    
    NSString *text = @&quot;这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字&quot;;
    
    textLayer.string = text;
}
</code></pre>

<blockquote>
<p>这里还要多说一句, 如果你发现文本显示的时候出现像素化的时候, 只要加上以下这段代码, 就哦了, 它会以<strong>Retina</strong>模式来渲染:</p>
</blockquote>

<pre><code class="language-objectivec">    textLayer.contentsScale = [UIScreen mainScreen].scale;
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/5.png" alt="5"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/6.png" alt="6"/></p>

<blockquote>
<p><strong>contentsScale</strong>并且并不关心屏幕的拉伸, 因为默认都是<strong>1.0f</strong>, 所以我们要高清, 那就设置它吧.<br/>
<dr/><br/>
<strong>CATextLayer</strong>里的<strong>font</strong>属性, 其实并不是一个真正的<strong>UIFont</strong>类型, 而是一个<strong>CFTypeRef</strong>类型, 这样子就可以根据我们的需求来决定字体的属性到底是用<strong>CGFontRef</strong>类型还是用<strong>Core Text</strong>里的<strong>CTFontRef</strong>类型了, 同时字体大小也是用<strong>fontSize</strong>属性单独设置的, 因为<strong>CTFontRef</strong>和<strong>CGFontRef</strong>和<strong>UIFont</strong>完全是两回事, 在代码中我们也知道了如何将<strong>UIFont</strong>转成<strong>CGFontRef</strong>.<br/>
<dr/><br/>
当然<strong>CATextLayer</strong>里的<strong>string</strong>属性是<strong>id</strong>类型, 并不是我们想象中的<strong>NSString</strong>类型, 因为这样子我们就可以用<strong>NSString</strong>也可以用<strong>NSAttributedString</strong>来指定要显示的文本, 比如指定某段文字的字体, 颜色, 字重, 斜体等等.</p>
</blockquote>

<h4 id="toc_6">Rich Text</h4>

<blockquote>
<p>其实在<strong>iOS 6</strong>的时候, <strong>Apple</strong>就已经给了<strong>UILabel</strong>和其他的<strong>UIKit</strong>文本视图添加直接的属性, 但事实上, 在<strong>iOS 3.2</strong>的时候, <strong>CATextLayer</strong>就已经支持属性化字符串了, 如果你想支持更低版本的<strong>iOS</strong>那么你可以使用<strong>CATextLayer</strong>, 不需要和更复杂的<strong>Core Text</strong>打交道, 也省略了使用其他的方法, 但现在又会有哪家公司支持低版本的<strong>iOS</strong>呢? 但不能够说在新版本的<strong>iOS</strong>D昂中<strong>CATextLayer</strong>就无用功了, 这个得看我们的需求来确定了.<br/>
<dr/> <br/>
这次我们把<strong>Core Text</strong>, <strong>CATextLayer</strong>, <strong>NSAttributedString</strong>三者混在一起使用一下~</p>
</blockquote>

<pre><code class="language-objectivec">- (void)attributedString {
    
    UIView *labelView = [[UIView alloc] initWithFrame:CGRectMake(0, 200, self.view.frame.size.width, 400)];
    
    [self.view addSubview:labelView];
    
    CATextLayer *textLayer = [CATextLayer layer];
    
    textLayer.frame = labelView.bounds;
    textLayer.contentsScale = [UIScreen mainScreen].scale;
    
    [labelView.layer addSublayer:textLayer];
    
    textLayer.alignmentMode = kCAAlignmentJustified; textLayer.wrapped = YES;
    
    UIFont *font = [UIFont systemFontOfSize:15];

    NSString *text = @&quot;这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字&quot;;
    
    NSMutableAttributedString *string = nil;
    string = [[NSMutableAttributedString alloc] initWithString:text];
    
    CFStringRef fontName = (__bridge CFStringRef)font.fontName; CGFloat fontSize = font.pointSize;
    CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);
    
    NSDictionary *attribs = @{(__bridge id)kCTForegroundColorAttributeName : (__bridge id)[UIColor blackColor].CGColor,
                              (__bridge id)kCTFontAttributeName: (__bridge id)fontRef};
    
    [string setAttributes:attribs range:NSMakeRange(0, [text length])];
    
    attribs = @{(__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,
                (__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),
                (__bridge id)kCTFontAttributeName: (__bridge id)fontRef};
    
    [string setAttributes:attribs range:NSMakeRange(6, 20)];
    
    CFRelease(fontRef);
    
    textLayer.string = string;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/7.png" alt="7"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/8.png" alt="8"/></p>

<h4 id="toc_7">Leading and Kerning</h4>

<blockquote>
<p>这里有个点, 由于<strong>Core Text</strong>和<strong>WebKit</strong>的内部实现机制不同, 用<strong>CATextLayer</strong>渲染或者是用<strong>UILabel</strong>渲染文本行距和字距也是不一样的, 这个是由使用字体和字符来决定的, 所以大家如果要使用普通的<strong>UILabel</strong>和<strong>CATextLayer</strong>, 就要好好注意一下了.</p>
</blockquote>

<h4 id="toc_8">A UILabel Replacement</h4>

<blockquote>
<p>这次我们就自己创建一个属于我们自己的<strong>UILabel</strong>, 代替系统的<strong>UILabel</strong>, 虽然这个类也是继承于<strong>UILabel</strong>, 但比系统的<strong>UILabel</strong>的<strong>-drawRect:</strong>方法要快, 来看看代码吧~</p>
</blockquote>

<pre><code class="language-objectivec">#import &quot;CLLabel.h&quot;
#import &lt;QuartzCore/QuartzCore.h&gt;

@implementation CLLabel

+ (Class)layerClass {
    
    return [CATextLayer class];
}

- (CATextLayer *)textLayer {
    
    return (CATextLayer *)self.layer;
}

- (void)setUp {
    
    self.text = self.text;
    self.textColor = self.textColor;
    self.font = self.font;
    
    [self textLayer].wrapped = YES;
    [self.layer display];
}

- (id)initWithFrame:(CGRect)frame {
    
    if (self = [super initWithFrame:frame]) {
        
        [self setUp];
    }
    
    return self;
}

- (void)awakeFromNib {
    
    [self setUp];
}

- (void)setText:(NSString *)text {
    super.text = text;
    
    [self textLayer].string = text;
}

- (void)setTextColor:(UIColor *)textColor {
    super.textColor = textColor;
    
    [self textLayer].foregroundColor = textColor.CGColor;
}

- (void)setFont:(UIFont *)font {
    super.font = font;
    
    CFStringRef fontName = (__bridge CFStringRef)font.fontName;
    CGFontRef fontRef = CGFontCreateWithFontName(fontName);
    
    [self textLayer].font = fontRef;
    [self textLayer].fontSize = font.pointSize;
    
    CGFontRelease(fontRef);
}

@end
</code></pre>

<blockquote>
<p>使用这个自定义的<strong>CLLabel</strong>, 我们看看效果</p>
</blockquote>

<pre><code class="language-objectivec">- (void)createCLLabel {
    
    CLLabel *label = [[CLLabel alloc] initWithFrame:CGRectMake(20, 50, 200, 200)];
    
    label.text = @&quot;这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的测试文字&quot;;
    label.textColor = [UIColor blackColor];
    
    [self.view addSubview:label];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/9.png" alt="9"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/10.png" alt="10"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/11.png" alt="11"/></p>

<hr/>

<h3 id="toc_9">CATransformLayer</h3>

<blockquote>
<p>在我们日常开发当中, 如果需要用到<strong>3D Layer</strong>, 可以用到之前我们说到的<strong>3D Transforms</strong>, 但是那样子太麻烦了, 要算一堆东西, 如果有一种<strong>Layer</strong>可以像玩积木一样, 一个一个的组合成一个<strong>3D</strong>形状的话, 那该多好~<br/>
<dr/><br/>
其实<strong>Apple</strong>早就想到了这个问题, 它们提供了<strong>CATransformLayer</strong>, 就是专门用来给<strong>Layer</strong>做一个容器, 然后让拼接成一个看起来像<strong>3D</strong>的一样图形.<br/>
<dr/><br/>
我们来看代码: </p>
</blockquote>

<pre><code class="language-objectivec">- (void)transformLayer {
    
    self.view.backgroundColor = [UIColor grayColor];
    
    CATransform3D transform3DOne = CATransform3DIdentity;
    
    transform3DOne.m34 = -1.0 / 500.0;
    
    self.view.layer.sublayerTransform = transform3DOne;
    
    CATransform3D transform3DTwo = CATransform3DIdentity;
    
    transform3DTwo = CATransform3DTranslate(transform3DTwo, -100, 0, 0);
    
    CALayer *cubeOne = [self cubeWithTransform:transform3DTwo];
    
    [self.view.layer addSublayer:cubeOne];
    
    CATransform3D transform3DThree = CATransform3DIdentity;
    
    transform3DThree = CATransform3DTranslate(transform3DThree, 100, 0, 0);
    transform3DThree = CATransform3DRotate(transform3DThree, -M_PI_4, 1, 0, 0);
    transform3DThree = CATransform3DRotate(transform3DThree, -M_PI_4, 0, 1, 0);
    
    CALayer *cubeTwo = [self cubeWithTransform:transform3DThree];
    
    [self.view.layer addSublayer:cubeTwo];
}

- (CALayer *)layerWithTransform:(CATransform3D)transform {
    
    CALayer *layer = [CALayer layer];
    
    layer.frame = CGRectMake(-50, -50, 100, 100);
    
    CGFloat red = (rand() / (double)INT_MAX);
    CGFloat green = (100000 / (double)INT_MAX);
    CGFloat blue = (rand() / (double)INT_MAX);
    
    layer.backgroundColor = [UIColor colorWithRed:red
                                            green:green
                                             blue:blue
                                            alpha:1.0f].CGColor;
    layer.transform = transform;
    
    return layer;
}

- (CALayer *)cubeWithTransform:(CATransform3D)transform {
    
    // cube
    CATransformLayer *cube = [CATransformLayer layer];
    
    // layer one
    CATransform3D transform3D = CATransform3DMakeTranslation(0, 0, 50);
    [cube addSublayer:[self layerWithTransform:transform3D]];
    
    // layer two
    transform3D = CATransform3DMakeTranslation(50, 0, 0);
    transform3D = CATransform3DRotate(transform3D, M_PI_2, 0, 1, 0);
    [cube addSublayer:[self layerWithTransform:transform3D]];
    
    // layer three
    transform3D = CATransform3DMakeTranslation(0, -50, 0);
    transform3D = CATransform3DRotate(transform3D, M_PI_2, 1, 0, 0);
    [cube addSublayer:[self layerWithTransform:transform3D]];

    // layer five
    transform3D = CATransform3DMakeTranslation(-50, 0, 0);
    transform3D = CATransform3DRotate(transform3D, -M_PI_2, 0, 1, 0);
    [cube addSublayer:[self layerWithTransform:transform3D]];

    // layer six
    transform3D = CATransform3DMakeTranslation(0, 0, -50);
    transform3D = CATransform3DRotate(transform3D, M_PI, 0, 1, 0);
    [cube addSublayer:[self layerWithTransform:transform3D]];

    CGSize containerSize = self.view.bounds.size;
    
    cube.position = CGPointMake(containerSize.width / 2.0,
                                containerSize.height / 2.0);
    
    cube.transform = transform;
    
    return cube;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/12.png" alt="12"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/13.png" alt="13"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/14.png" alt="14"/></p>

<hr/>

<h3 id="toc_10">CAGradientLayer</h3>

<blockquote>
<p>在<strong>Layer</strong>中, 有一种颜色平滑渐变的子类, 叫做<strong>CAGradientLayer</strong>, 虽然用<strong>Core Graphics</strong>也可以通过一些技巧做到和<strong>CAGradientLayer</strong>一样的效果, 但<strong>CAGradieLayer</strong>真正好, 是好在它是用硬件加速来绘制的, 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)gradientLayer {
    
    UIView *view = [[UIView alloc] init];
    
    view.bounds = CGRectMake(0, 0, 200, 200);
    view.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);
    
    CAGradientLayer *gradientLayer = [CAGradientLayer layer];
    gradientLayer.frame = view.bounds;
    
    // 设置渐变的颜色, 理论上来讲是无限添加的
    gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor,
                             (__bridge id)[UIColor greenColor].CGColor];
    
    gradientLayer.startPoint = CGPointMake(0, 0); // 开始渐变的点
    gradientLayer.endPoint = CGPointMake(1, 1); // 结束渐变的点
    
    gradientLayer.locations = @[@0.0, @0.2]; // 设置渐变的区域
    
    [view.layer addSublayer:gradientLayer];
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/15.png" alt="15"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/16.png" alt="16"/></p>

<hr/>

<h3 id="toc_11">CAReplicatorLayer</h3>

<blockquote>
<p>在<strong>CALayer</strong>的子类当中还有一个叫做<strong>CAReplicatorLayer</strong>, 它是用来复制重复的图层, 并且, 你可以给这些复制的图层进行一些属性上的操作, 比如渐变色, 渐变透明, 形状, 还可以加动画效果, 来看看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">#pragma mark - CAReplicatorLayer
- (void)replicatorLayer {
    
    UIView *view = [[UIView alloc] init];
    
    view.bounds = CGRectMake(0, 0, 100, 100);
    view.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 4.5);
    
    CATransform3D transform = CATransform3DIdentity;
    
    transform = CATransform3DTranslate(transform, 0, 200, 0);
    transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
    transform = CATransform3DTranslate(transform, 0, -200, 0);

    CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];
    
    replicatorLayer.frame = view.bounds;
    replicatorLayer.instanceCount = 10;  // 复制图层个数
    replicatorLayer.instanceBlueOffset = -1.0f; // 设置每一个图层的逐渐蓝色偏移
    replicatorLayer.instanceRedOffset = -1.0f;  // 设置每一个图层的逐渐红色偏移
    replicatorLayer.instanceAlphaOffset = -0.1f;
    replicatorLayer.instanceDelay = 0.33f;  // 设置每个图层延迟0.33f
    replicatorLayer.instanceTransform = transform;
    
    CALayer *layer = [CALayer layer];
    
    layer.frame = CGRectMake(0, 0, 100, 100);
    layer.backgroundColor = [UIColor whiteColor].CGColor;
    
    [replicatorLayer addSublayer:layer];
    
    self.view.backgroundColor = [UIColor grayColor];
    
    [view.layer addSublayer:replicatorLayer];
    
    [self addLayerAnimation:layer];
    
    [self.view addSubview:view];
}

- (void)addLayerAnimation:(CALayer *)layer {
    
    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;position.y&quot;];
    
    animation.toValue =  @(layer.position.y - 25.0);
    animation.duration = 0.5;
    animation.autoreverses = true;
    animation.repeatCount = CGFLOAT_MAX;
    
    [layer addAnimation:animation forKey:nil];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/17.png" alt="17"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/18.gif" alt="18"/></p>

<h4 id="toc_12">Reflections</h4>

<blockquote>
<p><strong>CAReplicatorLayer</strong>其实还有一个更加实用的功能, 就是做一个镜面反射的效果, 我们可以自己封装一个<strong>UIView</strong>的类, 也可以自己写一个简单的, 这里我就写个简单点的吧, 大家也可以去<strong>GitHub</strong>里面搜搜, 我在网上搜到一个, 虽然这个库已经2年多没更新了, 但还是值得看看的<a href="https://github.com/nicklockwood/ReflectionView">ReflectionView</a>.</p>
</blockquote>

<pre><code class="language-objectivec">- (void)reflectionsLayer {
    
    CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];
    
    replicatorLayer.instanceCount = 2;
    replicatorLayer.frame = CGRectMake(50, 100, 100, 100);

    CALayer *layer = [CALayer layer];
    
    layer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;github&quot;].CGImage);
    layer.frame = replicatorLayer.bounds;

    CATransform3D transform = CATransform3DIdentity;
    
    transform = CATransform3DTranslate(transform, 0, layer.bounds.size.height, 0);
    transform = CATransform3DScale(transform, 1, -1, 0);
    
    replicatorLayer.instanceTransform = transform;
    replicatorLayer.instanceAlphaOffset = -0.6;
    
    [replicatorLayer addSublayer:layer];
    
    [self.view.layer addSublayer:replicatorLayer];
    self.view.backgroundColor = [UIColor grayColor];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/19.png" alt="19"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/20.png" alt="20"/></p>

<hr/>

<h3 id="toc_13">CAScrollLayer</h3>

<blockquote>
<p>在<strong>CALayer</strong>的子类当中, 还有一个<strong>CAScrollLayer</strong>, 它可以被称为<strong>UIScrollView</strong>的代替品, 但有一个问题, 我们都知道<strong>Core Animation</strong>是不能处理用户输入, 所以<strong>CAScrollLayer</strong>也不能处理滑动事件, 也不能实现<strong>UIScrollView</strong>那种滑动反弹效果, 但这里加了一个滑动手势就可以实现了滑动效果了.</p>
</blockquote>

<pre><code class="language-objectivec">@interface ViewController ()

@property (nonatomic, strong) CAScrollLayer *scrollLayer;

@end

#pragma mark - CAScrollLayer
- (void)addScrollLayer {
    
    CALayer *layer = [CALayer layer];
    
    layer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;github&quot;].CGImage);
    layer.frame = CGRectMake(0, 0, 300, 300);
    
    self.scrollLayer = [CAScrollLayer layer];
    self.scrollLayer.frame = CGRectMake(50, 100, 150, 150);
    self.scrollLayer.scrollMode = kCAScrollBoth;
    self.scrollLayer.backgroundColor = [UIColor grayColor].CGColor;
    
    [self.scrollLayer addSublayer:layer];
    
    [self.view.layer addSublayer:self.scrollLayer];
    
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGesture:)];
    
    [self.view addGestureRecognizer:pan];
}

- (void)panGesture:(UIPanGestureRecognizer *)pan {
    
    CGPoint translocation = [pan translationInView:self.view];
    CGPoint origin = self.scrollLayer.bounds.origin;
    
    origin = CGPointMake(origin.x - translocation.x, origin.y - translocation.y);
    
    [self.scrollLayer scrollToPoint:origin];
    
    [pan setTranslation:CGPointZero inView:self.view];
}
</code></pre>

<hr/>

<h3 id="toc_14">CATiledLayer</h3>

<blockquote>
<p>在我们开发当中, 有时候我们会需要加载一张超大的图片, 比如神马4K高清图, 或者是世界地图等等之类的, 但是在<strong>iOS</strong>当中是有内存限制的, 并不像其他系统一样<strong>4G</strong>, <strong>6G</strong>有超大内存, 如果我们要把超大的图片加载到内存当中, 那很明显, 直接会撑爆, 或者是加速速度慢得感人, 如果你是在主线程中使用<strong>UIImage</strong>的<strong>+ (nullable UIImage *)imageNamed:(NSString *)name;</strong>或者是<strong>- (nullable instancetype)initWithContentsOfFile:(NSString *)path</strong>方法来加载图片的话, 那你会惊喜的发现, 卡线程了~~<br/>
<dr/><br/>
在<strong>iOS</strong>当中, 能够高效的绘制并且加载到界面的图片是有一个大小限制的, 因为在<strong>iOS</strong>当中所有显示在屏幕上的图片最终都会被转化为<strong>OpenGL</strong>的纹理, 同时<strong>OpenGL</strong>是有一个最大纹理尺寸的限制, 根据设备的型号来决定, 通常是<strong>2048*2048</strong>或者<strong>4096*4096</strong>, 如果我们想在单个纹理中显示一个比这个限制尺寸还要大的图, 哪怕图片已经存在于内存当中, 我们也会遇到非常大的性能问题, 因为<strong>Core Animation</strong>是强制用<strong>CPU</strong>处理图片, 而不是<strong>GPU</strong>, 苹果为了解决这个问题, 于是乎有了<strong>CATiledLayer</strong>, 下面我们来看看<strong>Demo</strong>:<br/>
<dr/><br/>
由于我不懂怎么把大图分解成小图, 这里就找张小一点的图用用</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addCATileLayer {
    
    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, self.view.frame.size.width)];
    
    [self.view addSubview:scrollView];
    
    CATiledLayer *tiledLayer = [CATiledLayer layer];
    
    tiledLayer.frame = CGRectMake(0, 0, 2048, 2048);
    tiledLayer.delegate = self;
    tiledLayer.contentsScale = [UIScreen mainScreen].scale;
    
    [scrollView.layer addSublayer:tiledLayer];
    
    scrollView.contentSize = tiledLayer.frame.size;
    
    [tiledLayer setNeedsDisplay];
}

- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx {
    
    CGRect bounds = CGContextGetClipBoundingBox(ctx);
    
    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);
    
    NSString *imageName = [NSString stringWithFormat:@&quot;image%02zd_%02zd&quot;, x, y];
    
    UIImage *tileImage = [UIImage imageNamed:imageName];
    
    UIGraphicsPushContext(ctx);
    
    [tileImage drawInRect:bounds];
    
    UIGraphicsPopContext();
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/21.gif" alt="21"/></p>

<blockquote>
<p>这里我们注意到, 我默认是用<strong>Retina</strong>模式去显示图片的, 所以我们看起来这些图片会比较小, 如果你不想用<strong>Retina</strong>模式去显示, 你可以把代码中的一句代码删除即可:</p>
</blockquote>

<pre><code class="language-objectivec">    tiledLayer.contentsScale = [UIScreen mainScreen].scale;
</code></pre>

<blockquote>
<p>如果我们要做到像地图那样子放大缩小的话, 那就要自己头脑风暴一下, 然后想着如何去实现了~~</p>
</blockquote>

<hr/>

<h3 id="toc_15">CAEmitterLayer</h3>

<blockquote>
<p>在<strong>iOS 5</strong>版本中, 苹果加入了一个新的<strong>CALayer</strong>子类, 叫做<strong>CAEmitterLayer</strong>, 它是一个高性能的粒子引擎, 常用于制作实时效果的动画, 比如烟雾, 火, 雨等等之类的.<br/>
<dr/><br/>
其实仔细想想, <strong>CAEmitterLayer</strong>看起来更像是一个容器, 里面装载着很多的<strong>CAEmitterCell</strong>, 这些<strong>CAEmitterCell</strong>定义了一个粒子效果, 然后在<strong>CAEmitterLayer</strong>的装载中显示出来.<br/>
<dr/><br/>
<strong>CAEmitterCell</strong>类似于一个普通的<strong>CALayer</strong>, 它有一个<strong>contents</strong>的属性, 可以定义为一个<strong>CGImage</strong>, 但不同于普通的<strong>CALayer</strong>的是它有一些课设置属性控制着表现和行为, 想了解更多的话, 大家可以自行去<strong>CAEmitterCell</strong>的头文件找找, 现在我们来看看<strong>Demo</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addCAEmitterLayer {
    
    UIView *contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 100,
                                                                   self.view.frame.size.width,
                                                                   self.view.frame.size.width)];
    
    [self.view addSubview:contentView];
    
    CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];
    
    emitterLayer.frame = contentView.bounds;
    emitterLayer.renderMode = kCAEmitterLayerAdditive;
    emitterLayer.emitterPosition = CGPointMake(emitterLayer.frame.size.width / 2,
                                               emitterLayer.frame.size.height / 2);
    
    [contentView.layer addSublayer:emitterLayer];
    
    CAEmitterCell *cell = [[CAEmitterCell alloc] init];
    
    cell.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;fire&quot;].CGImage);
    cell.birthRate = 150;
    cell.lifetime = 5.0;
    cell.color = [UIColor colorWithRed:1.f
                                 green:0.5f
                                  blue:0.1f
                                 alpha:1.0f].CGColor;
    cell.alphaSpeed = -0.4f;
    cell.velocity = 50.f;
    cell.velocityRange = 50.f;
    cell.emissionRange = M_PI * 2.0f;
    
    emitterLayer.emitterCells = @[cell];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/22.gif" alt="22"/></p>

<blockquote>
<p>这里补充一下知识点, <strong>CAEMitterCell</strong>基本上可以分为三种:</p>

<ul>
<li>粒子的某一属性的初始值, 比如:<strong>color</strong>属性指定了一个图片的混合色, 在<strong>Demo</strong>当中我们就设置了某个颜色.</li>
<li>粒子某一属性的变化范围, 比如:<strong>emissionRange</strong>, 在<strong>Demo</strong>当中, 我们设置为<strong>M_PI * 2.0f</strong>, 这意味着粒子可以从<strong>360°</strong>的任意位置反射出来.</li>
<li><p>粒子在指定值的时间线上的变化, 比如: <strong>alphaSpeed</strong>, 子啊<strong>Demo</strong>中, 我们设置为<strong>-0.4f</strong>, 这意味着, 每过一秒, 粒子的透明度就减少<strong>0.4</strong>, 这样子就有渐渐消失的效果啦.<br/>
<dr/><br/>
而<strong>CAEmitterLayer</strong>它是控制着整个粒子系统的位置和形状, 比如<strong>birthRate</strong>, <strong>lifetime</strong>和<strong>celocity</strong>, 当然, <strong>CAEMitterCell</strong>也有这些属性, 整个粒子系统都是这些属性以相乘的方式作用在一起, 这样子我们就可以用一个值来加速或者扩大整个粒子系统.<br/>
<dr/><br/>
我们还需要知道另外两个比较重要的属性:</p></li>
<li><p><strong>preservesDepth</strong>: 是否将一个<strong>3D</strong>的粒子系统平面化到一个图层, 或者可以在<strong>3D</strong>空间中混合其他图层.</p></li>
<li><p><strong>renderMode</strong>: 控制着粒子图片在视觉上是如何混合的, 在<strong>Demo</strong>当中, 我们设置为<strong>kCAEmitterLayerAdditive</strong>效果, 默认值为<strong>kCAEmitterLayerUnordered</strong>, 在开发当中需要什么样的效果, 还是得根据需求的来~</p></li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_16">CAEAGLLayer</h3>

<blockquote>
<p>在<strong>iOS</strong>当中, 如果我们需要高性能的图形绘制, 那肯定是少不了去了解<strong>OpenGL</strong>, 这里说的是非游戏类的应用哈, 毕竟游戏有属于自己的一套渲染库, 说起<strong>OpenGL</strong>, 肯定有很多人觉得这个框架很厉害, 的确是的, 因为<strong>OpenGL</strong>是用<strong>C</strong>来写的, 直接和硬件进行通信, 但是呢, 也因为是用<strong>C</strong>所写的, 几乎有没有抽象出来的接口, 如果你要直接使用<strong>OpenGL</strong>来把图形显示在屏幕上, 那你就需要写非常多的复杂代码, 虽然<strong>OpenGL</strong>是非常强大的神器, 因为<strong>OpenGL</strong>是<strong>Core Animation</strong>和<strong>UIKit</strong>的基础.<br/>
<dr/><br/>
在<strong>OpenGL</strong>中, 是没有对象和图层继承的概念, 它只是非常简单的去处理三角形, 在<strong>OpenGL</strong>中, 所有东西都是<strong>3D</strong>空间中有颜色和纹理的三角形, 感觉灰常的牛逼~<br/>
<dr/><br/>
如果我们要高效的时候<strong>Core Animation</strong>, 那么我们就需要判断我们需要绘制哪些内容, 比如(矢量图形, 粒子, 文本等等), 但即使是我们选择了合适的图层去呈现这些内容, <strong>Core Animation</strong>中也不是每个类型的内容都被高度优化过, 所以要想得到高性能的去绘制, 那就比较蛋疼了.<br/>
<dr/><br/>
在<strong>iOS 5</strong>中, 苹果为了解决这些蛋疼的问题, 加入了一个叫做<strong>GLKit</strong>的库, 它在一定层度上减少了使用<strong>OpenGL</strong>的复杂度, 提供了一个叫做<strong>GLKView</strong>的<strong>UIView</strong>子类, 帮我们处理大部分的设置内容和绘制工作, 有需要了解<strong>GLKit</strong>的朋友们可以去翻翻官方文档.<br/>
<dr/><br/>
即使是如此, 我们还是需要使用到一个叫做<strong>CAEAGLLayer</strong>的<strong>CALayer</strong>子类, 酱紫我们才可以用来显示<strong>OpenGL</strong>的图形.<br/>
<dr/><br/>
这里还需要提到一点, 虽然在大部分情况下, 我们不需要手动设置<strong>CAEAGLLayer</strong>(如果是用<strong>GLKView</strong>的话), 我们可以设置一个<strong>OpenGL ES 2.0</strong>的上下文, 这是大多数的用法, <strong>GLKit</strong>为我们提供许多便捷的方法, 比如设置顶点和片段的着色器之类的, 这些都是以类<strong>C</strong>语言叫做<strong>GLSL</strong>自包含在程序中, 同事在运行时载入到图形硬件中, 当然, <strong>GLSL</strong>的代码和设置<strong>CAEAGLLayer</strong>是一毛钱关系都没, 所以我们会用<strong>GLKBaseEffect</strong>类, 将着色的逻辑抽象出来就完事, 其他的事情, 还是和平常使用一样就哦了, 下面让我们来看看<strong>Demo</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addCAEAGLLayer {
    
    UIView *glView = [[UIView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, self.view.frame.size.width)];
    
    [self.view addSubview:glView];
    
    // 设置Context
    self.glContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
    
    [EAGLContext setCurrentContext:self.glContext];
    
    // 设置显示的Layer
    self.glLayer = [CAEAGLLayer layer];
    self.glLayer.frame = glView.bounds;
    [glView.layer addSublayer:self.glLayer];
    self.glLayer.drawableProperties = @{kEAGLDrawablePropertyRetainedBacking : @NO,
                                        kEAGLDrawablePropertyColorFormat : kEAGLColorFormatRGBA8};
    
    self.effect = [[GLKBaseEffect alloc] init];
    
    [self setUpBuffers];
    [self drawFrame];
}

- (void)setUpBuffers {
    
    // 设置Frame
    glGenFramebuffers(1, &amp;_framebuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);
    
    // 设置颜色
    glGenRenderbuffers(1, &amp;_colorRenderbuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                              GL_RENDERBUFFER, _colorRenderbuffer);
    
    [self.glContext renderbufferStorage:GL_RENDERBUFFER
                           fromDrawable:self.glLayer];
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH,
                                 &amp;_framebufferWidth);
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT,
                                 &amp;_framebufferHeight);
    
    // 检查是否成功
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        
        NSLog(@&quot;%i&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER));
    }
}

- (void)tearDownBuffers {
    
    if (_framebuffer) {
        
        glDeleteFramebuffers(1, &amp;_framebuffer);
        _framebuffer = 0;
    }
    
    if (_colorRenderbuffer) {
        
        glDeleteRenderbuffers(1, &amp;_colorRenderbuffer);
        _colorRenderbuffer = 0;
    }
}

- (void)drawFrame {
    
    // 绑定缓冲区
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);
    glViewport(0, 0, _framebufferWidth, _framebufferHeight);
    
    [self.effect prepareToDraw];
    
    // 清空屏幕
    glClear(GL_COLOR_BUFFER_BIT);
    glClearColor(0.0, 0.0, 0.0, 1.0);
    
    // 设置顶点
    GLfloat vertices[] = {
        -0.5f, -0.5f, -1.0f,
        0.0f, 0.5f, -1.0f,
        0.5f, -0.5f, -1.0f};
    
    // 设置颜色值
    GLfloat colors[] = {
        0.0f, 0.0f, 1.0f, 1.0f,
        0.0f, 1.0f, 0.0f, 1.0f,
        1.0f, 0.0f, 0.0f, 1.0f};
    
    // 开始画三角形
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribPosition,
                          3, GL_FLOAT, GL_FALSE, 0, vertices);
    glVertexAttribPointer(GLKVertexAttribColor,
                          4, GL_FLOAT, GL_FALSE, 0, colors);
    glDrawArrays(GL_TRIANGLES, 0, 3);
    
    // 渲染
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext presentRenderbuffer:GL_RENDERBUFFER];
}

- (void)dealloc {
    [self tearDownBuffers];
    
    [EAGLContext setCurrentContext:nil];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/23.png" alt="23"/></p>

<blockquote>
<p>如果我们要做一个真正的<strong>OpenGL</strong>应用, </p>
</blockquote>

<hr/>

<h3 id="toc_17">AVPlayerLayer</h3>

<blockquote>
<p>最后一个图层类型叫做<strong>AVPlayerLayer</strong>, 看名字就知道它并不属于<strong>Core Animation</strong>里的一个部分, 它是由<strong>AVFoundation</strong>所提供, 但它和<strong>Core Animation</strong>紧密的结合在一起, 并且是<strong>CALayer</strong>的子类, 可以用来显示自定义内容.<br/>
<dr/><br/>
实际上<strong>AVPlayerLayer</strong>是用来在<strong>iOS</strong>上播放视频的, 是属于<strong>MPMoivePlayer</strong>的底层实现, 提供了显示视频的底层支持.<br/>
<dr/><br/>
<strong>AVPlayerLayer</strong>使用起来比较简单, 我们可以直接来看看<strong>Demo</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addAVPlayerLayer {
    
    NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;demo0&quot;
                                         withExtension:@&quot;m4v&quot;];
    
    AVPlayer *player = [AVPlayer playerWithURL:url];
    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];
    
    playerLayer.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height);
    
    [self.view.layer addSublayer:playerLayer];
    
    [player play];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/24.gif" alt="24"/></p>

<blockquote>
<p>我们知道了<strong>AVPlayerLayer</strong>是<strong>CALayer</strong>的子类, 那么它应当也有父类的所有特性, 比如3D, 圆角, 有色边框, 蒙版, 阴影等等效果都有, 我们再原来的基础上再改改~</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addAVPlayerLayerTwo {
    
    NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;demo0&quot;
                                         withExtension:@&quot;m4v&quot;];
    
    AVPlayer *player = [AVPlayer playerWithURL:url];
    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];
    
    playerLayer.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height);
    
    [self.view.layer addSublayer:playerLayer];
    
    CATransform3D transform = CATransform3DIdentity;
    transform.m34 = -1.0 / 500.0;
    transform = CATransform3DRotate(transform, M_PI_4, 1, 1, 0);
    
    playerLayer.transform = transform;
    playerLayer.masksToBounds = YES;
    playerLayer.cornerRadius = 30.f;
    playerLayer.borderColor = [UIColor blueColor].CGColor;
    playerLayer.borderWidth = 10.f;
    
    [player play];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/25.gif" alt="25"/></p>

<hr/>

<h3 id="toc_18">总结</h3>

<blockquote>
<p>好了, 这次我们讲到这里了, 在这章里, 我们认识<strong>CALayer</strong>的一些子类, 以及它们的一些特性, 方便我们在开发当中实现我们想要的效果时提供了多一些的参考, 但是呢, 这还远远不够, 我们只是初步的去了解这些<strong>CALayer</strong>子类的皮毛, 单单<strong>CATiledLayer</strong>和<strong>CAEMitterLayer</strong>两个子类我们都可以单独抽出来写一长串的东东, 这个还是后面再说吧, 重点是, 我们要记住, <strong>CALayer</strong>的用处非常之大, 虽然有一些<strong>CALayer</strong>的子类并没有为所有可能出现的场景进行优化, 这个就要靠我们自己的头脑风暴去思考如何才能更好的去优化了.</p>
</blockquote>

<hr/>

<h3 id="toc_19">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_20">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：搭建Mac OS本地SVN服务器]]></title>
    <link href="https://cainrun.github.io/14785314208383.html"/>
    <updated>2016-11-07T23:10:20+08:00</updated>
    <id>https://cainrun.github.io/14785314208383.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在前一段时间, 没网的情况下写项目, 发现一件很蛋疼的事, 居然不知道怎么版本管理了, 灵光一闪, 自己搭建个本地SVN服务器吧, 于是乎这文章就出来了</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>搭建Mac OS本地SVN服务器</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">创建SVN服务器</h3>

<blockquote>
<p>首先我们要创建一个<strong>SVN</strong>服务器存放夹, 这里我的地址是如下:</p>
</blockquote>

<pre><code class="language-vim">    sudo svnadmin create /Users/imac/Documents/svn/MyCode
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/1.png" alt="1"/></p>

<hr/>

<h3 id="toc_2">配置SVNServe.conf文件</h3>

<blockquote>
<p>创建完之后, 就需要配置一下<strong>SVN</strong>, 我这里比较习惯使用<strong>Vim</strong>.<br/>
在我机子上的目录是如下: </p>
</blockquote>

<pre><code class="language-vim">sudo vim /Users/imac/Documents/svn/MyCode/conf/svnserve.conf 
</code></pre>

<blockquote>
<p>输入完之后, 需要开放几个参数, 一定要把他们前面的<strong>#</strong>号和<strong>空格</strong>都删掉.</p>

<ul>
<li>anon-access = none(默认为read, 修改改成none)</li>
<li>auth-access = write</li>
<li>password-db = passwd</li>
<li>authz-db = authz</li>
</ul>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2.png" alt="2"/></p>

<hr/>

<h3 id="toc_3">配置Passwd文件</h3>

<blockquote>
<p>配置完<strong>svnserve.conf</strong>文件之后, 就继续来配置<strong>passwd</strong>文件:</p>
</blockquote>

<pre><code class="language-vim">    sudo vim /Users/imac/Documents/svn/MyCode/conf/passwd 
</code></pre>

<blockquote>
<p>这里我们只需要添加一个用户名和密码就可以了, 毕竟就只有自己在用而已.</p>
</blockquote>

<pre><code class="language-vim">    admin=123456
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_4">配置Authz文件</h3>

<blockquote>
<p>配置完前面两个文件, 下面这个文件配置完就搞定了</p>
</blockquote>

<pre><code class="language-vim">    sudo vim /Users/imac/Documents/svn/MyCode/conf/authz
</code></pre>

<pre><code class="language-vim">[groups]

admins=admin

[/]
@admins=rw
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_5">启动SVN服务器</h3>

<blockquote>
<p>配置了那么多, 最重要的重头戏来了, 就是启动我们的<strong>SVN</strong>服务器</p>
</blockquote>

<pre><code class="language-vim">    svnserve -d -r /Users/imac/svn/MyCode
</code></pre>

<blockquote>
<p>如果输入之后, 终端一点提示都没有, 那就代表<strong>SVN</strong>服务器已经启动成功了.</p>
</blockquote>

<hr/>

<h3 id="toc_6">关闭SVN服务器</h3>

<blockquote>
<p>有启动, 当然也有关闭</p>
</blockquote>

<pre><code class="language-vim">    sudo killall svnserve
</code></pre>

<blockquote>
<p>或者是打开活动监视器搜索之后在咔擦掉</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_7">首次导入工程文件到SVN服务器</h3>

<blockquote>
<p><strong>SVN</strong>服务器弄好了, 现在就是要导入工程文件到服务器去了</p>
</blockquote>

<pre><code class="language-vim">    svn import /Users/imac/Documents/AFNetworking svn://localhost/MyCode --username=admin --password=123456 -m &quot;初始化导入&quot;
</code></pre>

<blockquote>
<p>这里解释一下这条命令是啥意思:<br/>
* <strong>/Users/imac/Documents/AFNetworking</strong>这一段指的是需要导入的工程文件.<br/>
* <strong>svn://localhost/MyCode</strong>指的是把工程文件上传到<strong>MyCode</strong>这个目录下.<br/>
* <strong>--username=admin --password=123456</strong>指的是校验用户名和密码.<br/>
* <strong>-m &quot;初始化导入&quot;</strong>指的是提交的信息.</p>
</blockquote>

<hr/>

<h3 id="toc_8">从SVN服务器下载工程文件到本地</h3>

<blockquote>
<p>上传工程我们已经知道了, 那下载工程我们也来说一说.</p>
</blockquote>

<pre><code class="language-vim">    svn checkout svn://localhost/mycode --username=admin --password=123456 /Users/imac/Documents/code
</code></pre>

<blockquote>
<p>这里就不解释了和上面那条命令意思差不多.</p>
</blockquote>

<hr/>

<h3 id="toc_9">二次提交代码到服务器</h3>

<blockquote>
<p>二次提交是有一个前提的, 那就是你首先需要在<strong>SVN</strong>服务器上下载代码到本地, 然后再去修改这一份代码, 才能够二次提交.<br/>
<dr/><br/>
首先我们得去到工程目录:</p>
</blockquote>

<pre><code class="language-vim">    cd /Users/imac/Documents/code
</code></pre>

<blockquote>
<p>然后再输入命令:</p>
</blockquote>

<pre><code class="language-vim">    svn commit -m &quot;修改部分代码&quot;
</code></pre>

<blockquote>
<p>这样子就可以把<strong>/Users/imac/Documents/code</strong>这个目录下所有修改过的代码都提交到服务器<br/>
<dr/><br/>
这些都是基于<a href="http://blog.csdn.net/langzi7758521/article/details/51646598">终端操作</a>的情况来说的, 我这里推荐使用<strong><font color=red>Cornerstone</font></strong>, 更加的简单方便, 至于哪里有免费版, 大概可以去百度搜一搜, 一堆一堆的~~</p>
</blockquote>

<hr/>

<h3 id="toc_10">权限错误</h3>

<blockquote>
<p>如果你在导入工程时候出现<strong>E000013</strong>的错误, 如下:</p>
</blockquote>

<pre><code class="language-vim">svn: E000013: Can&#39;t open file &#39;/Users/xxx/Documents/svn/XXX/db/txn-current-lock&#39;: Permission denied
</code></pre>

<blockquote>
<p>这个错误一般来说就是你的<strong>svn</strong>文件夹权限没开放, 只要进入到你的<strong>SVN</strong>目录下, 输入下面的命令就可以解决这个问题了.<br/>
我这边的目录是<strong>/Users/imac/Documents/svn/MyCode</strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/6.png" alt="6"/></p>

<pre><code class="language-vim">    /*MyCode就是你创建SVN服务器的文件夹*/
    sudo chown -R $(id -u):$(id -g) MyCode
    chmod -R u+w MyCode
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：5.《Core Animation》CALayer的Transforms]]></title>
    <link href="https://cainrun.github.io/14777052484078.html"/>
    <updated>2016-10-29T09:40:48+08:00</updated>
    <id>https://cainrun.github.io/14777052484078.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>之前我们所了解的<strong>CALayer</strong>都是比较抽象化, 好在<a href="https://cainrun.github.io/14775511877452.html">《Core Animation》CALayer的视觉效果</a>解决我们这些视觉动物的学东西的枯燥, 今天我们就来讲讲<strong>Transforms</strong>, 也就是<strong>CALayer</strong>的<strong>Transforms</strong>.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>CALayer Transforms</strong>讲得是<strong>CALayer</strong>一些我们能够看得见的东西, 这些知识点在我们日常开发中也会有用到的, 比如<strong>Affine Transforms</strong>, <strong>3D Transforms</strong>, <strong>Solid Objects</strong>等等, 待我们一一去讲解.</p>
</blockquote>

<hr/>

<h3 id="toc_2">Affine Transforms</h3>

<blockquote>
<p><strong>Affine Transforms</strong>的中文意思叫做仿射转换, 在前一篇文章的时候我们就使用过<strong>transform</strong>来旋转<strong>UIView</strong>, 但那时候我们只是简单的使用罢了, 并没有说明它的原理.<br/>
<dr/><br/>
实际上<strong>UIView</strong>里的<strong>transform</strong>是<strong>CAAffineTransform</strong>类型, 用于做二维空间的旋转, 缩放, 平移等操作, 而且<strong>CAAffineTransform</strong>可以和一个二维空间的向量, 比如<strong>CGPoint</strong>做<strong>3x2</strong>的矩阵.<br/>
<dr/><br/>
大概的运算原理就是, 用<strong>CGPoint</strong>的每一列和<strong>CGAffineTransform</strong>矩阵的每一列对应的元素进行相乘再求和, 这样子就会形成一个新的<strong>CGPoint</strong>.<br/>
<dr/><br/>
说到这里, 应该会有人有疑惑, <strong>CGAffineTransform</strong>和<strong>CGPoint</strong>完全都不是一样东西, 怎么能做运算呢? 其实并不是的, 当你使用它们两个进行运算的时候, 系统会自动补上一些缺少的元素, 使得<strong>CGAffineTransform</strong>和<strong>CGPoint</strong>进行一一对应, 但运算完之后, 这些填充值就会被抛弃掉, 不会进行保存, 仅仅只是用来做运算罢了.<br/>
<dr/><br/>
所以我们通常遇到的二维变换都是使用<strong>3x3</strong>, 而不是刚刚所说到的<strong>2x3</strong>, 但在某些情况下我们也会遇到<strong>2x3</strong>的格式矩阵, 这就是所谓的以列为主(这个等下用事例来查看吧), 但无论如何都好, 只要能够保持一致, 用什么格式又何妨呢?<br/>
<dr/><br/>
当对图层进行矩阵变换时, 图层矩形内的每一个点都被相应的做变换, 从而形成一个新的四边形的形状, <strong>CGAffineTransform</strong>中的&quot;仿射&quot;的意思是无论你如何去改变矩阵的值, 图层中平行的两条线在变换之后仍然保持平行, 这就是<strong>CGAffineTransform</strong>的&quot;仿射&quot;.</p>
</blockquote>

<h4 id="toc_3">Creating a CGAffineTransform - 创建一个CGAffineTransform</h4>

<blockquote>
<p>其实对矩阵数学的阐述早就超过了<strong>Core Animation</strong>的讨论范围了, 如果你是对矩阵数学一点都不了解的话, 那你就要哭晕在厕所了, 不过还好, <strong>Core Graphics</strong>提供了一系列的<strong>API</strong>, 对完全没有数学基础的开发者来讲也能够做一些简单的变换, 比如:</p>
</blockquote>

<pre><code class="language-objectivec">    CGAffineTransformMakeRotation(CGFloat angle);
    CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);
    CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);
</code></pre>

<blockquote>
<p>在<strong>UIView</strong>可以通过设置<strong>transform</strong>属性进行变换, 但实际上还是对CGLayer进行了一些图层转变的封装.<br/>
<dr/><br/>
<strong>CALayer</strong>同样也有一个<strong>transform</strong>属性, 它叫做<strong>affineTransform</strong>, 但它的类型是<strong>CATransform3D</strong>, 而不是<strong>CGAffineTransform</strong>, 这个后面再解释一下神马是<strong>CATransform3D</strong>.<br/>
<dr/><br/>
直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewTransform {
    
    self.view.backgroundColor = [UIColor grayColor];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    // 旋转
    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);
    imageView.layer.affineTransform = transform;
    
    // 缩放
//    CGAffineTransform scaleTransform = CGAffineTransformMakeScale(0.5, 0.5);
//    imageView.layer.affineTransform = scaleTransform;
    
    // 平移
//    CGAffineTransform translationTransform = CGAffineTransformMakeTranslation(50, 50);
//    imageView.layer.affineTransform = translationTransform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/1.png" alt="1"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/2.png" alt="2"/></p>

<blockquote>
<p>注意一下, 我们在这里使用的是<strong>M_PI_4</strong>, 而不是我们自己输入的神马<strong>45</strong>之类的数字, 因为在<strong>iOS</strong>当中, 使用的的是弧度单位, 而不是角度单位, 弧度用数学常量是表示为<strong>pi</strong>, 一个<strong>pi</strong>就为<strong>180°</strong>, 而四分之一度就是<strong>45°</strong>了.<br/>
<dr/><br/>
但这里会有一个问题, 这些宏都是系统提供给我们的, 如果你要自己去加载更多或者是扩展的话, 可以自己手动去写一个<strong>API</strong>.</p>
</blockquote>

<h4 id="toc_4">Combining Transforms - 混合变换</h4>

<blockquote>
<p><strong>Core Graphics</strong>提供了一系列的API可以在一个<strong>transform</strong>的基础上做更深层次的<strong>transform</strong>, 比如说缩放之后再旋转, 比如下面几个<strong>API</strong>:<br/>
<dr/></p>
</blockquote>

<pre><code class="language-objectivec">    CGAffineTransformRotate(CGAffineTransform t, CGFloat angle);
    CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy);
    CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)
</code></pre>

<blockquote>
<p>当你操纵一个<strong>transform</strong>的时候, 需要先创建一个<strong>CGAffineTransform</strong>类型的空值, 直接把<strong>CGAffineTransformIdentity</strong>赋值过去就好了, 这个称为单位矩阵.<br/>
<dr/><br/>
如果你需要把两个已经写好的<strong>transform</strong>合成为一个的话, 你可以使用系统提供的<strong>API</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);
</code></pre>

<blockquote>
<p>不说那么多废话了, 直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewCombiningTransforms {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    CGAffineTransform transform = CGAffineTransformIdentity;
    
    // 旋转
    transform = CGAffineTransformRotate(transform, M_PI_4);
    // 缩放
    transform = CGAffineTransformScale(transform, 0.5f, 0.5f);
    // 平移
    transform = CGAffineTransformTranslate(transform, 200, 0);
    
    imageView.layer.affineTransform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/3.png" alt="3"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/4.png" alt="4"/></p>

<blockquote>
<p>看到图片的时候, 你会发现结果好像和想象有些差异, 为什么会平移了那么多? 原因是在于当你按顺序做了<strong>transform</strong>, 上一个<strong>transform</strong>会影响到下一个<strong>transform</strong>, 所以平移之后, 你会发现同样被缩放和旋转了, 这就是意味着, 你在旋转之后的平移和平移之后的旋转讲会得到两种不同的结果, 这个大家需要注意一下.</p>
</blockquote>

<hr/>

<h3 id="toc_5">3D Transforms</h3>

<blockquote>
<p>在之前, 我们有提及过<strong>zPosition</strong>这个属性, 可以从用户角度的来让让图层远离或者是靠近,<strong>CATransform</strong>类型的<strong>transform</strong>可以真正做到让图层在<strong>3D</strong>空间内平移或者旋转.<br/>
<dr/><br/>
和<strong>CGAffineTransform</strong>类似,<strong>CATransform3D</strong>也是一个矩阵, 但和之间所说的<strong>2x3</strong>矩阵不一样,<strong>CATransform3D</strong>是一个可以在3D空间内做变换的<strong>4x4</strong>矩阵.<br/>
<dr/><br/>
和<strong>CGAffineTransform</strong>矩阵类似, <strong>Core Animation</strong>也提供了一系列的使用方法, 用来创建和组合<strong>CATransform3D</strong>矩阵, 于<strong>Core Graphics</strong>的函数相比, 也只是在<strong>3D</strong>的平移和旋转中多出了一个<strong>z</strong>参数, 而旋转的API除了有angle参数之外, 还多出了<strong>x</strong>, <strong>y</strong>, <strong>z</strong>等三个参数, 分别决定了每个坐标轴方向上的旋转, 比如:</p>
</blockquote>

<pre><code class="language-objectivec">
CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z);
CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz);
CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz);
</code></pre>

<blockquote>
<p>在之前的文章里, 我们都应该了解了在<strong>iOS</strong>当中, 原点<strong>{0, 0}</strong>是在左上角, <strong>x</strong>轴正方向为右边, <strong>y</strong>轴正方向为下边, 在<strong>Mac OS</strong>当中则是和<strong>iOS</strong>相反, 但是<strong>Z</strong>轴呢, 则是分别和<strong>x</strong>, <strong>y</strong>轴分别垂直, 指向视角外为正方向, 说那么多, 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewTransforms3D {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];

    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/5.png" alt="5"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/6.png" alt="6"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/7.png" alt="7"/></p>

<h4 id="toc_6">Perspective Projection</h4>

<blockquote>
<p>所谓的<strong>Perspective Projection</strong>就是透视投影, 这里需要普及一些知识(虽然我也看不太懂).<br/>
<dr/><br/>
在现实生活中, 当物体远离我们的时候, 会由于视角的问题, 物体看起来会变小, 理论上说远离我们的视图边要比靠近视角边更短, 但实际上, 我们的视角是等距离的, 也就是在<strong>3D Transform</strong>中仍然保持平行, 和之前提到的仿射变换有些类似.<br/>
<dr/><br/>
所以为了做一些修正, 我们需要引入<strong>投影变换</strong>, 又称为<strong>z变换</strong>, 来对一些做了变换的矩阵做一些修改, 旋转的除外, <strong>Core Animation</strong>, 当中并没有给我们提供直接设置透视变换的函数, 所以我们需要手动去修改矩阵值, 但很庆幸的是, 这个修改是很简单的, 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewPerspectiveProjection {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform;
    
    CATransform3D transform3DIdentity = CATransform3DIdentity;
    transform3DIdentity.m34 = - 1.0 / 500.0;
    transform3DIdentity = CATransform3DRotate(transform3DIdentity, M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform3DIdentity;
}
</code></pre>

<blockquote>
<p>在<strong>CATransform3D</strong>中, 有一个<strong>m34</strong>的元素, 它是用于按比例来缩放<strong>X</strong>和<strong>Y</strong>的值, 从而来计算离视角的距离.<br/>
<dr/><br/>
<strong>m34</strong>的默认值为0, 我们可以通过设置<strong>m34</strong>来应用透视效果, 公式是<strong>-1.0/d</strong>, <strong>d</strong>代表了想象中视角相机和屏幕之间的距离, 以像素为单位, 通常设置<strong>500-1000</strong>之间, 但是对于一些特殊视图, 设置的值要小一些, 或者大一些要比<strong>500-1000</strong>要好一些, 所以这些值并不是固定的, 最好是根据需求来调节, 不然会出现湿疹, 或者是失去透视效果.</p>
</blockquote>

<h4 id="toc_7">The Vanishing Point</h4>

<blockquote>
<p><strong>The Vanishing Point</strong>翻译过来叫做<strong>消失点</strong>, 意思是当在透视角度绘图时, 原理视觉角度的物体将会变小变远, 远离到一个极限的时候, 所有物体最后都会汇聚并且消失在同一个点.<br/>
<dr/><br/>
在现实生活中, 这个点通常都是视图的中心, 如果要在应用中创建拟真效果的透视, 这个点一般是在屏幕的重点, 至少是所有3D对象的视图中点.<br/>
<dr/><br/>
在<strong>Core Animation</strong>中, 这个点是位于变换图层的<strong>anchorPoint</strong>(当然也有一些特殊的情况), 也就是说, 当图层发生变换的时候, 这个点永远位于图层变换钱的<strong>anchorPoint</strong>位置.<br/>
<dr/><br/>
当我们改变一个图层的<strong>position</strong>时, 也同时改变了它的消失点, 所以在我们做3D变换的时候要记住.<br/>
<dr/><br/>
当我们去调整视图的<strong>m34</strong>来让视图更加有3D效果, 通常要把它放置在屏幕的中央, 然后通过平移来把它移动到指定的位置, 这样子做, 就可以让所有的3D图层都有同一个消失点.</p>
</blockquote>

<h4 id="toc_8">Sublayer Transform</h4>

<blockquote>
<p>如果在开发中, 我们有多个视图或者多个图层, 而且他们都要做3D变换, 那我们就要对这些视图或者图层每个都设置相同的<strong>m34</strong>值, 并且还要确保在变换钱都在屏幕中央都有一个相同的<strong>position</strong>, 当然, 我们可以自己封装一下, 但这样子也非常的蛋疼, 那该怎么做呢?<br/>
<dr/><br/>
在<strong>CALayer</strong>中有一个属性叫做<strong>sublayerTransform</strong>, 它也是<strong>CATransform3D</strong>类型, 但和我们一个一个的去设置图层不同, 它将会影响所有的子图层, 这就是说明了, 我们只要使用<strong>sublayerTransform</strong>, 就可以一次性的把所有子图层都改变.<br/>
<dr/><br/>
这也可以提供另一个好处, 就是当我们使用<strong>sublayerTransform</strong>属性时, 我们就不需要再对子图层挨个挨个的去设置消失点, 因为消失点将会被设置在容器图层的中心点, 那我们就可以随意设置<strong>position</strong>和<strong>frame</strong>来放置子图层, 还是直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewSublayerTransform {
    
    UIImageView *imageViewOne = [[UIImageView alloc] initWithFrame:CGRectMake(80, 100, 100, 100)];
    
    imageViewOne.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    UIImageView *imageViewTwo = [[UIImageView alloc] initWithFrame:CGRectMake(250, 100, 100, 100)];
    
    imageViewTwo.image = [UIImage imageNamed:@&quot;expression&quot;];

    [self.view addSubview:imageViewOne];
    [self.view addSubview:imageViewTwo];
    
    CATransform3D perspective = CATransform3DIdentity; perspective.m34 = - 1.0 / 500.0;
    
    self.view.layer.sublayerTransform = perspective;
    
    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    
    imageViewOne.layer.transform = transform1;
    
    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);
    
    imageViewTwo.layer.transform = transform2;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/8.png" alt="8"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/9.png" alt="9"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/10.png" alt="10"/></p>

<h4 id="toc_9">Backfaces</h4>

<blockquote>
<p>我们既然可以在3D场景下旋转图层, 当然也可以从背面去观察它, 比如我们把翻转的角度设置为<strong>M_PI</strong>, 那么就会显示一个镜像的图层, 我们来看看代码:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewBackfaces {
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
        
    CATransform3D transform3DIdentity = CATransform3DIdentity;
    transform3DIdentity.m34 = - 1.0 / 500.0;
    transform3DIdentity = CATransform3DRotate(transform3DIdentity, M_PI, 0, 1, 0);
    imageView.layer.transform = transform3DIdentity;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/11.png" alt="11"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/12.png" alt="12"/></p>

<h4 id="toc_10">Layer Flattening</h4>

<blockquote>
<p>有人会问, 如果我们对已经做过变换的图层做反方向的会发生啥事?<br/>
<dr/><br/>
在理论上来讲, 我们如果对内部图层做了一个-45度的旋转, 如果要恢复正常, 则要做相反的变换, 才能相互抵消, 为了验证一下, 我们先试试:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewLayerFlattening {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 200, 200)];
    view.backgroundColor = [UIColor blueColor];
    
    [self.view addSubview:view];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [view addSubview:imageView];
    
    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);
    view.layer.transform = outer;
    
    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);
    imageView.layer.transform = inner;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/13.png" alt="13"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/14.png" alt="14"/></p>

<blockquote>
<p>看结果, 和我们想象的一样, 再试试再3D变化的情况下能不能抵消, 继续看代码:</p>
</blockquote>

<pre><code class="language-objectivec">    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 200, 200)];
    view.backgroundColor = [UIColor blueColor];
    
    [self.view addSubview:view];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [view addSubview:imageView];
    
//    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);
//    view.layer.transform = outer;
//    
//    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);
//    imageView.layer.transform = inner;
    
    // 3D Trans
    CATransform3D outer = CATransform3DIdentity; outer.m34 = -1.0 / 500.0;
    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0); view.layer.transform = outer;
    
    CATransform3D inner = CATransform3DIdentity; inner.m34 = -1.0 / 500.0;
    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0); imageView.layer.transform = inner;
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/15.png" alt="15"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/16.png" alt="16"/></p>

<blockquote>
<p>这里我并没有使用<strong>sublayerTransform</strong>属性, 因为这里面的图层并不是容器图层直接的子图层, 所以这里分别对图层设置了<strong>Perspective Projection</strong>.<br/>
<dr/><br/>
结果也是和我们所预期的不太一样, 虽然按道理来讲是显示正常的方块, 但实际上并不是的.<br/>
<dr/><br/>
在<strong>Core Animation</strong>当中, 3D图层存在于3D空间之内, 但它们并不是存在同一个, 其实每一个图层的3D场景都是扁平化的, 当我们正面观察一个图层时, 看到的图层其实是由子图层创建的3D场景, 当你倾斜这个图层时, 会发现这个3D场景只是被绘制在图层的表面罢了.<br/>
<dr/><br/>
总之一句话说完, 用<strong>Core Animation</strong>创建非常负责的3D场景是很蛋疼的, 因为我们不能直接创建一个个图层的去套, 然后构建成一个3D结构的图层关系, 刚刚也说了, 在相同场景下任何3D表面必须和同样的图层保持一致, 这是因为每一个父视图都把它的子视图扁平化了.<br/>
<dr/><br/>
那这个有办法解决吗? 当然有, 使用<strong>CALayer</strong>就可以啦, 在<strong>CALayer</strong>中, 有一个叫做<strong>CATransformLayer</strong>的子类就可以解决这个问题, 这个后面再说吧.</p>
</blockquote>

<hr/>

<h3 id="toc_11">Solid Objects</h3>

<blockquote>
<p><strong>Solid Objects</strong>翻译过来就叫做固体对象, 前面我们懂得了一丢丢的3D空间图层布局, 现在我们尝试着来创建一个固态的3D对象(也就是我们所谓的骰子), 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewSolidObjects {
    
    CATransform3D perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;

    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);
    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);

    self.view.layer.sublayerTransform = perspective;
    
    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);

    for (NSInteger i = 0; i &lt; 6; i++) {
        
        UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
        
        label.backgroundColor = [UIColor whiteColor];
        label.textColor = [UIColor redColor];
        label.layer.borderColor = [UIColor blackColor].CGColor;
        label.layer.borderWidth = 0.5;
        label.tag = i;
        label.text = [NSString stringWithFormat:@&quot;%ld&quot;, i + 1];
        label.font = [UIFont systemFontOfSize:30];
        label.textAlignment = NSTextAlignmentCenter;
        
        switch (label.tag) {
            case 0: {
                
                [self addLabel:label withTransform:transform];
            }
                break;
            case 1: {
                transform = CATransform3DMakeTranslation(100, 0, 0);
                transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 2: {
                transform = CATransform3DMakeTranslation(0, -100, 0);
                transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 3: {
                transform = CATransform3DMakeTranslation(0, 100, 0);
                transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 4: {
                transform = CATransform3DMakeTranslation(-100, 0, 0);
                transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 5: {
                transform = CATransform3DMakeTranslation(0, 0, -100);
                transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            default:
                break;
        }
    }
}

- (void)addLabel:(UILabel *)label withTransform:(CATransform3D)transform {
    
    [self.view addSubview:label];
    
    CGSize containerSize = self.view.bounds.size;
    label.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);
    label.layer.transform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/17.png" alt="17"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/18.png" alt="18"/></p>

<h4 id="toc_12">Light and Shadow</h4>

<blockquote>
<p>刚刚我们弄了一个看上去像是立方体的, 但是它们之前的每一个面之间的连接压根就分辨不出, 虽然在<strong>Core Animation</strong>可以用3D显示图层, 但它并没有光线的概念, 如果要让这个立方体看起来更加的真实, 那我们就要手动给它加个阴影效果, 这个就根据自己的需求来看了.<br/>
<dr/><br/>
这里我们简单的来看看事例: </p>
</blockquote>

<pre><code class="language-objectivec">- (void)addLightingToLabel:(CALayer *)labelLayer {
    
    CALayer *layer = [CALayer layer];
    layer.frame = labelLayer.bounds;
    
    [labelLayer addSublayer:layer];
    
    CATransform3D transform = labelLayer.transform;
    
    GLKMatrix4 matrix4 = [self matrixFrom3DTransformation:transform];
    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);
    
    GLKVector3 normal = GLKVector3Make(0, 0, 1);
    normal = GLKMatrix3MultiplyVector3(matrix3, normal);
    normal = GLKVector3Normalize(normal);
    
    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));
    CGFloat dotProduct = GLKVector3DotProduct(normal, light);
    
    CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;
    UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];
    
    layer.backgroundColor = color.CGColor;
}

- (GLKMatrix4)matrixFrom3DTransformation:(CATransform3D)transform {
    GLKMatrix4 matrix = GLKMatrix4Make(transform.m11, transform.m12, transform.m13, transform.m14,
                                       transform.m21, transform.m22, transform.m23, transform.m24,
                                       transform.m31, transform.m32, transform.m33, transform.m34,
                                       transform.m41, transform.m42, transform.m43, transform.m44);
    
    return matrix;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/19.png" alt="19"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/20.png" alt="20"/></p>

<h4 id="toc_13">Touch Events</h4>

<blockquote>
<p>虽然说我们现在用的是<strong>UILabel</strong>, 如果我们把3, 4, 5, 6换成<strong>UIButton</strong>和<strong>UIView</strong>的组合, 那4, 5, 6点击按钮是无法触发点击事件的.<br/>
<dr/><br/>
这是因为由于视图的顺序, 在之前我们就说过, 点击事件的处理是由视图再父视图中的顺序决定的, 并不是在<strong>3D空间</strong>的<strong>Z轴顺序</strong>上.<br/>
<dr/><br/>
但在这个例子当中, 我们的视图的确是按照顺序来添加的, 那为什么把4, 5, 6换成<strong>UIButton</strong>和<strong>UIView</strong>之后就无法处理点击事件了呢? 那是因为被前面的三个视图挡住了, 在表面上截断了4, 5, 6的点击事件, 这个是和普通的2D布局在按钮上覆盖物体是一样的.<br/>
<dr/><br/>
我们可以把除了3视图之外的视图<strong>userInteractionEnabled</strong>属性都设置成<strong>NO</strong>, 这样子就可以禁止事件传递, 或者通过简单的代码, 把<strong>视图3</strong>覆盖在<strong>视图6</strong>上, 那这样子无论你如何点, 都可以点击到按钮了.</p>
</blockquote>

<hr/>

<h3 id="toc_14">总结</h3>

<blockquote>
<p>总结一下:<br/>
* AffineTransforms的使用<br/>
* AffineTransforms的混合变换<br/>
* 3D Transforms的Perspective Projection<br/>
* 3D Transforms的The Vanishing Point<br/>
* 3D Transforms的Sublayer Transform<br/>
* 3D Transforms的Backfaces<br/>
* 3D Transforms的Layer Flattening<br/>
* 最后再来一丢丢的Solid Objects</p>
</blockquote>

<hr/>

<h3 id="toc_15">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_16">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：4.《Core Animation》CALayer的视觉效果]]></title>
    <link href="https://cainrun.github.io/14775511877452.html"/>
    <updated>2016-10-27T14:53:07+08:00</updated>
    <id>https://cainrun.github.io/14775511877452.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前一章我们对<strong>CALayer</strong>了解的更加深入了一些<a href="https://cainrun.github.io/14773198375857.html">《Core Animation》CALayer的几何图层</a>今天我们就来讲讲<strong>CALayer Visual Effects</strong>, 也就是<strong>CALayer</strong>的视觉效果.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>CALayer Visual Effects</strong>讲得是<strong>CALayer</strong>一些我们能够看得见的东西, 这些知识点在我们日常开发中也会有用到的, 比如<strong>Rounded Corners</strong>, <strong>Layer Borders</strong>, <strong>Drop Shadows</strong>, <strong>Layer Masking</strong>, <strong>Scaling Filters</strong>, <strong>Group Opacity</strong>等等, 待我们一一去讲解.</p>
</blockquote>

<hr/>

<h3 id="toc_2">Rounded Corners</h3>

<blockquote>
<p><strong>Rounded Corners</strong>这个东西我们用的其实也是挺多的, 我们都知道, 在<strong>iOS 7</strong>之前, 基本上所有的<strong>Button</strong>都是椭圆形的, 而这些<strong>Button</strong>之所以都是椭圆形, 大多数都是因为<strong>Rounded Corners</strong>这个东西的原因.<br/>
<dr/><br/>
在<strong>CALayer</strong>有一个叫<strong>conrnerRadius</strong>的CGFloat类型属性来控制着图层角的曲率, 默认值为0, 你可以设置任意数值, 是的图层角显示不一样的曲率, 而且<strong>conrnerRadius</strong>这个属性所影响的到的只有设置该属性的<strong>CALayer</strong>, 并不会影响到子图层或者是背景图, 但如果你要让子图层或者是背景图也要跟着该<strong>CALayer</strong>进行曲率处理, 你可以把<strong>masksToBounds</strong>设置为<strong>YES</strong>, 这样子就可以满足你的需求了.<br/>
<dr/><br/>
我们直接来看看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerRoundedCorners {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor redColor];
    view.layer.cornerRadius = 50.f;
    view.layer.masksToBounds = YES;
    
    CALayer *layer = [CALayer layer];
    
    layer.backgroundColor = [UIColor blueColor].CGColor;
    layer.frame = CGRectMake(50, 50, 50, 50);
    
    [view.layer addSublayer:layer];
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/2.png" alt="2"/></p>

<blockquote>
<p><strong><font color=red>PS: 这里需要注意一点, 由于</strong>masksToBounds<strong>和</strong>conrnerRadius<strong>这两个属性同时使用是挺消耗性能的, 如果你是要大面积的去使用, 会造成卡顿现象, 比如说在</strong>UICollectionView<strong>或者是</strong>UITableView<strong>上使用.</font></strong></p>
</blockquote>

<hr/>

<h3 id="toc_3">Layer Borders</h3>

<blockquote>
<p><strong>CALayer</strong>还有两个更好玩的属性, 这也是在<strong>iOS 7</strong>之前<strong>Button</strong>会默认实现的两个属性, 一个叫做<strong>borderWidth</strong>, 一个叫做<strong>borderColor</strong>.<br/>
<dr/></p>

<ul>
<li><strong>borderWidth</strong>: 这是一个<strong>CGFloat</strong>类型的属性, 是用来设置<strong>CALayer</strong>边框宽度, 默认值是为0.</li>
<li><strong>borderColor</strong>: 这是一个<strong>CGColorRef</strong>类型的属性, 所以你不能给它直接设置一个<strong>UIColor</strong>对象, 前面我们已经对<strong>CGColorRef</strong>这个东东进行了简单的介绍, 这里我们只需要知道直接给它赋个值就好了, 还有就是<strong>borderColor</strong>是用来设置<strong>CALayer</strong>边框颜色, 在<strong>iOS 7</strong>之前默认值是为黑色, <strong>iOS 7</strong>之后默认值是为透明.</li>
</ul>

<p><dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerBorders {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor blueColor];
    view.layer.borderWidth = 5.f;
    view.layer.borderColor = [UIColor redColor].CGColor;
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/3.png" alt="3"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_4">Drop Shadows</h3>

<blockquote>
<p>在<strong>iOS</strong>当中, 还有一个特性, 叫做<strong>Drop Shadows(阴影)</strong>, 其实这个也不算是<strong>iOS</strong>特有的, 毕竟在<strong>Mac OS</strong>里早就已经有这个特性了.<br/>
<dr/><br/>
阴影往往是起暗示作用, 比如说你现在正在显示的窗口, 周边就会带上阴影, 或者是强调里面的某个图层的优先级, 大多数时候只是用来装饰罢了.<br/>
<dr/><br/>
设置阴影的时候也是很简单, 直接给<strong>shadowOpacity</strong>属性设置一个大于<strong>0.0</strong>的值就好了, <strong>shadowOpacity</strong>这个属性可设置的值是在<strong>0.0~1.0</strong>之间, 默认是<strong>0.f</strong>, 最大值是<strong>1.f</strong>, 如果直接设置为<strong>1.f</strong>, 那么将会显示一个轻微模糊的黑色阴影在图层的上方, 另外, 你可以通过<strong>CALayer</strong>所提供的<strong>shadowColor</strong>, <strong>shadowOffset</strong>, <strong>shadowRadius</strong>对阴影进行一些额外的操作, 这里就不一一介绍了, 各位童鞋们可以自行尝试一下~<br/>
<dr/><br/>
说到这里, 会有人问, 为什么阴影是在图层的上方呢? 其实在之前我们就有了解过Mac OS和iOS的一些东西, 基本上iOS的一些东西都是从Mac OS搬过来, 然后再改改的, 包括这个阴影也是如此, 所以你才会看到在iOS当中阴影是反过来的, 这里我们只需要设置一下<strong>shadowOffset</strong>就可以正常显示了.<br/>
<dr/><br/>
直接看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerDropShadows {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor redColor];
    view.layer.shadowOpacity = 1.0f;
    view.layer.shadowOffset = CGSizeMake(0, 3);
    view.layer.shadowRadius = 10.f;
    view.layer.shadowColor = [UIColor blueColor].CGColor;
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/5.png" alt="5"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/6.png" alt="6"/></p>

<h4 id="toc_5">Shadow Clipping</h4>

<blockquote>
<p>这里还有一个比较好玩的东西, 就是阴影剪切, 我们都知道<strong>CALayer</strong>超出了<strong>UIView</strong>的范围, 如果要剪切掉的话, 只能用<strong>masksToBounds</strong>这个属性去剪切.<br/>
<dr/><br/>
但这样子会带来另一个的问题, 因为一旦使用<strong>masksToBounds</strong>这个属性, 剪切掉的就不只是多出来的部分, 会连阴影部分都一起剪切完, 为了防止阴影也跟着被剪切掉, 我们需要使用一个比较笨的方法, 就是再创建多一个<strong>CALayer</strong>, 让它去创建阴影部分, 另一个<strong>CALayer</strong>去剪切内容就可以了.<br/>
<dr/><br/>
我们还是直接看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerShadowClipping {
    
    UIView *contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
    UIView *blueView = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    UIView *shadowView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    contentView.backgroundColor = [UIColor grayColor];
    blueView.backgroundColor = [UIColor blueColor];
    
    contentView.layer.masksToBounds = YES;
    
    shadowView.layer.shadowOpacity = 1.0f;
    shadowView.layer.shadowOffset = CGSizeMake(0, 0.5f);
    shadowView.layer.shadowColor = [UIColor redColor].CGColor;

    [contentView addSubview:blueView];
    [shadowView addSubview:contentView];
    
    [self.view addSubview:shadowView];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/7.png" alt="7"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/8.png" alt="8"/></p>

<h4 id="toc_6">shadowPath</h4>

<blockquote>
<p>我们都知道其实阴影是没有形态的, 它是根据图层的形状来进行显示, 如果在一个视图当中有很多子图层, 然后要一个一个的去计算阴影的形状, 那是非常耗性能的, 但如果在开发之前你就已经知道阴影的形状, 那么你就可以提前设置好, 这样子就可以优化性能了, 而这个属性就是<strong>shadowPath</strong>, <br/>
<dr/><br/>
<strong>shadowPath</strong>是<strong>CGPathRef</strong>类型, 可以说是一个指向<strong>CGPath</strong>的指针, 而<strong>CGPath</strong>是一个<strong>Core Graphics</strong>对象, 可以用来任意描绘一个矢量图形, 我们也可以使用它来描绘阴影, 大大的提升性能.<br/>
<dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerShadowPath {
    
    UIView *shadowViewOne = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    UIView *shadowViewTwo = [[UIView alloc] initWithFrame:CGRectMake(50, 250, 100, 100)];

    shadowViewOne.layer.shadowOpacity = 0.5f;
    shadowViewTwo.layer.shadowOpacity = 0.5f;
    
    CGMutablePathRef squarePath = CGPathCreateMutable();
    CGPathAddRect(squarePath, NULL, shadowViewOne.bounds);
    shadowViewOne.layer.shadowPath = squarePath;
    
    CGPathRelease(squarePath);
    
    CGMutablePathRef circlePath = CGPathCreateMutable();
    CGPathAddEllipseInRect(circlePath, NULL, shadowViewTwo.bounds);
    shadowViewTwo.layer.shadowPath = circlePath;
    
    CGPathRelease(circlePath);

    [self.view addSubview:shadowViewOne];
    [self.view addSubview:shadowViewTwo];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/9.png" alt="9"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/10.png" alt="10"/></p>

<hr/>

<h3 id="toc_7">Layer Masking</h3>

<blockquote>
<p>我们都知道如果我们要剪切超出范围的图层可以使用<strong>masksToBounds</strong>, 通过<strong>conrnerRadius</strong>可以设置图层为圆角, 但如果你需要设置一个不规整的图层时, 用上面的两个属性是没法实现的.<br/>
<dr/><br/>
虽然我们可以使用一个<strong>32位</strong>且带有<strong>alpha</strong>通道的<strong>png</strong>图片可以实现, 但这个方法也是有局限的, 不能以动态编码的形式生成蒙版, 也不能让子图层或者子视图也裁剪成同样的形状.<br/>
<dr/><br/>
苹果为了解决这个为题, 在<strong>CALayer</strong>当中提供了一个<strong>CGLayer</strong>类型, 名叫<strong>mask</strong>的属性, 有着和其他CALayer一样的布局属性, 它就像是一个子图层, 相对于父图层来进行布局的, 但它又区别于子图层, 它是定义父图层可见部分的.<br/>
<dr/><br/>
虽然<strong>mask</strong>里也有<strong>Color</strong>这个属性, 但它并没啥用, 真正重要的是图层的轮廓, 它就像是一台切割机一样, 实心图层部分会被保留, 其他的就会作为垃圾一样被抛弃.<br/>
<dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerMasking {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;arrow&quot;];
    
    CALayer *maskLayer = [CALayer layer];
    UIImage *maskImage = [UIImage imageNamed:@&quot;star&quot;];
    
    maskLayer.frame = imageView.bounds;
    maskLayer.contents = (__bridge id _Nullable)(maskImage.CGImage);
    
    imageView.layer.mask = maskLayer;
    
    [self.view addSubview:imageView];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/11.png" alt="11"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/12.png" alt="12"/></p>

<hr/>

<h3 id="toc_8">Scaling Filters</h3>

<blockquote>
<p>这里我们提及一个点, 是关于图片显示的一个问题, 我们都知道如果要让一个<strong>CALayer</strong>显示一张图片是直接给它的<strong>contents</strong>直接设置内容, 但是呢, 这个图片是否正确的显示, 画质如何, 我们都无从而知.<br/>
<dr/><br/>
为了解决这个问题,<strong>CALayer</strong>分别提供了<strong>minificationFilter</strong>和<strong>magnificationFilter</strong>属性, 它们都是<strong>NSString</strong>类型, 说到这里, 有人会疑问, 直接显示不就是最好的么, 为啥要那么麻烦, 其实不一定的, 原因的话, 大概有三点吧:<br/>
<dr/></p>

<ul>
<li>能够显示最好的画质, 指的是像素没有被压缩也没有被拉伸.</li>
<li>可以节省资源, 比如神马内存, 存储之类的.</li>
<li>可以优化性能, 减轻CPU的压力.
<dr/></li>
</ul>

<p>打个比方, 比如我们开发的时候, 有个头像省略图, 这个时候呢, 你说是用全图比较好, 还是压缩过的比较好? 答案肯定是压缩过的比较好, 因为可以省资源.<br/>
<dr/><br/>
顺便说说, 这两个属性可设置的值分别是:</p>

<ul>
<li>kCAFilterLinear(默认值)</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear
<dr/>
说那么多, 直接来看Demo吧:</li>
</ul>
</blockquote>

<pre><code class="language-objectivec">- (void)layerScalingFilters {
    
    UIImageView *imageViewOne = [[UIImageView alloc] initWithFrame:CGRectMake(0, 100, self.view.bounds.size.width / 2, 200)];
    UIImageView *imageViewTwo = [[UIImageView alloc] initWithFrame:CGRectMake(self.view.bounds.size.width / 2, 100, self.view.bounds.size.width / 2, 200)];
    UIImageView *imageViewThree = [[UIImageView alloc] initWithFrame:CGRectMake(0, 300, self.view.bounds.size.width / 2, 200)];
    
    imageViewOne.image = [UIImage imageNamed:@&quot;expression&quot;];
    imageViewTwo.image = [UIImage imageNamed:@&quot;expression&quot;];
    imageViewThree.image = [UIImage imageNamed:@&quot;expression&quot;];

    imageViewOne.layer.magnificationFilter = kCAFilterNearest;
    imageViewTwo.layer.magnificationFilter = kCAFilterLinear;
    imageViewThree.layer.magnificationFilter = kCAFilterTrilinear;

    imageViewOne.layer.minificationFilter = kCAFilterNearest;
    imageViewTwo.layer.minificationFilter = kCAFilterLinear;
    imageViewThree.layer.minificationFilter = kCAFilterTrilinear;
    
    [self.view addSubview:imageViewOne];
    [self.view addSubview:imageViewTwo];
    [self.view addSubview:imageViewThree];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/13.png" alt="13"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/14.png" alt="14"/></p>

<blockquote>
<p>额...这个有些尴尬, 看起来的效果区别不太大...凑合着看吧..</p>
</blockquote>

<hr/>

<h3 id="toc_9">Group Opacity</h3>

<blockquote>
<p>最后, 我们来说说<strong>Group Opacity</strong>这个东西, 在<strong>iOS 7</strong>之前, 如果你在一个<strong>Button</strong>上添加一个视图, 在<strong>alpha</strong>设置为<strong>50%</strong>的情况下会出现图层有分割, 需要设置<strong>shouldRasterize</strong>和<strong>rasterizationScale</strong>两个属性才能使得在半透明的情况下看起来是一体, 但是这个问题在<strong>iOS 7</strong>之后就已经解决了, 现在<strong>shouldRasterize</strong>属性更多的是用来解决<strong>UITableView</strong>里的<strong>CALayer</strong>圆角显示图层的处理, 这里就不做多的解释了, 有兴趣的童鞋们可以去谷歌搜搜<strong>shouldRasterize</strong>的用法, 都是挺简单的~</p>
</blockquote>

<hr/>

<h3 id="toc_10">总结</h3>

<blockquote>
<p>总结一下, 这一章我们了解更多的是<strong>CALayer</strong>肉眼上能看到的东西, 比如:<br/>
<br/></p>

<ul>
<li><strong>Rounded Corners</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>圆角的处理.</li>
<li><strong>Layer Borders</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>边框的处理, 包括边框的厚度, 以及颜色等</li>
<li><strong>Drop Shadows</strong>: 在这个知识点里, 我们知道了<strong>CALayer</strong>阴影的处理.</li>
<li><strong>Layer Masking</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>可以作为一个<strong>mask</strong>去使用, 并且可以显示不同不规则的形状.</li>
<li><strong>Scaling Filters</strong>: 在这个知识点里, 我们知道<strong>CALayer</strong>可以更改显示的画质, 优化显示的资源等等.</li>
<li><strong>Group Opacity</strong>: 在这个知识点里, 虽然在<strong>iOS 7</strong>之后已经解决了这个问题, 但我们也可以把<strong>shouldRasterize</strong>属性运用在其他的地方.</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_11">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_12">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
</feed>
