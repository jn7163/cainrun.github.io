<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Cain For iOS]]></title>
  <link href="https://cainrun.github.io/atom.xml" rel="self"/>
  <link href="https://cainrun.github.io/"/>
  <updated>2017-06-11T00:00:31+08:00</updated>
  <id>https://cainrun.github.io/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.coderforart.com/">CoderForArt</generator>

  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 10 新特性《Message Extension》]]></title>
    <link href="https://cainrun.github.io/14969899245168.html"/>
    <updated>2017-06-09T14:32:04+08:00</updated>
    <id>https://cainrun.github.io/14969899245168.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">说点废话</h3>

<blockquote>
<p>中途因为发生了点事, 所以有一段时间没有写博文了, 现在开始开始慢慢写回, 写的风格也改了一些, 大家不懂得可以去各大博客, 论坛, 等等地方翻翻资料, 如果一定要找我问问题的话, 麻烦先用红包来打一下我, 祝大家学习愉快.</p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">Message</h3>

<p><code>Message</code>是苹果爸爸在<code>iOS 10</code>开放给开发者的库, 虽然说是新的库, 但和在<code>iOS 8</code>所使用的方式差不多, 就是<code>Extension</code>, 我们都知道<code>iOS</code>是封闭系统, 所以就不用抱着会和<code>Android</code>那样的开发.</p>

<p>作为<code>Extension</code>有什么好处咧, 按照官方的说法就是, 既可以保证系统的安全, 又可以独立于<code>App</code>之外, 不必绑定父应用程序的一部分.</p>

<p>这里注明一下, 我这个是<code>Objective-C</code>版本的, 如果要找<code>Swift</code>版本的话, 可以到这里去<a href="https://github.com/shinobicontrols/iOS10-day-by-day/tree/master/01%20-%20Messages">Swift-Message</a>.</p>

<hr/>

<h3 id="toc_2">创建项目</h3>

<p>创建<code>Message</code>很简单, 打开<code>Xcode -&gt; New Project -&gt; iMessage Application</code>就搞定了.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/1.Message/Images/1.png" alt="1"/></p>

<p>创建完之后, 我们就可以看到一个<code>MessageViewController</code>, 这个是苹果爸爸一开始就给我们弄好的控制器, 我们只需要在上面弄我们所需要的东西就好.</p>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/1.Message/Images/2.png" alt="2"/></p>

<hr/>

<h3 id="toc_3">两个重要的方法</h3>

<p>这里有两个重要的方法是我们必须知道的</p>

<pre><code class="language-objectivec">// 当我们即将打开Message Extension的时候, 就会调用这个方法
- (void)willBecomeActiveWithConversation:(MSConversation *)conversation;
</code></pre>

<pre><code class="language-objectivec">// 当我们即将操作Message Extension的时候, 就会调用这个方法, 可以选择不同的样式, 然后决定你的Message Extension的显示方式
-
(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle;
</code></pre>

<hr/>

<h3 id="toc_4">添加新的控制器</h3>

<p>为了可扩展性和低耦合, 我打算把整个<code>Message Extension</code>拆的非常零散, 这个时候就需要好几个<code>Controller</code>去分别管理它们自己的业务逻辑了.</p>

<p>这里顺便加一个第三方的库<code>Masonry</code>, 感谢<code>Masonry</code>作者的无私奉献~~</p>

<p>我这个<code>Demo</code>里一共有三个自己创建的控制器, 分别是<code>MessageStartController</code>, <code>MessageFinishController</code>, <code>MessageChangeController</code></p>

<p>由于只是简单的演示, 所以这边就不弄的那么复杂了, 详细的代码自己可以去看看, 也很简单.</p>

<hr/>

<h3 id="toc_5">MessagesViewController</h3>

<p>回到我们的<code>MessagesViewController</code>, 这里主要讲讲我的代码:</p>

<pre><code class="language-objectivec">/**
 Configure ChildController

 @param presentationStyle MSMessagesAppPresentationStyle
 @param conversation MSConversation
 */
- (void)configureChildViewControllerWithPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle
                                             conversation:(MSConversation *)conversation {
    
    // 清除所有的自控制器
    for (UIViewController *childController in self.childViewControllers) {
        
        [childController willMoveToParentViewController:nil];
        [childController.view removeFromSuperview];
        [childController removeFromParentViewController];
    }
    
    switch (presentationStyle) {
        case MSMessagesAppPresentationStyleCompact:
            
            self.childViewController = [self createMessageStartController];
            
            break;
        case MSMessagesAppPresentationStyleExpanded:{
            
            MSMessage *message = conversation.selectedMessage;
            
            if (message) {
                
                self.childViewController = [self createChangeControllerWithConversation:conversation];

            } else {
                self.childViewController = [self createFinishControllerWithConversation:conversation];
            }
        }
            break;
        default:
            break;
    }
    
    // 添加子控制器
    [self addChildViewController:self.childViewController];
    
    [self.view addSubview:self.childViewController.view];
    
    [self.childViewController.view mas_makeConstraints:^(MASConstraintMaker *make) {
        (void)make.edges;
    }];
    
    [self.childViewController didMoveToParentViewController:self];
}
</code></pre>

<p>之前也说过, 为了灵活性和低耦合, 上面那个方法就是用来添加和删除子控制器的.</p>

<pre><code class="language-objectivec">- (void)willBecomeActiveWithConversation:(MSConversation *)conversation {
    
    [self configureChildViewControllerWithPresentationStyle:self.presentationStyle
                                               conversation:conversation];
}

-(void)willTransitionToPresentationStyle:(MSMessagesAppPresentationStyle)presentationStyle {

    [self configureChildViewControllerWithPresentationStyle:presentationStyle
                                               conversation:self.activeConversation];
}
</code></pre>

<p>上面这两个方法就是在<code>Message Extension</code>在切换不同样式的时候, 去调用<code>configureChildViewControllerWithPresentationStyle:</code>方法, 来达到在不同样式下可以切换不同的子控制器.</p>

<pre><code class="language-objectivec">/**
 Configure Message Start Controller

 @return UIViewController
 */
- (UIViewController *)createMessageStartController {
    
    MessageStartController *childController = [[MessageStartController alloc] init];
    
    [childController setMessageStartBloack:^(UIButton *sender){
        
        [self requestPresentationStyle:MSMessagesAppPresentationStyleExpanded];
    }];
    
    return childController;
}

/**
 Configure Message Finish Controller
 
 @return UIViewController
 */
- (UIViewController *)createFinishControllerWithConversation:(MSConversation *)conversation {
    
    MessageFinishController *finishController = [[MessageFinishController alloc] init];
    
    [finishController setMessageFinishBloack:^(UIButton *sender){
        
        MSSession *session = [[MSSession alloc] init];
        
        NSString *player = [NSString stringWithFormat:@&quot;%@ - 是否要发送这条内容?&quot;, conversation.localParticipantIdentifier];
        
        [self insertMessageWithCaption:player
                               session:session
                                 image:[UIImage ms_getImageForView:self.view]
                          conversation:conversation];
        
        [self dismiss];
    }];
    
    return finishController;
}

/**
 Configure Message Change Controller
 
 @return UIViewController
 */
- (UIViewController *)createChangeControllerWithConversation:(MSConversation *)conversation {
    
    MessageChangeController *changeViewController = [[MessageChangeController alloc] init];
    
    [changeViewController setMessageChangeBloack:^(UIButton *sender){
        
        MSMessage *message = conversation.selectedMessage;
        
        if (message) {
            
            MSSession *session = [message session];
            
            NSString *player = [NSString stringWithFormat:@&quot;%@ - 是否要发送更改后的内容?&quot;, conversation.localParticipantIdentifier];
            
            [self insertMessageWithCaption:player
                                   session:session
                                     image:[UIImage ms_getImageForView:self.view]
                              conversation:conversation];
        }
        
        [self dismiss];
    }];
    
    return changeViewController;
}
</code></pre>

<p>上面这三个方法就是用来配置<code>MessageStartController</code>, <code>MessageFinishController</code>, <code>MessageChangeController</code>三个控制器.</p>

<hr/>

<h3 id="toc_6">重点</h3>

<p>这里需要重点讲一个方法:</p>

<pre><code class="language-objectivec">/**
 把内容插入到Message中

 @param caption NSString
 @param session MSSession
 @param image UIImage
 @param conversation MSConversation
 */
- (void)insertMessageWithCaption:(NSString *)caption
                         session:(MSSession *)session
                           image:(UIImage *)image
                    conversation:(MSConversation *)conversation {
    
    MSMessage *message = [[MSMessage alloc] initWithSession:session];
    MSMessageTemplateLayout *templateLayout = [[MSMessageTemplateLayout alloc] init];
    
    templateLayout.caption = caption;
    templateLayout.image = image;
    
    message.layout = templateLayout;
    message.URL = [NSURL URLWithString:@&quot;http://www.baidu.com&quot;];
    
    [conversation insertMessage:message
              completionHandler:nil];
}

</code></pre>

<p>这个方法, 可以把我们想要内容插入到<code>Message Extension</code>中, 然后发送出去.</p>

<hr/>

<h3 id="toc_7">最终效果</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/iOS-10-Characteristic/master/1.Message/Images/3.gif" alt="3"/></p>

<hr/>

<h3 id="toc_8">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/iOS-10-Characteristic/tree/master/1.Message">https://github.com/CainRun/iOS-10-Characteristic/tree/master/1.Message</a></p>

<hr/>

<h3 id="toc_9">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：7.《Core Animation》Implicit Animations]]></title>
    <link href="https://cainrun.github.io/14807833712288.html"/>
    <updated>2016-12-04T00:42:51+08:00</updated>
    <id>https://cainrun.github.io/14807833712288.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在上一篇文章<a href="https://cainrun.github.io/14790557329421.html">《Core Animation》CALayer的Specialized Layers</a>中, 我们了解了<strong>CALayer</strong>的许多子类特性, 可以为我们在遇到一些特殊的开发需求中提供一定的帮助, 既然我们这次学的的<strong>Core Animation</strong>, 那怎么会和动画不挂钩呢? 这次让我们来初体验一下.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>Implicit Animations</strong>也称为隐式动画, 啥? 什么叫做隐式动画? 百度去吧~~哈哈哈(后面会讲解的), 这些问题就不在这里做解释了, 还是进入主题才比较重要.</p>
</blockquote>

<hr/>

<h3 id="toc_2">Transactions</h3>

<blockquote>
<p>其实在<strong>Core Animation</strong>中, 动画效果并不需要我们去手动打开, 因为系统默认就是<strong>Open</strong>状态, 相反过来, 如果我们不需要动画的话, 我们需要手动的去关闭.<br/>
<dr/><br/>
如果我们用一个<strong>CALayer</strong>的一个动画属性, 并且尝试去改变它, 这个效果并不会马上就显示出来, 因为它要从一个默认值平滑的过度到一个新的值, 而这些所有的内部操作我们都不需要去理会, 因为系统默认就是这么做的.<br/>
<dr/><br/>
我们可以先来看个<strong>Demo</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)transactionsColor {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0,
                                                            100,
                                                            self.view.frame.size.width,
                                                            self.view.frame.size.width)];
    
    view.backgroundColor = [UIColor grayColor];
    
    [self.view addSubview:view];
    
    UIButton *button = [[UIButton alloc] init];
    
    button.center = CGPointMake(self.view.frame.size.width / 2, 50);
    button.bounds = CGRectMake(0, 0, 100, 50);
    button.backgroundColor = [UIColor blueColor];
    
    [button setTitle:@&quot;改变颜色&quot;
            forState:UIControlStateNormal];
    [button addTarget:self
               action:@selector(changeLayerColor)
     forControlEvents:UIControlEventTouchUpInside];
    
    [view addSubview:button];
    
    self.colorLayer  = [CALayer layer];
    self.colorLayer.position = CGPointMake(view.frame.size.width / 2, view.frame.size.height / 2);
    self.colorLayer.bounds = CGRectMake(0, 0, 150, 150);
    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    
    [view.layer addSublayer:self.colorLayer];
}

- (void)changeLayerColor {
    
    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                      green:greenColor
                                                       blue:blueColor
                                                      alpha:1.0f].CGColor;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/1.gif" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/2.png" alt="2"/></p>

<blockquote>
<p>看完这个<strong>Demo</strong>其实就已经知道神马叫做隐式动画了, 所谓的隐式动画就是我们没有给它指定任何的动画类型, 仅仅只是改变某个属性, 当然<strong>Core Animation</strong>也是支持显示动画, 不然我们就没那么多的兴趣来学习<strong>Core Animation</strong>了~<br/>
<dr/><br/>
那么当我们去改变一个属性的时候, <strong>Core Animation</strong>是如何去判断动画类型还有动画的持续时间呢? 这个问题其实也很简单, 动画的执行时间取决于<strong>Transactions</strong>的设置, 而动画类型是取决于<strong>CALayer</strong>的行为.<br/>
<dr/><br/>
其实<strong>Transactions</strong>实际上是<strong>Core Animation</strong>用来包含一堆属性动画集合的机制, 任何用指定<strong>Transactions</strong>去改变可以做动画效果的图层属性都不会马上发生变化, 而是需要<strong>Transactions</strong>在提交的一瞬间, 才会开始用一个动画效果过渡到新设置的值.<br/>
<dr/><br/>
而<strong>Transactions</strong>是需要通过<strong>CATransaction</strong>这个类来进行管理的, 奇怪的是, <strong>CATransaction</strong>这个类并不是管理一个简单的<strong>Transactions</strong>, 而是管理了一堆我们不能访问的<strong>Transactions</strong>, 由于<strong>CATransaction</strong>并没有属性和实例化方法, 也不能用<strong>+ (instancetype)alloc;</strong>和<strong>- (instancetype)init;</strong>方法来创建它, 只有它所提供的<strong>+ (void)begin;</strong>和<strong>+ (void)commit;</strong>来控制.<br/>
<dr/><br/>
虽然我们再上面的<strong>Demo</strong>里没有设置动画时间, 但<strong>Core Animation</strong>会在每一个<strong>run looop</strong>周期中自动开始一次新的<strong>Transactions</strong>, 即使我们不手动的去调用<strong>[CATransaction begin];</strong>, 但在每一次<strong>run loop</strong>的循环中, 被修改的属性都会集中起来, 然后统一做一次0.25秒的动画, 这个是系统默认的.<br/>
<dr/><br/>
说了那么多, 我们实际上来改改修改颜色的那个代码块, 让它有一个显示动画的效果:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)changeLayerColorAgain {
    
    [CATransaction begin];
    [CATransaction setAnimationDuration:2.0f];
    
    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                      green:greenColor
                                                       blue:blueColor
                                                      alpha:1.0f].CGColor;
    
    [CATransaction commit];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/3.gif" alt="3"/></p>

<blockquote>
<p>看起来的效果让人觉得是真的有动画效果了, 如果大家在之前就已经用过<strong>UIView</strong>来做过动画的话, 那么大家应该对这个动画模式不会感觉到陌生, 因为<strong>UIView</strong>就有两个类似的方法, <strong>+ (void)beginAnimations:(nullable NSString *)animationID context:(nullable void *)context;</strong>和<strong>+ (void)commitAnimations;</strong>, 其实这两个这两个方法也是因为在内部设置了<strong>CATransaction</strong>的原因.<br/>
<dr/><br/>
在<strong>iOS 4</strong>的时候, 苹果就已经对<strong>UIView</strong>添加了一种基于<strong>Block</strong>的动画方法, <strong>+ (void)animateWithDuration:(NSTimeInterval)duration animations:(void (<sup>)(void))animations</sup> NS_AVAILABLE_IOS(4_0);</strong>, 用起来更加的方便, 但实际上是做同样的事情, 但使用这种方法就可以避免<strong>+ (void)begin;</strong>和<strong>+ (void)commit;</strong>匹配的问题造成一些蛋疼的事情.</p>
</blockquote>

<hr/>

<h3 id="toc_3">Completion Blocks</h3>

<blockquote>
<p>这里我们就使用一下基于<strong>UIView</strong>的<strong>Block</strong>动画方法, 我们可以在动画结束之后再对这个图层进行一些操作, 当然这里还是基于上面的<strong>Demo</strong>来做演示:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)changeLayerColorWithCompletion {
    
    [CATransaction begin];
    [CATransaction setAnimationDuration:2.0f];
    
    [CATransaction setCompletionBlock:^{
        CGAffineTransform transform = self.colorLayer.affineTransform;
        
        transform = CGAffineTransformRotate(transform, M_PI_4);
        
        self.colorLayer.affineTransform = transform;
    }];
    
    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                      green:greenColor
                                                       blue:blueColor
                                                      alpha:1.0f].CGColor;
    
    [CATransaction commit];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/4.gif" alt="4"/></p>

<hr/>

<h3 id="toc_4">Layer Actions</h3>

<blockquote>
<p>开始的时候我们就用一个<strong>Demo</strong>来进行演示:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addLayerView {
    
    self.layerView = [[UIView alloc] init];
    self.layerView.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);
    self.layerView.bounds = CGRectMake(0, 0, 150, 150);
    self.layerView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:self.layerView];
    
    UIButton *button = [[UIButton alloc] init];
    
    button.center = CGPointMake(self.view.frame.size.width / 2, 200);
    button.bounds = CGRectMake(0, 0, 100, 50);
    button.backgroundColor = [UIColor blueColor];
    
    [button setTitle:@&quot;改变颜色&quot;
            forState:UIControlStateNormal];
    
    [button addTarget:self
               action:@selector(changeLayerViewColor)
     forControlEvents:UIControlEventTouchUpInside];
    
    [self.view addSubview:button];
}

- (void)changeLayerViewColor {
    
    [CATransaction begin];
    [CATransaction setAnimationDuration:2.0f];
    
    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.layerView.layer.backgroundColor = [UIColor colorWithRed:redColor
                                                           green:greenColor
                                                            blue:blueColor
                                                           alpha:1.0f].CGColor;
    
    [CATransaction commit];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/5.gif" alt="5"/></p>

<blockquote>
<p>看完这个<strong>Demo</strong>, 有很多人肯定会有疑问, 为啥没有了之前的那个平滑过渡效果呢? 好像是被干掉了, 这是啥回事?<br/>
<dr/><br/>
其实我们可以仔细想一想, 如果<strong>UIView</strong>里的属性都有动画特性的话, 那我们去修改这些属性时, 肯定会注意到的, 可为啥<strong>UIKit</strong>要把这个隐式动画给禁止呢?<br/>
<dr/><br/>
我们都知道<strong>Core Animation</strong>通常会对<strong>CALayer</strong>所有的可做动画的属性都赋予了动画特性, 但在<strong>UIView</strong>中就不一样了, 它会默认把所关联在一起的<strong>CALayer</strong>的这个特性给关闭掉, 这里就要了解一下隐式动画是如何实现的.<br/>
<dr/><br/>
当我们改变<strong>CALayer</strong>属性时, <strong>CALayer</strong>自动应用的动画, 我们可以成为<strong>CALayer</strong>的行为, 每当<strong>CALayer</strong>的属性被修改的时候, 它会去调用<strong>- (nullable id<CAAction>)actionForKey:(NSString *)event;</strong>这个方法去传递属性的名称, 然后就会去执行如下几步:</p>

<ul>
<li>首先<strong>CALayer</strong>会去检测它是否有<strong>Delegate</strong>, 并且看看这个<strong>Delegate</strong>有没有实现<strong>CALayerDelegate</strong>协议里的<strong>- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;</strong>方法, 如果有, 就直接调用并返回结果.</li>
<li>如果<strong>CALayer</strong>没有<strong>Delegate</strong>的话, 或者<strong>Delegate</strong>没有实现<strong>- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;</strong>方法, 那么图层就会接着去检查包含属性名称对应的<strong>CALayer</strong>行为所映射的<strong>Actions</strong>字典.</li>
<li>如果<strong>Actions</strong>字典没有包含对应的属性, 那么图层接着会在它的<strong>style</strong>字典里接着搜索属性名.</li>
<li><p>最后, 在<strong>style</strong>里也找不到对应的行为, 那么图层就会直接调用<strong>+ (nullable id<CAAction>)defaultActionForKey:(NSString *)event;</strong>实现系统所提供的每个属性的默认行为.<br/>
<dr/><br/>
如果一轮完整的搜索结束之后, <strong>- (nullable id<CAAction>)actionForKey:(NSString *)event;</strong>返回为空的话, 那么肯定不会有动画效果, 如果返回<strong>CAAction</strong>协议对应的对象, <strong>CALayer</strong>会拿这个结果去对比先前和当前的值, 并且做一个动画效果.<br/>
<dr/><br/>
知道这个原理之后, 我们就知道<strong>UIKit</strong>是肿么把隐式动画给禁止掉了:</p></li>
<li><p>每一个<strong>UIView</strong>对它所关联的图层都是充当一个<strong>Delegate</strong>对象, 并且提供了<strong>- (nullable id<CAAction>)actionForKey:(NSString *)event;</strong>的实现方法.</p></li>
<li><p>当不在一个动画块的实现中, 那么<strong>UIView</strong>就会对所有<strong>CALayer</strong>的行为返回<strong>nil</strong>, 如果在动画的<strong>Block</strong>范围之内, <strong>UIView</strong>就会返回一个非空的值.<br/>
<dr/><br/>
这里我们简单的<strong>Log</strong>一下结果:</p></li>
</ul>
</blockquote>

<pre><code class="language-objectivec">- (void)checkViewAction {
    
    UIView *layerView = [[UIView alloc] init];
    
    layerView.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);
    layerView.bounds = CGRectMake(0, 0, 150, 150);
    layerView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:layerView];
    
    NSLog(@&quot;Before: %@&quot;, [layerView actionForLayer:layerView.layer
                                            forKey:@&quot;backgroundColor&quot;]);
    
    [UIView beginAnimations:nil
                    context:nil];
    
    NSLog(@&quot;After: %@&quot;, [layerView actionForLayer:layerView.layer
                                           forKey:@&quot;backgroundColor&quot;]);
    
    [UIView commitAnimations];
}
</code></pre>

<pre><code class="language-vim">2016-12-04 12:45:28.178 7.ImplicitAnimations[57079:2126402] Before: &lt;null&gt;
2016-12-04 12:45:28.179 7.ImplicitAnimations[57079:2126402] After: &lt;CABasicAnimation: 0x6000000327c0&gt;
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/6.png" alt="6"/></p>

<blockquote>
<p>这样子我们就可以知道, 当属性在<strong>Block</strong>之外发生改变, <strong>UIView</strong>会直接通过返回<strong>nil</strong>来禁用隐式动画, 但如果在动画块的范围之内, 就会根据动画的具体类型来返回相应的属性, 这个后续会讲到.<br/>
<dr/><br/>
其实除了通过返回<strong>nil</strong>并不是唯一禁止隐式动画的方法, 我们也可以通过<strong>CATransacition</strong>的<strong>+ (void)setDisableActions:(BOOL)flag;</strong>方法, 通过<strong>flag</strong>来对所有属性打开或者关闭隐式动画, 哪怕你是在<strong>[CATransaction begin];</strong>之后来添加, 也是一样可以关闭的.<br/>
<dr/><br/>
这里还有一个<strong>Demo</strong>, 使用<strong>CATransaction</strong>来实现的一个叫做<strong>推进过渡</strong>动画, 其实说白也就是一个<strong>Push</strong>动画:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)pushAnimation {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0,
                                                            100,
                                                            self.view.frame.size.width,
                                                            self.view.frame.size.width)];
    
    view.backgroundColor = [UIColor grayColor];
    
    [self.view addSubview:view];
    
    UIButton *button = [[UIButton alloc] init];
    
    button.center = CGPointMake(self.view.frame.size.width / 2, 50);
    button.bounds = CGRectMake(0, 0, 100, 50);
    button.backgroundColor = [UIColor blueColor];
    
    [button setTitle:@&quot;改变颜色&quot;
            forState:UIControlStateNormal];
    
    [button addTarget:self
               action:@selector(pushChangeColor)
     forControlEvents:UIControlEventTouchUpInside];
    
    [view addSubview:button];
    
    self.colorLayer  = [CALayer layer];
    self.colorLayer.position = CGPointMake(view.frame.size.width / 2, view.frame.size.height / 2);
    self.colorLayer.bounds = CGRectMake(0, 0, 150, 150);
    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    
    CATransition *transition = [CATransition animation];
    
    transition.type = kCATransitionPush;
    transition.subtype = kCATransitionFromLeft;
    
    self.colorLayer.actions = @{@&quot;backgroundColor&quot;: transition};
    
    [view.layer addSublayer:self.colorLayer];
}

- (void)pushChangeColor {
    
    [CATransaction begin];
    [CATransaction setAnimationDuration:2.0f];

    CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
    CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
    
    self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                      green:greenColor
                                                       blue:blueColor
                                                      alpha:1.0f].CGColor;
    [CATransaction commit];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/7.gif" alt="7"/></p>

<hr/>

<h3 id="toc_5">Presentation Versus Model</h3>

<blockquote>
<p>其实仔细想想, <strong>CALayer</strong>的属性行为并不太正常, 为何这么说呢, 因为当我们去改变一个图层的属性时, 我们会发现, 这个值的确是立即发生了改变, 但在屏幕上并没有马上生效, 为何呢? 因为我们在设置属性的时候, 并没有直接去调整图层的显示外观, 仅仅只是定义了图层动画结束之后即将要发生改变的外观.<br/>
<dr/><br/>
<strong>Core Animation</strong>在这里充当了一个控制器的角色, 并且根据<strong>Layer Actions</strong>和<strong>Transactions</strong>来更新视图在屏幕上显示的状态.<br/>
<dr/><br/>
在于用户交互的界面中, <strong>CALayer</strong>的行为更像是保存着视图如何去显示和动画的执行数据模型.<br/>
<dr/><br/>
在<strong>iOS</strong>中, 屏幕会以每秒钟重绘60次, 如果动画市场比60分之一秒还要长, 那么在这段时间里, <strong>Core Animation</strong>就会对屏幕上的图层进行重新的组合, 这就意味着<strong>CALayer</strong>除了我们给予的值之外, 还必须要知道当前显示在屏幕上的属性值的记录.<br/>
<dr/><br/>
而每个图层属性的显示值都会被存储在一个叫做<strong>呈现图层</strong>的独立图层当中, 我们可以通过<strong>- (nullable instancetype)presentationLayer;</strong>方法来访问, 而这个所谓的<strong>呈现图层</strong>, 实际上就是模型图层的复制, 但它的好处是它的属性值代表了在任何指定时间当前所显示的外观效果, 通俗点来讲, 就是我们可以通过获取<strong>呈现图层</strong>的值来获取当前屏幕上真正显示出来的值.<br/>
<dr/><br/>
这里需要注意的一点就是, 如果在<strong>呈现图层</strong>仅仅当<strong>CALayer</strong>首次被提交的时候创建, 那么去调用<strong>- (nullable instancetype)presentationLayer;</strong>方法就会返回<strong>nil</strong>.<br/>
<dr/><br/>
这里我们或许还会注意到另一个方法<strong>- (instancetype)modelLayer;</strong>, 如果我们在呈现图层上调用这个方法, 那么就会返回一个它正在呈现所以来的<strong>CALayer</strong>, 而通常在一个图层上调用这个方法, 就会返回<strong>self</strong>.<br/>
<dr/><br/>
在大多数开发的场景下, 我们都不需要直接访问呈现图层, 我们可以通过和模型图层的交互, 来让<strong>Core Animation</strong>更新并且显示, 但在以下两种场景下<strong>呈现图层</strong>就非常有用了, 一个是在同步动画里, 一个是在处理用户交互的时候:</p>

<ul>
<li>如果我们在实现一个基于定时器的动画, 而不仅仅是基于<strong>Transactions</strong>的动画, 这个时候我们就要准确的知道在某一时刻图层显示在什么位置, 这就会对正确的布局起非常大的作用了.</li>
<li>如果我们想让做动画的图层对于用户有交互, 我们可以使用<strong>- (nullable CALayer *)hitTest:(CGPoint)p;</strong>方法来判断指定的图层是否被点击了, 这个时候就会显示更加的友好, 因为<strong>呈现图层</strong>代表了用户当前看到的图层位置, 而不是当动画效果结束之后的位置.
<dr/>
说了那么多, 还是直接上<strong>Demo</strong>比较直接:</li>
</ul>
</blockquote>

<pre><code class="language-objectivec">- (void)presentationVersusModel {
    
    self.colorLayer  = [CALayer layer];
    self.colorLayer.position = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);
    self.colorLayer.bounds = CGRectMake(0, 0, 150, 150);
    self.colorLayer.backgroundColor = [UIColor redColor].CGColor;
    
    [self.view.layer addSublayer:self.colorLayer];
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    
    CGPoint point = [[touches anyObject] locationInView:self.view];
    
    if ([self.colorLayer.presentationLayer hitTest:point]) {
        
        CGFloat redColor = arc4random() / (CGFloat)INT_MAX;
        CGFloat greenColor = arc4random() / (CGFloat)INT_MAX;
        CGFloat blueColor = arc4random() / (CGFloat)INT_MAX;
        
        self.colorLayer.backgroundColor = [UIColor colorWithRed:redColor
                                                          green:greenColor
                                                           blue:blueColor
                                                          alpha:1.0f].CGColor;
    } else {
        [CATransaction begin];
        [CATransaction setAnimationDuration:4.0f];
        
        self.colorLayer.position = point;
        
        [CATransaction commit];
    }
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/7.ImplicitAnimations/Images/8.gif" alt="8"/></p>

<hr/>

<h3 id="toc_6">总结</h3>

<blockquote>
<p>总结一下:</p>

<ul>
<li><strong>Core Animation</strong>默认是打开动画效果的, 并且默认的动画效果是平滑过渡滴.</li>
<li>我们知道了隐式动画的实现方式.</li>
<li><strong>UIView</strong>关联的图层默认都禁用了隐式动画, 对这种图层做动画的唯一办法就是使用<strong>UIView</strong>的动画函数, 或者是继承与<strong>UIView</strong>并且重写<strong>- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;</strong>方法, 最直接的方法就是直接创建一个显示动画.</li>
<li>对于一个单独存在的图层来讲, 我们可以通过实现图层的<strong>- (nullable id<CAAction>)actionForLayer:(CALayer *)layer forKey:(NSString *)event;</strong>方法, 或者是提供一个<strong>Actions</strong>的字典来控制隐式动画.</li>
<li>除此之外, 我们来了解了<strong>呈现图层</strong>和<strong>模型图层</strong>, 知道了这两个家伙的一些皮毛.
<dr/>
好了, 这次就到这里了, 谢谢大家~</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_7">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_8">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：6.《Core Animation》CALayer的Specialized Layers]]></title>
    <link href="https://cainrun.github.io/14790557329421.html"/>
    <updated>2016-11-14T00:48:52+08:00</updated>
    <id>https://cainrun.github.io/14790557329421.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在上一篇文章<a href="https://cainrun.github.io/14777052484078.html">《Core Animation》CALayer的Transforms</a>中, 我们了解了二维空间和三维空间的一些布局, 还有就是最简单的旋转, 平移之类的, 再来一些就是混合使用的, 这次我们来换个话题.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>Specialized Layers</strong>讲得是一些专用的一些图层类, 而不是之前所说的一些用于图片, 颜色之类的, 下面让我们来看看吧~</p>
</blockquote>

<hr/>

<h3 id="toc_2">CAShapeLayer</h3>

<blockquote>
<p>在之前的文章里, 我们使用过阴影效果, 并且是不使用<strong>CGPath</strong>情况下去构建形状不同的阴影, 在<strong>CALayer</strong>中, 有一个子类叫做<strong>CAShapeLayer</strong>, 它也是可以做到对应的效果.<br/>
<dr/><br/>
<strong>CAShapeLayer</strong>是一个通过矢量图形来进行绘制的图层子类, 而并不是使用<strong>Bitmap</strong>, 当我们指定对应的颜色, 线宽等属性, 就可以使用<strong>CGPath</strong>来绘制我们想要的形状, 最后<strong>CAShapeLayer</strong>就自动渲染出来了, 当然你也可以使用<strong>Core Graphics</strong>直接对一个<strong>CALayer</strong>进行绘制, 但<strong>CAShapeLayer</strong>要比<strong>Core Graphics</strong>直接操作<strong>CALayer</strong>要好一些, 比如:</p>

<ul>
<li><strong>CAShapeLayer</strong>使用了硬件加速, 绘制同一图形时会比<strong>Core Graphics</strong>渲染的快.</li>
<li><strong>CAShapeLayer</strong>不需要像普通<strong>CALayer</strong>一样创建一个寄宿图形, 所以无论有多大, 都不会占用太多的内存.</li>
<li><strong>CAShapeLayer</strong>和<strong>Core Graphics</strong>不一样, 它并不会被图层边界给裁剪掉.</li>
<li><strong>CAShapeLayer</strong>不会出现像素化, 这可以提现在, 用<strong>CAShapeLayer</strong>做3D变换的时候, 不会和普通的图层一样出现像素化.</li>
</ul>
</blockquote>

<h4 id="toc_3">创建一个CGPath</h4>

<blockquote>
<p>刚刚说了, <strong>CAShapeLayer</strong>可以通过<strong>CGPath</strong>来绘制任意图形, 并且可以设置一些属性, 比如<strong>lineWith</strong>, <strong>lineCap</strong>, <strong>lineJoin</strong>.<br/>
<dr/><br/>
我们绘制这个图形的时候, 不一定要闭合, 图层路径也不是绝对, 可以在一个图层上绘制多个不同的图形, 当然, 如果你要想用不同的颜色风格来绘制N个图形, 那你就要准备好多个<strong>Layer</strong>了.<br/>
<dr/><br/>
<strong>CAShapeLayer</strong>是属于<strong>CGPathRef</strong>类型, 但在实际开发中, 我们是用<strong>UIBezierPath</strong>来创建图层路径的, 这样子我们就不用考虑人工释放<strong>CGPath</strong>了, 下面让我们来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)createPath {
    
    UIBezierPath *path = [[UIBezierPath alloc] init];
    
    [path moveToPoint:CGPointMake(175, 100)];
    [path addQuadCurveToPoint:CGPointMake(100, 500)
                 controlPoint:CGPointMake(250, 600)];
    
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    shapeLayer.strokeColor = [UIColor blueColor].CGColor;
    shapeLayer.fillColor = [UIColor clearColor].CGColor;
    shapeLayer.lineWidth = 10;
    shapeLayer.lineJoin = kCALineJoinRound;
    shapeLayer.lineCap = kCALineCapRound;
    shapeLayer.path = path.CGPath;
    
    [self.view.layer addSublayer:shapeLayer];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/1.png" alt="1"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/2.png" alt="2"/></p>

<h4 id="toc_4">圆角</h4>

<blockquote>
<p>之前我们在之前的文章里, 有提到过把一个视图剪切成圆角, 用的就是<strong>CALayer</strong>的<strong>cornerRadius</strong>属性, 而<strong>CAShapeLayer</strong>类也可以提供同样的功能, 虽然代码多了一些, 但也多了一些灵活, 它可以指定单独的指定每个角.<br/>
<dr/><br/>
我们创建圆角矩形其实就是人工绘制单独的直线和弧度, 但在<strong>UIBezierPath</strong>中有提供自动绘制圆角矩形的方法, 直接看代码:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewRoundedCorners {
    
    CGRect rect = CGRectMake(130, 130, 100, 100);
    CGSize radii = CGSizeMake(10, 10);
    
    UIRectCorner corners = UIRectCornerTopRight | UIRectCornerBottomRight | UIRectCornerBottomLeft | UIRectCornerTopLeft;
    
    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:rect
                                               byRoundingCorners:corners
                                                     cornerRadii:radii];
    
    CAShapeLayer *shapeLayer = [CAShapeLayer layer];
    
    shapeLayer.path = path.CGPath;
    
    [self.view.layer addSublayer:shapeLayer];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/3.png" alt="3"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_5">CATextLayer</h3>

<blockquote>
<p>如果我们想在一个图层里显示文字, 我们可以借助和<strong>UILabel</strong>一样的方式, 使用<strong>Core Graphics</strong>在图层上写入内容, 但如果要越过<strong>UILabel</strong>这些控件, 直接在图层上显示文字的话, 我们就要为每个显示文字的图层创建一个图层代理的类, 并且判断哪个图层需要显示哪个字符串, 如果再加一些字体, 颜色一些乱七八糟的东西, 那就蛋疼的不要不要的.<br/>
<dr/><br/>
好在<strong>CALayer</strong>里有一个子类, 叫做<strong>CATextLayer</strong>, 它几乎都包含了<strong>UILabel</strong>的所有绘制特性, 而且还额外提供了一些新特性, 并且在渲染的速度上, 要比<strong>UILabel</strong>快的多, 偷偷说个事, 在<strong>iOS 6</strong>之前, <strong>UILabel</strong>其实是通过<strong>WebKit</strong>来实现绘制的, 所以那时候<strong>iOS</strong>在渲染文字的时候会有非常大的性能问题, 但<strong>CATextLayer</strong>使用的是<strong>Core Text</strong>, 两者之前完全不同一个概念.<br/>
<dr/><br/>
说那么多废话, 直接上代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)catextLayer {
    
    UIView *labelView = [[UIView alloc] initWithFrame:CGRectMake(30, 100, 300, 300)];
    
    labelView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:labelView];
    
    CATextLayer *textLayer = [CATextLayer layer];
    textLayer.frame = labelView.bounds;
    
    [labelView.layer addSublayer:textLayer];
    
    textLayer.foregroundColor = [UIColor blackColor].CGColor;
    textLayer.alignmentMode = kCAAlignmentJustified;
    textLayer.wrapped = YES;
    
    UIFont *font = [UIFont systemFontOfSize:15];
    
    CFStringRef fontName = (__bridge CFStringRef)font.fontName;
    CGFontRef fontRef = CGFontCreateWithFontName(fontName);
    
    textLayer.font = fontRef;
    textLayer.fontSize = font.pointSize;
    
    CGFontRelease(fontRef);
    
    NSString *text = @&quot;这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字&quot;;
    
    textLayer.string = text;
}
</code></pre>

<blockquote>
<p>这里还要多说一句, 如果你发现文本显示的时候出现像素化的时候, 只要加上以下这段代码, 就哦了, 它会以<strong>Retina</strong>模式来渲染:</p>
</blockquote>

<pre><code class="language-objectivec">    textLayer.contentsScale = [UIScreen mainScreen].scale;
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/5.png" alt="5"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/6.png" alt="6"/></p>

<blockquote>
<p><strong>contentsScale</strong>并且并不关心屏幕的拉伸, 因为默认都是<strong>1.0f</strong>, 所以我们要高清, 那就设置它吧.<br/>
<dr/><br/>
<strong>CATextLayer</strong>里的<strong>font</strong>属性, 其实并不是一个真正的<strong>UIFont</strong>类型, 而是一个<strong>CFTypeRef</strong>类型, 这样子就可以根据我们的需求来决定字体的属性到底是用<strong>CGFontRef</strong>类型还是用<strong>Core Text</strong>里的<strong>CTFontRef</strong>类型了, 同时字体大小也是用<strong>fontSize</strong>属性单独设置的, 因为<strong>CTFontRef</strong>和<strong>CGFontRef</strong>和<strong>UIFont</strong>完全是两回事, 在代码中我们也知道了如何将<strong>UIFont</strong>转成<strong>CGFontRef</strong>.<br/>
<dr/><br/>
当然<strong>CATextLayer</strong>里的<strong>string</strong>属性是<strong>id</strong>类型, 并不是我们想象中的<strong>NSString</strong>类型, 因为这样子我们就可以用<strong>NSString</strong>也可以用<strong>NSAttributedString</strong>来指定要显示的文本, 比如指定某段文字的字体, 颜色, 字重, 斜体等等.</p>
</blockquote>

<h4 id="toc_6">Rich Text</h4>

<blockquote>
<p>其实在<strong>iOS 6</strong>的时候, <strong>Apple</strong>就已经给了<strong>UILabel</strong>和其他的<strong>UIKit</strong>文本视图添加直接的属性, 但事实上, 在<strong>iOS 3.2</strong>的时候, <strong>CATextLayer</strong>就已经支持属性化字符串了, 如果你想支持更低版本的<strong>iOS</strong>那么你可以使用<strong>CATextLayer</strong>, 不需要和更复杂的<strong>Core Text</strong>打交道, 也省略了使用其他的方法, 但现在又会有哪家公司支持低版本的<strong>iOS</strong>呢? 但不能够说在新版本的<strong>iOS</strong>D昂中<strong>CATextLayer</strong>就无用功了, 这个得看我们的需求来确定了.<br/>
<dr/> <br/>
这次我们把<strong>Core Text</strong>, <strong>CATextLayer</strong>, <strong>NSAttributedString</strong>三者混在一起使用一下~</p>
</blockquote>

<pre><code class="language-objectivec">- (void)attributedString {
    
    UIView *labelView = [[UIView alloc] initWithFrame:CGRectMake(0, 200, self.view.frame.size.width, 400)];
    
    [self.view addSubview:labelView];
    
    CATextLayer *textLayer = [CATextLayer layer];
    
    textLayer.frame = labelView.bounds;
    textLayer.contentsScale = [UIScreen mainScreen].scale;
    
    [labelView.layer addSublayer:textLayer];
    
    textLayer.alignmentMode = kCAAlignmentJustified; textLayer.wrapped = YES;
    
    UIFont *font = [UIFont systemFontOfSize:15];

    NSString *text = @&quot;这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字, 这是一段测试的文字&quot;;
    
    NSMutableAttributedString *string = nil;
    string = [[NSMutableAttributedString alloc] initWithString:text];
    
    CFStringRef fontName = (__bridge CFStringRef)font.fontName; CGFloat fontSize = font.pointSize;
    CTFontRef fontRef = CTFontCreateWithName(fontName, fontSize, NULL);
    
    NSDictionary *attribs = @{(__bridge id)kCTForegroundColorAttributeName : (__bridge id)[UIColor blackColor].CGColor,
                              (__bridge id)kCTFontAttributeName: (__bridge id)fontRef};
    
    [string setAttributes:attribs range:NSMakeRange(0, [text length])];
    
    attribs = @{(__bridge id)kCTForegroundColorAttributeName: (__bridge id)[UIColor redColor].CGColor,
                (__bridge id)kCTUnderlineStyleAttributeName: @(kCTUnderlineStyleSingle),
                (__bridge id)kCTFontAttributeName: (__bridge id)fontRef};
    
    [string setAttributes:attribs range:NSMakeRange(6, 20)];
    
    CFRelease(fontRef);
    
    textLayer.string = string;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/7.png" alt="7"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/8.png" alt="8"/></p>

<h4 id="toc_7">Leading and Kerning</h4>

<blockquote>
<p>这里有个点, 由于<strong>Core Text</strong>和<strong>WebKit</strong>的内部实现机制不同, 用<strong>CATextLayer</strong>渲染或者是用<strong>UILabel</strong>渲染文本行距和字距也是不一样的, 这个是由使用字体和字符来决定的, 所以大家如果要使用普通的<strong>UILabel</strong>和<strong>CATextLayer</strong>, 就要好好注意一下了.</p>
</blockquote>

<h4 id="toc_8">A UILabel Replacement</h4>

<blockquote>
<p>这次我们就自己创建一个属于我们自己的<strong>UILabel</strong>, 代替系统的<strong>UILabel</strong>, 虽然这个类也是继承于<strong>UILabel</strong>, 但比系统的<strong>UILabel</strong>的<strong>-drawRect:</strong>方法要快, 来看看代码吧~</p>
</blockquote>

<pre><code class="language-objectivec">#import &quot;CLLabel.h&quot;
#import &lt;QuartzCore/QuartzCore.h&gt;

@implementation CLLabel

+ (Class)layerClass {
    
    return [CATextLayer class];
}

- (CATextLayer *)textLayer {
    
    return (CATextLayer *)self.layer;
}

- (void)setUp {
    
    self.text = self.text;
    self.textColor = self.textColor;
    self.font = self.font;
    
    [self textLayer].wrapped = YES;
    [self.layer display];
}

- (id)initWithFrame:(CGRect)frame {
    
    if (self = [super initWithFrame:frame]) {
        
        [self setUp];
    }
    
    return self;
}

- (void)awakeFromNib {
    
    [self setUp];
}

- (void)setText:(NSString *)text {
    super.text = text;
    
    [self textLayer].string = text;
}

- (void)setTextColor:(UIColor *)textColor {
    super.textColor = textColor;
    
    [self textLayer].foregroundColor = textColor.CGColor;
}

- (void)setFont:(UIFont *)font {
    super.font = font;
    
    CFStringRef fontName = (__bridge CFStringRef)font.fontName;
    CGFontRef fontRef = CGFontCreateWithFontName(fontName);
    
    [self textLayer].font = fontRef;
    [self textLayer].fontSize = font.pointSize;
    
    CGFontRelease(fontRef);
}

@end
</code></pre>

<blockquote>
<p>使用这个自定义的<strong>CLLabel</strong>, 我们看看效果</p>
</blockquote>

<pre><code class="language-objectivec">- (void)createCLLabel {
    
    CLLabel *label = [[CLLabel alloc] initWithFrame:CGRectMake(20, 50, 200, 200)];
    
    label.text = @&quot;这是一段很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长很长的测试文字&quot;;
    label.textColor = [UIColor blackColor];
    
    [self.view addSubview:label];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/9.png" alt="9"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/10.png" alt="10"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/11.png" alt="11"/></p>

<hr/>

<h3 id="toc_9">CATransformLayer</h3>

<blockquote>
<p>在我们日常开发当中, 如果需要用到<strong>3D Layer</strong>, 可以用到之前我们说到的<strong>3D Transforms</strong>, 但是那样子太麻烦了, 要算一堆东西, 如果有一种<strong>Layer</strong>可以像玩积木一样, 一个一个的组合成一个<strong>3D</strong>形状的话, 那该多好~<br/>
<dr/><br/>
其实<strong>Apple</strong>早就想到了这个问题, 它们提供了<strong>CATransformLayer</strong>, 就是专门用来给<strong>Layer</strong>做一个容器, 然后让拼接成一个看起来像<strong>3D</strong>的一样图形.<br/>
<dr/><br/>
我们来看代码: </p>
</blockquote>

<pre><code class="language-objectivec">- (void)transformLayer {
    
    self.view.backgroundColor = [UIColor grayColor];
    
    CATransform3D transform3DOne = CATransform3DIdentity;
    
    transform3DOne.m34 = -1.0 / 500.0;
    
    self.view.layer.sublayerTransform = transform3DOne;
    
    CATransform3D transform3DTwo = CATransform3DIdentity;
    
    transform3DTwo = CATransform3DTranslate(transform3DTwo, -100, 0, 0);
    
    CALayer *cubeOne = [self cubeWithTransform:transform3DTwo];
    
    [self.view.layer addSublayer:cubeOne];
    
    CATransform3D transform3DThree = CATransform3DIdentity;
    
    transform3DThree = CATransform3DTranslate(transform3DThree, 100, 0, 0);
    transform3DThree = CATransform3DRotate(transform3DThree, -M_PI_4, 1, 0, 0);
    transform3DThree = CATransform3DRotate(transform3DThree, -M_PI_4, 0, 1, 0);
    
    CALayer *cubeTwo = [self cubeWithTransform:transform3DThree];
    
    [self.view.layer addSublayer:cubeTwo];
}

- (CALayer *)layerWithTransform:(CATransform3D)transform {
    
    CALayer *layer = [CALayer layer];
    
    layer.frame = CGRectMake(-50, -50, 100, 100);
    
    CGFloat red = (rand() / (double)INT_MAX);
    CGFloat green = (100000 / (double)INT_MAX);
    CGFloat blue = (rand() / (double)INT_MAX);
    
    layer.backgroundColor = [UIColor colorWithRed:red
                                            green:green
                                             blue:blue
                                            alpha:1.0f].CGColor;
    layer.transform = transform;
    
    return layer;
}

- (CALayer *)cubeWithTransform:(CATransform3D)transform {
    
    // cube
    CATransformLayer *cube = [CATransformLayer layer];
    
    // layer one
    CATransform3D transform3D = CATransform3DMakeTranslation(0, 0, 50);
    [cube addSublayer:[self layerWithTransform:transform3D]];
    
    // layer two
    transform3D = CATransform3DMakeTranslation(50, 0, 0);
    transform3D = CATransform3DRotate(transform3D, M_PI_2, 0, 1, 0);
    [cube addSublayer:[self layerWithTransform:transform3D]];
    
    // layer three
    transform3D = CATransform3DMakeTranslation(0, -50, 0);
    transform3D = CATransform3DRotate(transform3D, M_PI_2, 1, 0, 0);
    [cube addSublayer:[self layerWithTransform:transform3D]];

    // layer five
    transform3D = CATransform3DMakeTranslation(-50, 0, 0);
    transform3D = CATransform3DRotate(transform3D, -M_PI_2, 0, 1, 0);
    [cube addSublayer:[self layerWithTransform:transform3D]];

    // layer six
    transform3D = CATransform3DMakeTranslation(0, 0, -50);
    transform3D = CATransform3DRotate(transform3D, M_PI, 0, 1, 0);
    [cube addSublayer:[self layerWithTransform:transform3D]];

    CGSize containerSize = self.view.bounds.size;
    
    cube.position = CGPointMake(containerSize.width / 2.0,
                                containerSize.height / 2.0);
    
    cube.transform = transform;
    
    return cube;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/12.png" alt="12"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/13.png" alt="13"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/14.png" alt="14"/></p>

<hr/>

<h3 id="toc_10">CAGradientLayer</h3>

<blockquote>
<p>在<strong>Layer</strong>中, 有一种颜色平滑渐变的子类, 叫做<strong>CAGradientLayer</strong>, 虽然用<strong>Core Graphics</strong>也可以通过一些技巧做到和<strong>CAGradientLayer</strong>一样的效果, 但<strong>CAGradieLayer</strong>真正好, 是好在它是用硬件加速来绘制的, 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)gradientLayer {
    
    UIView *view = [[UIView alloc] init];
    
    view.bounds = CGRectMake(0, 0, 200, 200);
    view.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 2);
    
    CAGradientLayer *gradientLayer = [CAGradientLayer layer];
    gradientLayer.frame = view.bounds;
    
    // 设置渐变的颜色, 理论上来讲是无限添加的
    gradientLayer.colors = @[(__bridge id)[UIColor redColor].CGColor,
                             (__bridge id)[UIColor greenColor].CGColor];
    
    gradientLayer.startPoint = CGPointMake(0, 0); // 开始渐变的点
    gradientLayer.endPoint = CGPointMake(1, 1); // 结束渐变的点
    
    gradientLayer.locations = @[@0.0, @0.2]; // 设置渐变的区域
    
    [view.layer addSublayer:gradientLayer];
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/15.png" alt="15"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/16.png" alt="16"/></p>

<hr/>

<h3 id="toc_11">CAReplicatorLayer</h3>

<blockquote>
<p>在<strong>CALayer</strong>的子类当中还有一个叫做<strong>CAReplicatorLayer</strong>, 它是用来复制重复的图层, 并且, 你可以给这些复制的图层进行一些属性上的操作, 比如渐变色, 渐变透明, 形状, 还可以加动画效果, 来看看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">#pragma mark - CAReplicatorLayer
- (void)replicatorLayer {
    
    UIView *view = [[UIView alloc] init];
    
    view.bounds = CGRectMake(0, 0, 100, 100);
    view.center = CGPointMake(self.view.frame.size.width / 2, self.view.frame.size.height / 4.5);
    
    CATransform3D transform = CATransform3DIdentity;
    
    transform = CATransform3DTranslate(transform, 0, 200, 0);
    transform = CATransform3DRotate(transform, M_PI / 5.0, 0, 0, 1);
    transform = CATransform3DTranslate(transform, 0, -200, 0);

    CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];
    
    replicatorLayer.frame = view.bounds;
    replicatorLayer.instanceCount = 10;  // 复制图层个数
    replicatorLayer.instanceBlueOffset = -1.0f; // 设置每一个图层的逐渐蓝色偏移
    replicatorLayer.instanceRedOffset = -1.0f;  // 设置每一个图层的逐渐红色偏移
    replicatorLayer.instanceAlphaOffset = -0.1f;
    replicatorLayer.instanceDelay = 0.33f;  // 设置每个图层延迟0.33f
    replicatorLayer.instanceTransform = transform;
    
    CALayer *layer = [CALayer layer];
    
    layer.frame = CGRectMake(0, 0, 100, 100);
    layer.backgroundColor = [UIColor whiteColor].CGColor;
    
    [replicatorLayer addSublayer:layer];
    
    self.view.backgroundColor = [UIColor grayColor];
    
    [view.layer addSublayer:replicatorLayer];
    
    [self addLayerAnimation:layer];
    
    [self.view addSubview:view];
}

- (void)addLayerAnimation:(CALayer *)layer {
    
    CABasicAnimation *animation = [CABasicAnimation animationWithKeyPath:@&quot;position.y&quot;];
    
    animation.toValue =  @(layer.position.y - 25.0);
    animation.duration = 0.5;
    animation.autoreverses = true;
    animation.repeatCount = CGFLOAT_MAX;
    
    [layer addAnimation:animation forKey:nil];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/17.png" alt="17"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/18.gif" alt="18"/></p>

<h4 id="toc_12">Reflections</h4>

<blockquote>
<p><strong>CAReplicatorLayer</strong>其实还有一个更加实用的功能, 就是做一个镜面反射的效果, 我们可以自己封装一个<strong>UIView</strong>的类, 也可以自己写一个简单的, 这里我就写个简单点的吧, 大家也可以去<strong>GitHub</strong>里面搜搜, 我在网上搜到一个, 虽然这个库已经2年多没更新了, 但还是值得看看的<a href="https://github.com/nicklockwood/ReflectionView">ReflectionView</a>.</p>
</blockquote>

<pre><code class="language-objectivec">- (void)reflectionsLayer {
    
    CAReplicatorLayer *replicatorLayer = [CAReplicatorLayer layer];
    
    replicatorLayer.instanceCount = 2;
    replicatorLayer.frame = CGRectMake(50, 100, 100, 100);

    CALayer *layer = [CALayer layer];
    
    layer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;github&quot;].CGImage);
    layer.frame = replicatorLayer.bounds;

    CATransform3D transform = CATransform3DIdentity;
    
    transform = CATransform3DTranslate(transform, 0, layer.bounds.size.height, 0);
    transform = CATransform3DScale(transform, 1, -1, 0);
    
    replicatorLayer.instanceTransform = transform;
    replicatorLayer.instanceAlphaOffset = -0.6;
    
    [replicatorLayer addSublayer:layer];
    
    [self.view.layer addSublayer:replicatorLayer];
    self.view.backgroundColor = [UIColor grayColor];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/19.png" alt="19"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/20.png" alt="20"/></p>

<hr/>

<h3 id="toc_13">CAScrollLayer</h3>

<blockquote>
<p>在<strong>CALayer</strong>的子类当中, 还有一个<strong>CAScrollLayer</strong>, 它可以被称为<strong>UIScrollView</strong>的代替品, 但有一个问题, 我们都知道<strong>Core Animation</strong>是不能处理用户输入, 所以<strong>CAScrollLayer</strong>也不能处理滑动事件, 也不能实现<strong>UIScrollView</strong>那种滑动反弹效果, 但这里加了一个滑动手势就可以实现了滑动效果了.</p>
</blockquote>

<pre><code class="language-objectivec">@interface ViewController ()

@property (nonatomic, strong) CAScrollLayer *scrollLayer;

@end

#pragma mark - CAScrollLayer
- (void)addScrollLayer {
    
    CALayer *layer = [CALayer layer];
    
    layer.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;github&quot;].CGImage);
    layer.frame = CGRectMake(0, 0, 300, 300);
    
    self.scrollLayer = [CAScrollLayer layer];
    self.scrollLayer.frame = CGRectMake(50, 100, 150, 150);
    self.scrollLayer.scrollMode = kCAScrollBoth;
    self.scrollLayer.backgroundColor = [UIColor grayColor].CGColor;
    
    [self.scrollLayer addSublayer:layer];
    
    [self.view.layer addSublayer:self.scrollLayer];
    
    UIPanGestureRecognizer *pan = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(panGesture:)];
    
    [self.view addGestureRecognizer:pan];
}

- (void)panGesture:(UIPanGestureRecognizer *)pan {
    
    CGPoint translocation = [pan translationInView:self.view];
    CGPoint origin = self.scrollLayer.bounds.origin;
    
    origin = CGPointMake(origin.x - translocation.x, origin.y - translocation.y);
    
    [self.scrollLayer scrollToPoint:origin];
    
    [pan setTranslation:CGPointZero inView:self.view];
}
</code></pre>

<hr/>

<h3 id="toc_14">CATiledLayer</h3>

<blockquote>
<p>在我们开发当中, 有时候我们会需要加载一张超大的图片, 比如神马4K高清图, 或者是世界地图等等之类的, 但是在<strong>iOS</strong>当中是有内存限制的, 并不像其他系统一样<strong>4G</strong>, <strong>6G</strong>有超大内存, 如果我们要把超大的图片加载到内存当中, 那很明显, 直接会撑爆, 或者是加速速度慢得感人, 如果你是在主线程中使用<strong>UIImage</strong>的<strong>+ (nullable UIImage *)imageNamed:(NSString *)name;</strong>或者是<strong>- (nullable instancetype)initWithContentsOfFile:(NSString *)path</strong>方法来加载图片的话, 那你会惊喜的发现, 卡线程了~~<br/>
<dr/><br/>
在<strong>iOS</strong>当中, 能够高效的绘制并且加载到界面的图片是有一个大小限制的, 因为在<strong>iOS</strong>当中所有显示在屏幕上的图片最终都会被转化为<strong>OpenGL</strong>的纹理, 同时<strong>OpenGL</strong>是有一个最大纹理尺寸的限制, 根据设备的型号来决定, 通常是<strong>2048*2048</strong>或者<strong>4096*4096</strong>, 如果我们想在单个纹理中显示一个比这个限制尺寸还要大的图, 哪怕图片已经存在于内存当中, 我们也会遇到非常大的性能问题, 因为<strong>Core Animation</strong>是强制用<strong>CPU</strong>处理图片, 而不是<strong>GPU</strong>, 苹果为了解决这个问题, 于是乎有了<strong>CATiledLayer</strong>, 下面我们来看看<strong>Demo</strong>:<br/>
<dr/><br/>
由于我不懂怎么把大图分解成小图, 这里就找张小一点的图用用</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addCATileLayer {
    
    UIScrollView *scrollView = [[UIScrollView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, self.view.frame.size.width)];
    
    [self.view addSubview:scrollView];
    
    CATiledLayer *tiledLayer = [CATiledLayer layer];
    
    tiledLayer.frame = CGRectMake(0, 0, 2048, 2048);
    tiledLayer.delegate = self;
    tiledLayer.contentsScale = [UIScreen mainScreen].scale;
    
    [scrollView.layer addSublayer:tiledLayer];
    
    scrollView.contentSize = tiledLayer.frame.size;
    
    [tiledLayer setNeedsDisplay];
}

- (void)drawLayer:(CATiledLayer *)layer inContext:(CGContextRef)ctx {
    
    CGRect bounds = CGContextGetClipBoundingBox(ctx);
    
    NSInteger x = floor(bounds.origin.x / layer.tileSize.width);
    NSInteger y = floor(bounds.origin.y / layer.tileSize.height);
    
    NSString *imageName = [NSString stringWithFormat:@&quot;image%02zd_%02zd&quot;, x, y];
    
    UIImage *tileImage = [UIImage imageNamed:imageName];
    
    UIGraphicsPushContext(ctx);
    
    [tileImage drawInRect:bounds];
    
    UIGraphicsPopContext();
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/21.gif" alt="21"/></p>

<blockquote>
<p>这里我们注意到, 我默认是用<strong>Retina</strong>模式去显示图片的, 所以我们看起来这些图片会比较小, 如果你不想用<strong>Retina</strong>模式去显示, 你可以把代码中的一句代码删除即可:</p>
</blockquote>

<pre><code class="language-objectivec">    tiledLayer.contentsScale = [UIScreen mainScreen].scale;
</code></pre>

<blockquote>
<p>如果我们要做到像地图那样子放大缩小的话, 那就要自己头脑风暴一下, 然后想着如何去实现了~~</p>
</blockquote>

<hr/>

<h3 id="toc_15">CAEmitterLayer</h3>

<blockquote>
<p>在<strong>iOS 5</strong>版本中, 苹果加入了一个新的<strong>CALayer</strong>子类, 叫做<strong>CAEmitterLayer</strong>, 它是一个高性能的粒子引擎, 常用于制作实时效果的动画, 比如烟雾, 火, 雨等等之类的.<br/>
<dr/><br/>
其实仔细想想, <strong>CAEmitterLayer</strong>看起来更像是一个容器, 里面装载着很多的<strong>CAEmitterCell</strong>, 这些<strong>CAEmitterCell</strong>定义了一个粒子效果, 然后在<strong>CAEmitterLayer</strong>的装载中显示出来.<br/>
<dr/><br/>
<strong>CAEmitterCell</strong>类似于一个普通的<strong>CALayer</strong>, 它有一个<strong>contents</strong>的属性, 可以定义为一个<strong>CGImage</strong>, 但不同于普通的<strong>CALayer</strong>的是它有一些课设置属性控制着表现和行为, 想了解更多的话, 大家可以自行去<strong>CAEmitterCell</strong>的头文件找找, 现在我们来看看<strong>Demo</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addCAEmitterLayer {
    
    UIView *contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 100,
                                                                   self.view.frame.size.width,
                                                                   self.view.frame.size.width)];
    
    [self.view addSubview:contentView];
    
    CAEmitterLayer *emitterLayer = [CAEmitterLayer layer];
    
    emitterLayer.frame = contentView.bounds;
    emitterLayer.renderMode = kCAEmitterLayerAdditive;
    emitterLayer.emitterPosition = CGPointMake(emitterLayer.frame.size.width / 2,
                                               emitterLayer.frame.size.height / 2);
    
    [contentView.layer addSublayer:emitterLayer];
    
    CAEmitterCell *cell = [[CAEmitterCell alloc] init];
    
    cell.contents = (__bridge id _Nullable)([UIImage imageNamed:@&quot;fire&quot;].CGImage);
    cell.birthRate = 150;
    cell.lifetime = 5.0;
    cell.color = [UIColor colorWithRed:1.f
                                 green:0.5f
                                  blue:0.1f
                                 alpha:1.0f].CGColor;
    cell.alphaSpeed = -0.4f;
    cell.velocity = 50.f;
    cell.velocityRange = 50.f;
    cell.emissionRange = M_PI * 2.0f;
    
    emitterLayer.emitterCells = @[cell];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/22.gif" alt="22"/></p>

<blockquote>
<p>这里补充一下知识点, <strong>CAEMitterCell</strong>基本上可以分为三种:</p>

<ul>
<li>粒子的某一属性的初始值, 比如:<strong>color</strong>属性指定了一个图片的混合色, 在<strong>Demo</strong>当中我们就设置了某个颜色.</li>
<li>粒子某一属性的变化范围, 比如:<strong>emissionRange</strong>, 在<strong>Demo</strong>当中, 我们设置为<strong>M_PI * 2.0f</strong>, 这意味着粒子可以从<strong>360°</strong>的任意位置反射出来.</li>
<li><p>粒子在指定值的时间线上的变化, 比如: <strong>alphaSpeed</strong>, 子啊<strong>Demo</strong>中, 我们设置为<strong>-0.4f</strong>, 这意味着, 每过一秒, 粒子的透明度就减少<strong>0.4</strong>, 这样子就有渐渐消失的效果啦.<br/>
<dr/><br/>
而<strong>CAEmitterLayer</strong>它是控制着整个粒子系统的位置和形状, 比如<strong>birthRate</strong>, <strong>lifetime</strong>和<strong>celocity</strong>, 当然, <strong>CAEMitterCell</strong>也有这些属性, 整个粒子系统都是这些属性以相乘的方式作用在一起, 这样子我们就可以用一个值来加速或者扩大整个粒子系统.<br/>
<dr/><br/>
我们还需要知道另外两个比较重要的属性:</p></li>
<li><p><strong>preservesDepth</strong>: 是否将一个<strong>3D</strong>的粒子系统平面化到一个图层, 或者可以在<strong>3D</strong>空间中混合其他图层.</p></li>
<li><p><strong>renderMode</strong>: 控制着粒子图片在视觉上是如何混合的, 在<strong>Demo</strong>当中, 我们设置为<strong>kCAEmitterLayerAdditive</strong>效果, 默认值为<strong>kCAEmitterLayerUnordered</strong>, 在开发当中需要什么样的效果, 还是得根据需求的来~</p></li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_16">CAEAGLLayer</h3>

<blockquote>
<p>在<strong>iOS</strong>当中, 如果我们需要高性能的图形绘制, 那肯定是少不了去了解<strong>OpenGL</strong>, 这里说的是非游戏类的应用哈, 毕竟游戏有属于自己的一套渲染库, 说起<strong>OpenGL</strong>, 肯定有很多人觉得这个框架很厉害, 的确是的, 因为<strong>OpenGL</strong>是用<strong>C</strong>来写的, 直接和硬件进行通信, 但是呢, 也因为是用<strong>C</strong>所写的, 几乎有没有抽象出来的接口, 如果你要直接使用<strong>OpenGL</strong>来把图形显示在屏幕上, 那你就需要写非常多的复杂代码, 虽然<strong>OpenGL</strong>是非常强大的神器, 因为<strong>OpenGL</strong>是<strong>Core Animation</strong>和<strong>UIKit</strong>的基础.<br/>
<dr/><br/>
在<strong>OpenGL</strong>中, 是没有对象和图层继承的概念, 它只是非常简单的去处理三角形, 在<strong>OpenGL</strong>中, 所有东西都是<strong>3D</strong>空间中有颜色和纹理的三角形, 感觉灰常的牛逼~<br/>
<dr/><br/>
如果我们要高效的时候<strong>Core Animation</strong>, 那么我们就需要判断我们需要绘制哪些内容, 比如(矢量图形, 粒子, 文本等等), 但即使是我们选择了合适的图层去呈现这些内容, <strong>Core Animation</strong>中也不是每个类型的内容都被高度优化过, 所以要想得到高性能的去绘制, 那就比较蛋疼了.<br/>
<dr/><br/>
在<strong>iOS 5</strong>中, 苹果为了解决这些蛋疼的问题, 加入了一个叫做<strong>GLKit</strong>的库, 它在一定层度上减少了使用<strong>OpenGL</strong>的复杂度, 提供了一个叫做<strong>GLKView</strong>的<strong>UIView</strong>子类, 帮我们处理大部分的设置内容和绘制工作, 有需要了解<strong>GLKit</strong>的朋友们可以去翻翻官方文档.<br/>
<dr/><br/>
即使是如此, 我们还是需要使用到一个叫做<strong>CAEAGLLayer</strong>的<strong>CALayer</strong>子类, 酱紫我们才可以用来显示<strong>OpenGL</strong>的图形.<br/>
<dr/><br/>
这里还需要提到一点, 虽然在大部分情况下, 我们不需要手动设置<strong>CAEAGLLayer</strong>(如果是用<strong>GLKView</strong>的话), 我们可以设置一个<strong>OpenGL ES 2.0</strong>的上下文, 这是大多数的用法, <strong>GLKit</strong>为我们提供许多便捷的方法, 比如设置顶点和片段的着色器之类的, 这些都是以类<strong>C</strong>语言叫做<strong>GLSL</strong>自包含在程序中, 同事在运行时载入到图形硬件中, 当然, <strong>GLSL</strong>的代码和设置<strong>CAEAGLLayer</strong>是一毛钱关系都没, 所以我们会用<strong>GLKBaseEffect</strong>类, 将着色的逻辑抽象出来就完事, 其他的事情, 还是和平常使用一样就哦了, 下面让我们来看看<strong>Demo</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addCAEAGLLayer {
    
    UIView *glView = [[UIView alloc] initWithFrame:CGRectMake(0, 100, self.view.frame.size.width, self.view.frame.size.width)];
    
    [self.view addSubview:glView];
    
    // 设置Context
    self.glContext = [[EAGLContext alloc] initWithAPI:kEAGLRenderingAPIOpenGLES2];
    
    [EAGLContext setCurrentContext:self.glContext];
    
    // 设置显示的Layer
    self.glLayer = [CAEAGLLayer layer];
    self.glLayer.frame = glView.bounds;
    [glView.layer addSublayer:self.glLayer];
    self.glLayer.drawableProperties = @{kEAGLDrawablePropertyRetainedBacking : @NO,
                                        kEAGLDrawablePropertyColorFormat : kEAGLColorFormatRGBA8};
    
    self.effect = [[GLKBaseEffect alloc] init];
    
    [self setUpBuffers];
    [self drawFrame];
}

- (void)setUpBuffers {
    
    // 设置Frame
    glGenFramebuffers(1, &amp;_framebuffer);
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);
    
    // 设置颜色
    glGenRenderbuffers(1, &amp;_colorRenderbuffer);
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0,
                              GL_RENDERBUFFER, _colorRenderbuffer);
    
    [self.glContext renderbufferStorage:GL_RENDERBUFFER
                           fromDrawable:self.glLayer];
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_WIDTH,
                                 &amp;_framebufferWidth);
    glGetRenderbufferParameteriv(GL_RENDERBUFFER, GL_RENDERBUFFER_HEIGHT,
                                 &amp;_framebufferHeight);
    
    // 检查是否成功
    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE) {
        
        NSLog(@&quot;%i&quot;, glCheckFramebufferStatus(GL_FRAMEBUFFER));
    }
}

- (void)tearDownBuffers {
    
    if (_framebuffer) {
        
        glDeleteFramebuffers(1, &amp;_framebuffer);
        _framebuffer = 0;
    }
    
    if (_colorRenderbuffer) {
        
        glDeleteRenderbuffers(1, &amp;_colorRenderbuffer);
        _colorRenderbuffer = 0;
    }
}

- (void)drawFrame {
    
    // 绑定缓冲区
    glBindFramebuffer(GL_FRAMEBUFFER, _framebuffer);
    glViewport(0, 0, _framebufferWidth, _framebufferHeight);
    
    [self.effect prepareToDraw];
    
    // 清空屏幕
    glClear(GL_COLOR_BUFFER_BIT);
    glClearColor(0.0, 0.0, 0.0, 1.0);
    
    // 设置顶点
    GLfloat vertices[] = {
        -0.5f, -0.5f, -1.0f,
        0.0f, 0.5f, -1.0f,
        0.5f, -0.5f, -1.0f};
    
    // 设置颜色值
    GLfloat colors[] = {
        0.0f, 0.0f, 1.0f, 1.0f,
        0.0f, 1.0f, 0.0f, 1.0f,
        1.0f, 0.0f, 0.0f, 1.0f};
    
    // 开始画三角形
    glEnableVertexAttribArray(GLKVertexAttribPosition);
    glEnableVertexAttribArray(GLKVertexAttribColor);
    glVertexAttribPointer(GLKVertexAttribPosition,
                          3, GL_FLOAT, GL_FALSE, 0, vertices);
    glVertexAttribPointer(GLKVertexAttribColor,
                          4, GL_FLOAT, GL_FALSE, 0, colors);
    glDrawArrays(GL_TRIANGLES, 0, 3);
    
    // 渲染
    glBindRenderbuffer(GL_RENDERBUFFER, _colorRenderbuffer);
    [self.glContext presentRenderbuffer:GL_RENDERBUFFER];
}

- (void)dealloc {
    [self tearDownBuffers];
    
    [EAGLContext setCurrentContext:nil];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/23.png" alt="23"/></p>

<blockquote>
<p>如果我们要做一个真正的<strong>OpenGL</strong>应用, </p>
</blockquote>

<hr/>

<h3 id="toc_17">AVPlayerLayer</h3>

<blockquote>
<p>最后一个图层类型叫做<strong>AVPlayerLayer</strong>, 看名字就知道它并不属于<strong>Core Animation</strong>里的一个部分, 它是由<strong>AVFoundation</strong>所提供, 但它和<strong>Core Animation</strong>紧密的结合在一起, 并且是<strong>CALayer</strong>的子类, 可以用来显示自定义内容.<br/>
<dr/><br/>
实际上<strong>AVPlayerLayer</strong>是用来在<strong>iOS</strong>上播放视频的, 是属于<strong>MPMoivePlayer</strong>的底层实现, 提供了显示视频的底层支持.<br/>
<dr/><br/>
<strong>AVPlayerLayer</strong>使用起来比较简单, 我们可以直接来看看<strong>Demo</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addAVPlayerLayer {
    
    NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;demo0&quot;
                                         withExtension:@&quot;m4v&quot;];
    
    AVPlayer *player = [AVPlayer playerWithURL:url];
    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];
    
    playerLayer.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height);
    
    [self.view.layer addSublayer:playerLayer];
    
    [player play];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/24.gif" alt="24"/></p>

<blockquote>
<p>我们知道了<strong>AVPlayerLayer</strong>是<strong>CALayer</strong>的子类, 那么它应当也有父类的所有特性, 比如3D, 圆角, 有色边框, 蒙版, 阴影等等效果都有, 我们再原来的基础上再改改~</p>
</blockquote>

<pre><code class="language-objectivec">- (void)addAVPlayerLayerTwo {
    
    NSURL *url = [[NSBundle mainBundle] URLForResource:@&quot;demo0&quot;
                                         withExtension:@&quot;m4v&quot;];
    
    AVPlayer *player = [AVPlayer playerWithURL:url];
    AVPlayerLayer *playerLayer = [AVPlayerLayer playerLayerWithPlayer:player];
    
    playerLayer.frame = CGRectMake(0, 0, self.view.frame.size.width, self.view.frame.size.height);
    
    [self.view.layer addSublayer:playerLayer];
    
    CATransform3D transform = CATransform3DIdentity;
    transform.m34 = -1.0 / 500.0;
    transform = CATransform3DRotate(transform, M_PI_4, 1, 1, 0);
    
    playerLayer.transform = transform;
    playerLayer.masksToBounds = YES;
    playerLayer.cornerRadius = 30.f;
    playerLayer.borderColor = [UIColor blueColor].CGColor;
    playerLayer.borderWidth = 10.f;
    
    [player play];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/6.SpecializedLayers/images/25.gif" alt="25"/></p>

<hr/>

<h3 id="toc_18">总结</h3>

<blockquote>
<p>好了, 这次我们讲到这里了, 在这章里, 我们认识<strong>CALayer</strong>的一些子类, 以及它们的一些特性, 方便我们在开发当中实现我们想要的效果时提供了多一些的参考, 但是呢, 这还远远不够, 我们只是初步的去了解这些<strong>CALayer</strong>子类的皮毛, 单单<strong>CATiledLayer</strong>和<strong>CAEMitterLayer</strong>两个子类我们都可以单独抽出来写一长串的东东, 这个还是后面再说吧, 重点是, 我们要记住, <strong>CALayer</strong>的用处非常之大, 虽然有一些<strong>CALayer</strong>的子类并没有为所有可能出现的场景进行优化, 这个就要靠我们自己的头脑风暴去思考如何才能更好的去优化了.</p>
</blockquote>

<hr/>

<h3 id="toc_19">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_20">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：搭建Mac OS本地SVN服务器]]></title>
    <link href="https://cainrun.github.io/14785314208383.html"/>
    <updated>2016-11-07T23:10:20+08:00</updated>
    <id>https://cainrun.github.io/14785314208383.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在前一段时间, 没网的情况下写项目, 发现一件很蛋疼的事, 居然不知道怎么版本管理了, 灵光一闪, 自己搭建个本地SVN服务器吧, 于是乎这文章就出来了</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>搭建Mac OS本地SVN服务器</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">创建SVN服务器</h3>

<blockquote>
<p>首先我们要创建一个<strong>SVN</strong>服务器存放夹, 这里我的地址是如下:</p>
</blockquote>

<pre><code class="language-vim">    sudo svnadmin create /Users/imac/Documents/svn/MyCode
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/1.png" alt="1"/></p>

<hr/>

<h3 id="toc_2">配置SVNServe.conf文件</h3>

<blockquote>
<p>创建完之后, 就需要配置一下<strong>SVN</strong>, 我这里比较习惯使用<strong>Vim</strong>.<br/>
在我机子上的目录是如下: </p>
</blockquote>

<pre><code class="language-vim">sudo vim /Users/imac/Documents/svn/MyCode/conf/svnserve.conf 
</code></pre>

<blockquote>
<p>输入完之后, 需要开放几个参数, 一定要把他们前面的<strong>#</strong>号和<strong>空格</strong>都删掉.</p>

<ul>
<li>anon-access = none(默认为read, 修改改成none)</li>
<li>auth-access = write</li>
<li>password-db = passwd</li>
<li>authz-db = authz</li>
</ul>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/2.png" alt="2"/></p>

<hr/>

<h3 id="toc_3">配置Passwd文件</h3>

<blockquote>
<p>配置完<strong>svnserve.conf</strong>文件之后, 就继续来配置<strong>passwd</strong>文件:</p>
</blockquote>

<pre><code class="language-vim">    sudo vim /Users/imac/Documents/svn/MyCode/conf/passwd 
</code></pre>

<blockquote>
<p>这里我们只需要添加一个用户名和密码就可以了, 毕竟就只有自己在用而已.</p>
</blockquote>

<pre><code class="language-vim">    admin=123456
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_4">配置Authz文件</h3>

<blockquote>
<p>配置完前面两个文件, 下面这个文件配置完就搞定了</p>
</blockquote>

<pre><code class="language-vim">    sudo vim /Users/imac/Documents/svn/MyCode/conf/authz
</code></pre>

<pre><code class="language-vim">[groups]

admins=admin

[/]
@admins=rw
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_5">启动SVN服务器</h3>

<blockquote>
<p>配置了那么多, 最重要的重头戏来了, 就是启动我们的<strong>SVN</strong>服务器</p>
</blockquote>

<pre><code class="language-vim">    svnserve -d -r /Users/imac/svn/MyCode
</code></pre>

<blockquote>
<p>如果输入之后, 终端一点提示都没有, 那就代表<strong>SVN</strong>服务器已经启动成功了.</p>
</blockquote>

<hr/>

<h3 id="toc_6">关闭SVN服务器</h3>

<blockquote>
<p>有启动, 当然也有关闭</p>
</blockquote>

<pre><code class="language-vim">    sudo killall svnserve
</code></pre>

<blockquote>
<p>或者是打开活动监视器搜索之后在咔擦掉</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_7">首次导入工程文件到SVN服务器</h3>

<blockquote>
<p><strong>SVN</strong>服务器弄好了, 现在就是要导入工程文件到服务器去了</p>
</blockquote>

<pre><code class="language-vim">    svn import /Users/imac/Documents/AFNetworking svn://localhost/MyCode --username=admin --password=123456 -m &quot;初始化导入&quot;
</code></pre>

<blockquote>
<p>这里解释一下这条命令是啥意思:<br/>
* <strong>/Users/imac/Documents/AFNetworking</strong>这一段指的是需要导入的工程文件.<br/>
* <strong>svn://localhost/MyCode</strong>指的是把工程文件上传到<strong>MyCode</strong>这个目录下.<br/>
* <strong>--username=admin --password=123456</strong>指的是校验用户名和密码.<br/>
* <strong>-m &quot;初始化导入&quot;</strong>指的是提交的信息.</p>
</blockquote>

<hr/>

<h3 id="toc_8">从SVN服务器下载工程文件到本地</h3>

<blockquote>
<p>上传工程我们已经知道了, 那下载工程我们也来说一说.</p>
</blockquote>

<pre><code class="language-vim">    svn checkout svn://localhost/mycode --username=admin --password=123456 /Users/imac/Documents/code
</code></pre>

<blockquote>
<p>这里就不解释了和上面那条命令意思差不多.</p>
</blockquote>

<hr/>

<h3 id="toc_9">二次提交代码到服务器</h3>

<blockquote>
<p>二次提交是有一个前提的, 那就是你首先需要在<strong>SVN</strong>服务器上下载代码到本地, 然后再去修改这一份代码, 才能够二次提交.<br/>
<dr/><br/>
首先我们得去到工程目录:</p>
</blockquote>

<pre><code class="language-vim">    cd /Users/imac/Documents/code
</code></pre>

<blockquote>
<p>然后再输入命令:</p>
</blockquote>

<pre><code class="language-vim">    svn commit -m &quot;修改部分代码&quot;
</code></pre>

<blockquote>
<p>这样子就可以把<strong>/Users/imac/Documents/code</strong>这个目录下所有修改过的代码都提交到服务器<br/>
<dr/><br/>
这些都是基于<a href="http://blog.csdn.net/langzi7758521/article/details/51646598">终端操作</a>的情况来说的, 我这里推荐使用<strong><font color=red>Cornerstone</font></strong>, 更加的简单方便, 至于哪里有免费版, 大概可以去百度搜一搜, 一堆一堆的~~</p>
</blockquote>

<hr/>

<h3 id="toc_10">权限错误</h3>

<blockquote>
<p>如果你在导入工程时候出现<strong>E000013</strong>的错误, 如下:</p>
</blockquote>

<pre><code class="language-vim">svn: E000013: Can&#39;t open file &#39;/Users/xxx/Documents/svn/XXX/db/txn-current-lock&#39;: Permission denied
</code></pre>

<blockquote>
<p>这个错误一般来说就是你的<strong>svn</strong>文件夹权限没开放, 只要进入到你的<strong>SVN</strong>目录下, 输入下面的命令就可以解决这个问题了.<br/>
我这边的目录是<strong>/Users/imac/Documents/svn/MyCode</strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DeveloperDocument/master/%E7%8E%A9%E8%BD%ACiOS%E5%BC%80%E5%8F%91%EF%BC%9A%E6%90%AD%E5%BB%BAMac%20OS%E6%9C%AC%E5%9C%B0SVN%E6%9C%8D%E5%8A%A1%E5%99%A8/6.png" alt="6"/></p>

<pre><code class="language-vim">    /*MyCode就是你创建SVN服务器的文件夹*/
    sudo chown -R $(id -u):$(id -g) MyCode
    chmod -R u+w MyCode
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：5.《Core Animation》CALayer的Transforms]]></title>
    <link href="https://cainrun.github.io/14777052484078.html"/>
    <updated>2016-10-29T09:40:48+08:00</updated>
    <id>https://cainrun.github.io/14777052484078.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>之前我们所了解的<strong>CALayer</strong>都是比较抽象化, 好在<a href="https://cainrun.github.io/14775511877452.html">《Core Animation》CALayer的视觉效果</a>解决我们这些视觉动物的学东西的枯燥, 今天我们就来讲讲<strong>Transforms</strong>, 也就是<strong>CALayer</strong>的<strong>Transforms</strong>.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>CALayer Transforms</strong>讲得是<strong>CALayer</strong>一些我们能够看得见的东西, 这些知识点在我们日常开发中也会有用到的, 比如<strong>Affine Transforms</strong>, <strong>3D Transforms</strong>, <strong>Solid Objects</strong>等等, 待我们一一去讲解.</p>
</blockquote>

<hr/>

<h3 id="toc_2">Affine Transforms</h3>

<blockquote>
<p><strong>Affine Transforms</strong>的中文意思叫做仿射转换, 在前一篇文章的时候我们就使用过<strong>transform</strong>来旋转<strong>UIView</strong>, 但那时候我们只是简单的使用罢了, 并没有说明它的原理.<br/>
<dr/><br/>
实际上<strong>UIView</strong>里的<strong>transform</strong>是<strong>CAAffineTransform</strong>类型, 用于做二维空间的旋转, 缩放, 平移等操作, 而且<strong>CAAffineTransform</strong>可以和一个二维空间的向量, 比如<strong>CGPoint</strong>做<strong>3x2</strong>的矩阵.<br/>
<dr/><br/>
大概的运算原理就是, 用<strong>CGPoint</strong>的每一列和<strong>CGAffineTransform</strong>矩阵的每一列对应的元素进行相乘再求和, 这样子就会形成一个新的<strong>CGPoint</strong>.<br/>
<dr/><br/>
说到这里, 应该会有人有疑惑, <strong>CGAffineTransform</strong>和<strong>CGPoint</strong>完全都不是一样东西, 怎么能做运算呢? 其实并不是的, 当你使用它们两个进行运算的时候, 系统会自动补上一些缺少的元素, 使得<strong>CGAffineTransform</strong>和<strong>CGPoint</strong>进行一一对应, 但运算完之后, 这些填充值就会被抛弃掉, 不会进行保存, 仅仅只是用来做运算罢了.<br/>
<dr/><br/>
所以我们通常遇到的二维变换都是使用<strong>3x3</strong>, 而不是刚刚所说到的<strong>2x3</strong>, 但在某些情况下我们也会遇到<strong>2x3</strong>的格式矩阵, 这就是所谓的以列为主(这个等下用事例来查看吧), 但无论如何都好, 只要能够保持一致, 用什么格式又何妨呢?<br/>
<dr/><br/>
当对图层进行矩阵变换时, 图层矩形内的每一个点都被相应的做变换, 从而形成一个新的四边形的形状, <strong>CGAffineTransform</strong>中的&quot;仿射&quot;的意思是无论你如何去改变矩阵的值, 图层中平行的两条线在变换之后仍然保持平行, 这就是<strong>CGAffineTransform</strong>的&quot;仿射&quot;.</p>
</blockquote>

<h4 id="toc_3">Creating a CGAffineTransform - 创建一个CGAffineTransform</h4>

<blockquote>
<p>其实对矩阵数学的阐述早就超过了<strong>Core Animation</strong>的讨论范围了, 如果你是对矩阵数学一点都不了解的话, 那你就要哭晕在厕所了, 不过还好, <strong>Core Graphics</strong>提供了一系列的<strong>API</strong>, 对完全没有数学基础的开发者来讲也能够做一些简单的变换, 比如:</p>
</blockquote>

<pre><code class="language-objectivec">    CGAffineTransformMakeRotation(CGFloat angle);
    CGAffineTransformMakeScale(CGFloat sx, CGFloat sy);
    CGAffineTransformMakeTranslation(CGFloat tx, CGFloat ty);
</code></pre>

<blockquote>
<p>在<strong>UIView</strong>可以通过设置<strong>transform</strong>属性进行变换, 但实际上还是对CGLayer进行了一些图层转变的封装.<br/>
<dr/><br/>
<strong>CALayer</strong>同样也有一个<strong>transform</strong>属性, 它叫做<strong>affineTransform</strong>, 但它的类型是<strong>CATransform3D</strong>, 而不是<strong>CGAffineTransform</strong>, 这个后面再解释一下神马是<strong>CATransform3D</strong>.<br/>
<dr/><br/>
直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewTransform {
    
    self.view.backgroundColor = [UIColor grayColor];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    // 旋转
    CGAffineTransform transform = CGAffineTransformMakeRotation(M_PI_4);
    imageView.layer.affineTransform = transform;
    
    // 缩放
//    CGAffineTransform scaleTransform = CGAffineTransformMakeScale(0.5, 0.5);
//    imageView.layer.affineTransform = scaleTransform;
    
    // 平移
//    CGAffineTransform translationTransform = CGAffineTransformMakeTranslation(50, 50);
//    imageView.layer.affineTransform = translationTransform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/1.png" alt="1"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/2.png" alt="2"/></p>

<blockquote>
<p>注意一下, 我们在这里使用的是<strong>M_PI_4</strong>, 而不是我们自己输入的神马<strong>45</strong>之类的数字, 因为在<strong>iOS</strong>当中, 使用的的是弧度单位, 而不是角度单位, 弧度用数学常量是表示为<strong>pi</strong>, 一个<strong>pi</strong>就为<strong>180°</strong>, 而四分之一度就是<strong>45°</strong>了.<br/>
<dr/><br/>
但这里会有一个问题, 这些宏都是系统提供给我们的, 如果你要自己去加载更多或者是扩展的话, 可以自己手动去写一个<strong>API</strong>.</p>
</blockquote>

<h4 id="toc_4">Combining Transforms - 混合变换</h4>

<blockquote>
<p><strong>Core Graphics</strong>提供了一系列的API可以在一个<strong>transform</strong>的基础上做更深层次的<strong>transform</strong>, 比如说缩放之后再旋转, 比如下面几个<strong>API</strong>:<br/>
<dr/></p>
</blockquote>

<pre><code class="language-objectivec">    CGAffineTransformRotate(CGAffineTransform t, CGFloat angle);
    CGAffineTransformScale(CGAffineTransform t, CGFloat sx, CGFloat sy);
    CGAffineTransformTranslate(CGAffineTransform t, CGFloat tx, CGFloat ty)
</code></pre>

<blockquote>
<p>当你操纵一个<strong>transform</strong>的时候, 需要先创建一个<strong>CGAffineTransform</strong>类型的空值, 直接把<strong>CGAffineTransformIdentity</strong>赋值过去就好了, 这个称为单位矩阵.<br/>
<dr/><br/>
如果你需要把两个已经写好的<strong>transform</strong>合成为一个的话, 你可以使用系统提供的<strong>API</strong>:</p>
</blockquote>

<pre><code class="language-objectivec">CGAffineTransformConcat(CGAffineTransform t1, CGAffineTransform t2);
</code></pre>

<blockquote>
<p>不说那么多废话了, 直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewCombiningTransforms {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    CGAffineTransform transform = CGAffineTransformIdentity;
    
    // 旋转
    transform = CGAffineTransformRotate(transform, M_PI_4);
    // 缩放
    transform = CGAffineTransformScale(transform, 0.5f, 0.5f);
    // 平移
    transform = CGAffineTransformTranslate(transform, 200, 0);
    
    imageView.layer.affineTransform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/3.png" alt="3"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/4.png" alt="4"/></p>

<blockquote>
<p>看到图片的时候, 你会发现结果好像和想象有些差异, 为什么会平移了那么多? 原因是在于当你按顺序做了<strong>transform</strong>, 上一个<strong>transform</strong>会影响到下一个<strong>transform</strong>, 所以平移之后, 你会发现同样被缩放和旋转了, 这就是意味着, 你在旋转之后的平移和平移之后的旋转讲会得到两种不同的结果, 这个大家需要注意一下.</p>
</blockquote>

<hr/>

<h3 id="toc_5">3D Transforms</h3>

<blockquote>
<p>在之前, 我们有提及过<strong>zPosition</strong>这个属性, 可以从用户角度的来让让图层远离或者是靠近,<strong>CATransform</strong>类型的<strong>transform</strong>可以真正做到让图层在<strong>3D</strong>空间内平移或者旋转.<br/>
<dr/><br/>
和<strong>CGAffineTransform</strong>类似,<strong>CATransform3D</strong>也是一个矩阵, 但和之间所说的<strong>2x3</strong>矩阵不一样,<strong>CATransform3D</strong>是一个可以在3D空间内做变换的<strong>4x4</strong>矩阵.<br/>
<dr/><br/>
和<strong>CGAffineTransform</strong>矩阵类似, <strong>Core Animation</strong>也提供了一系列的使用方法, 用来创建和组合<strong>CATransform3D</strong>矩阵, 于<strong>Core Graphics</strong>的函数相比, 也只是在<strong>3D</strong>的平移和旋转中多出了一个<strong>z</strong>参数, 而旋转的API除了有angle参数之外, 还多出了<strong>x</strong>, <strong>y</strong>, <strong>z</strong>等三个参数, 分别决定了每个坐标轴方向上的旋转, 比如:</p>
</blockquote>

<pre><code class="language-objectivec">
CATransform3DMakeRotation(CGFloat angle, CGFloat x, CGFloat y, CGFloat z);
CATransform3DMakeScale(CGFloat sx, CGFloat sy, CGFloat sz);
CATransform3DMakeTranslation(Gloat tx, CGFloat ty, CGFloat tz);
</code></pre>

<blockquote>
<p>在之前的文章里, 我们都应该了解了在<strong>iOS</strong>当中, 原点<strong>{0, 0}</strong>是在左上角, <strong>x</strong>轴正方向为右边, <strong>y</strong>轴正方向为下边, 在<strong>Mac OS</strong>当中则是和<strong>iOS</strong>相反, 但是<strong>Z</strong>轴呢, 则是分别和<strong>x</strong>, <strong>y</strong>轴分别垂直, 指向视角外为正方向, 说那么多, 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewTransforms3D {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];

    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/5.png" alt="5"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/6.png" alt="6"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/7.png" alt="7"/></p>

<h4 id="toc_6">Perspective Projection</h4>

<blockquote>
<p>所谓的<strong>Perspective Projection</strong>就是透视投影, 这里需要普及一些知识(虽然我也看不太懂).<br/>
<dr/><br/>
在现实生活中, 当物体远离我们的时候, 会由于视角的问题, 物体看起来会变小, 理论上说远离我们的视图边要比靠近视角边更短, 但实际上, 我们的视角是等距离的, 也就是在<strong>3D Transform</strong>中仍然保持平行, 和之前提到的仿射变换有些类似.<br/>
<dr/><br/>
所以为了做一些修正, 我们需要引入<strong>投影变换</strong>, 又称为<strong>z变换</strong>, 来对一些做了变换的矩阵做一些修改, 旋转的除外, <strong>Core Animation</strong>, 当中并没有给我们提供直接设置透视变换的函数, 所以我们需要手动去修改矩阵值, 但很庆幸的是, 这个修改是很简单的, 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewPerspectiveProjection {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
    
    CATransform3D transform = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform;
    
    CATransform3D transform3DIdentity = CATransform3DIdentity;
    transform3DIdentity.m34 = - 1.0 / 500.0;
    transform3DIdentity = CATransform3DRotate(transform3DIdentity, M_PI_4, 0, 1, 0);
    imageView.layer.transform = transform3DIdentity;
}
</code></pre>

<blockquote>
<p>在<strong>CATransform3D</strong>中, 有一个<strong>m34</strong>的元素, 它是用于按比例来缩放<strong>X</strong>和<strong>Y</strong>的值, 从而来计算离视角的距离.<br/>
<dr/><br/>
<strong>m34</strong>的默认值为0, 我们可以通过设置<strong>m34</strong>来应用透视效果, 公式是<strong>-1.0/d</strong>, <strong>d</strong>代表了想象中视角相机和屏幕之间的距离, 以像素为单位, 通常设置<strong>500-1000</strong>之间, 但是对于一些特殊视图, 设置的值要小一些, 或者大一些要比<strong>500-1000</strong>要好一些, 所以这些值并不是固定的, 最好是根据需求来调节, 不然会出现湿疹, 或者是失去透视效果.</p>
</blockquote>

<h4 id="toc_7">The Vanishing Point</h4>

<blockquote>
<p><strong>The Vanishing Point</strong>翻译过来叫做<strong>消失点</strong>, 意思是当在透视角度绘图时, 原理视觉角度的物体将会变小变远, 远离到一个极限的时候, 所有物体最后都会汇聚并且消失在同一个点.<br/>
<dr/><br/>
在现实生活中, 这个点通常都是视图的中心, 如果要在应用中创建拟真效果的透视, 这个点一般是在屏幕的重点, 至少是所有3D对象的视图中点.<br/>
<dr/><br/>
在<strong>Core Animation</strong>中, 这个点是位于变换图层的<strong>anchorPoint</strong>(当然也有一些特殊的情况), 也就是说, 当图层发生变换的时候, 这个点永远位于图层变换钱的<strong>anchorPoint</strong>位置.<br/>
<dr/><br/>
当我们改变一个图层的<strong>position</strong>时, 也同时改变了它的消失点, 所以在我们做3D变换的时候要记住.<br/>
<dr/><br/>
当我们去调整视图的<strong>m34</strong>来让视图更加有3D效果, 通常要把它放置在屏幕的中央, 然后通过平移来把它移动到指定的位置, 这样子做, 就可以让所有的3D图层都有同一个消失点.</p>
</blockquote>

<h4 id="toc_8">Sublayer Transform</h4>

<blockquote>
<p>如果在开发中, 我们有多个视图或者多个图层, 而且他们都要做3D变换, 那我们就要对这些视图或者图层每个都设置相同的<strong>m34</strong>值, 并且还要确保在变换钱都在屏幕中央都有一个相同的<strong>position</strong>, 当然, 我们可以自己封装一下, 但这样子也非常的蛋疼, 那该怎么做呢?<br/>
<dr/><br/>
在<strong>CALayer</strong>中有一个属性叫做<strong>sublayerTransform</strong>, 它也是<strong>CATransform3D</strong>类型, 但和我们一个一个的去设置图层不同, 它将会影响所有的子图层, 这就是说明了, 我们只要使用<strong>sublayerTransform</strong>, 就可以一次性的把所有子图层都改变.<br/>
<dr/><br/>
这也可以提供另一个好处, 就是当我们使用<strong>sublayerTransform</strong>属性时, 我们就不需要再对子图层挨个挨个的去设置消失点, 因为消失点将会被设置在容器图层的中心点, 那我们就可以随意设置<strong>position</strong>和<strong>frame</strong>来放置子图层, 还是直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewSublayerTransform {
    
    UIImageView *imageViewOne = [[UIImageView alloc] initWithFrame:CGRectMake(80, 100, 100, 100)];
    
    imageViewOne.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    UIImageView *imageViewTwo = [[UIImageView alloc] initWithFrame:CGRectMake(250, 100, 100, 100)];
    
    imageViewTwo.image = [UIImage imageNamed:@&quot;expression&quot;];

    [self.view addSubview:imageViewOne];
    [self.view addSubview:imageViewTwo];
    
    CATransform3D perspective = CATransform3DIdentity; perspective.m34 = - 1.0 / 500.0;
    
    self.view.layer.sublayerTransform = perspective;
    
    CATransform3D transform1 = CATransform3DMakeRotation(M_PI_4, 0, 1, 0);
    
    imageViewOne.layer.transform = transform1;
    
    CATransform3D transform2 = CATransform3DMakeRotation(-M_PI_4, 0, 1, 0);
    
    imageViewTwo.layer.transform = transform2;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/8.png" alt="8"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/9.png" alt="9"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/10.png" alt="10"/></p>

<h4 id="toc_9">Backfaces</h4>

<blockquote>
<p>我们既然可以在3D场景下旋转图层, 当然也可以从背面去观察它, 比如我们把翻转的角度设置为<strong>M_PI</strong>, 那么就会显示一个镜像的图层, 我们来看看代码:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewBackfaces {
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [self.view addSubview:imageView];
        
    CATransform3D transform3DIdentity = CATransform3DIdentity;
    transform3DIdentity.m34 = - 1.0 / 500.0;
    transform3DIdentity = CATransform3DRotate(transform3DIdentity, M_PI, 0, 1, 0);
    imageView.layer.transform = transform3DIdentity;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/11.png" alt="11"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/12.png" alt="12"/></p>

<h4 id="toc_10">Layer Flattening</h4>

<blockquote>
<p>有人会问, 如果我们对已经做过变换的图层做反方向的会发生啥事?<br/>
<dr/><br/>
在理论上来讲, 我们如果对内部图层做了一个-45度的旋转, 如果要恢复正常, 则要做相反的变换, 才能相互抵消, 为了验证一下, 我们先试试:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewLayerFlattening {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 200, 200)];
    view.backgroundColor = [UIColor blueColor];
    
    [self.view addSubview:view];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [view addSubview:imageView];
    
    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);
    view.layer.transform = outer;
    
    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);
    imageView.layer.transform = inner;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/13.png" alt="13"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/14.png" alt="14"/></p>

<blockquote>
<p>看结果, 和我们想象的一样, 再试试再3D变化的情况下能不能抵消, 继续看代码:</p>
</blockquote>

<pre><code class="language-objectivec">    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 200, 200)];
    view.backgroundColor = [UIColor blueColor];
    
    [self.view addSubview:view];
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;expression&quot;];
    
    [view addSubview:imageView];
    
//    CATransform3D outer = CATransform3DMakeRotation(M_PI_4, 0, 0, 1);
//    view.layer.transform = outer;
//    
//    CATransform3D inner = CATransform3DMakeRotation(-M_PI_4, 0, 0, 1);
//    imageView.layer.transform = inner;
    
    // 3D Trans
    CATransform3D outer = CATransform3DIdentity; outer.m34 = -1.0 / 500.0;
    outer = CATransform3DRotate(outer, M_PI_4, 0, 1, 0); view.layer.transform = outer;
    
    CATransform3D inner = CATransform3DIdentity; inner.m34 = -1.0 / 500.0;
    inner = CATransform3DRotate(inner, -M_PI_4, 0, 1, 0); imageView.layer.transform = inner;
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/15.png" alt="15"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/16.png" alt="16"/></p>

<blockquote>
<p>这里我并没有使用<strong>sublayerTransform</strong>属性, 因为这里面的图层并不是容器图层直接的子图层, 所以这里分别对图层设置了<strong>Perspective Projection</strong>.<br/>
<dr/><br/>
结果也是和我们所预期的不太一样, 虽然按道理来讲是显示正常的方块, 但实际上并不是的.<br/>
<dr/><br/>
在<strong>Core Animation</strong>当中, 3D图层存在于3D空间之内, 但它们并不是存在同一个, 其实每一个图层的3D场景都是扁平化的, 当我们正面观察一个图层时, 看到的图层其实是由子图层创建的3D场景, 当你倾斜这个图层时, 会发现这个3D场景只是被绘制在图层的表面罢了.<br/>
<dr/><br/>
总之一句话说完, 用<strong>Core Animation</strong>创建非常负责的3D场景是很蛋疼的, 因为我们不能直接创建一个个图层的去套, 然后构建成一个3D结构的图层关系, 刚刚也说了, 在相同场景下任何3D表面必须和同样的图层保持一致, 这是因为每一个父视图都把它的子视图扁平化了.<br/>
<dr/><br/>
那这个有办法解决吗? 当然有, 使用<strong>CALayer</strong>就可以啦, 在<strong>CALayer</strong>中, 有一个叫做<strong>CATransformLayer</strong>的子类就可以解决这个问题, 这个后面再说吧.</p>
</blockquote>

<hr/>

<h3 id="toc_11">Solid Objects</h3>

<blockquote>
<p><strong>Solid Objects</strong>翻译过来就叫做固体对象, 前面我们懂得了一丢丢的3D空间图层布局, 现在我们尝试着来创建一个固态的3D对象(也就是我们所谓的骰子), 直接来看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewSolidObjects {
    
    CATransform3D perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;

    perspective = CATransform3DRotate(perspective, -M_PI_4, 1, 0, 0);
    perspective = CATransform3DRotate(perspective, -M_PI_4, 0, 1, 0);

    self.view.layer.sublayerTransform = perspective;
    
    CATransform3D transform = CATransform3DMakeTranslation(0, 0, 100);

    for (NSInteger i = 0; i &lt; 6; i++) {
        
        UILabel *label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
        
        label.backgroundColor = [UIColor whiteColor];
        label.textColor = [UIColor redColor];
        label.layer.borderColor = [UIColor blackColor].CGColor;
        label.layer.borderWidth = 0.5;
        label.tag = i;
        label.text = [NSString stringWithFormat:@&quot;%ld&quot;, i + 1];
        label.font = [UIFont systemFontOfSize:30];
        label.textAlignment = NSTextAlignmentCenter;
        
        switch (label.tag) {
            case 0: {
                
                [self addLabel:label withTransform:transform];
            }
                break;
            case 1: {
                transform = CATransform3DMakeTranslation(100, 0, 0);
                transform = CATransform3DRotate(transform, M_PI_2, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 2: {
                transform = CATransform3DMakeTranslation(0, -100, 0);
                transform = CATransform3DRotate(transform, M_PI_2, 1, 0, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 3: {
                transform = CATransform3DMakeTranslation(0, 100, 0);
                transform = CATransform3DRotate(transform, -M_PI_2, 1, 0, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 4: {
                transform = CATransform3DMakeTranslation(-100, 0, 0);
                transform = CATransform3DRotate(transform, -M_PI_2, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            case 5: {
                transform = CATransform3DMakeTranslation(0, 0, -100);
                transform = CATransform3DRotate(transform, M_PI, 0, 1, 0);
                [self addLabel:label withTransform:transform];
            }
                break;
            default:
                break;
        }
    }
}

- (void)addLabel:(UILabel *)label withTransform:(CATransform3D)transform {
    
    [self.view addSubview:label];
    
    CGSize containerSize = self.view.bounds.size;
    label.center = CGPointMake(containerSize.width / 2.0, containerSize.height / 2.0);
    label.layer.transform = transform;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/17.png" alt="17"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/18.png" alt="18"/></p>

<h4 id="toc_12">Light and Shadow</h4>

<blockquote>
<p>刚刚我们弄了一个看上去像是立方体的, 但是它们之前的每一个面之间的连接压根就分辨不出, 虽然在<strong>Core Animation</strong>可以用3D显示图层, 但它并没有光线的概念, 如果要让这个立方体看起来更加的真实, 那我们就要手动给它加个阴影效果, 这个就根据自己的需求来看了.<br/>
<dr/><br/>
这里我们简单的来看看事例: </p>
</blockquote>

<pre><code class="language-objectivec">- (void)addLightingToLabel:(CALayer *)labelLayer {
    
    CALayer *layer = [CALayer layer];
    layer.frame = labelLayer.bounds;
    
    [labelLayer addSublayer:layer];
    
    CATransform3D transform = labelLayer.transform;
    
    GLKMatrix4 matrix4 = [self matrixFrom3DTransformation:transform];
    GLKMatrix3 matrix3 = GLKMatrix4GetMatrix3(matrix4);
    
    GLKVector3 normal = GLKVector3Make(0, 0, 1);
    normal = GLKMatrix3MultiplyVector3(matrix3, normal);
    normal = GLKVector3Normalize(normal);
    
    GLKVector3 light = GLKVector3Normalize(GLKVector3Make(LIGHT_DIRECTION));
    CGFloat dotProduct = GLKVector3DotProduct(normal, light);
    
    CGFloat shadow = 1 + dotProduct - AMBIENT_LIGHT;
    UIColor *color = [UIColor colorWithWhite:0 alpha:shadow];
    
    layer.backgroundColor = color.CGColor;
}

- (GLKMatrix4)matrixFrom3DTransformation:(CATransform3D)transform {
    GLKMatrix4 matrix = GLKMatrix4Make(transform.m11, transform.m12, transform.m13, transform.m14,
                                       transform.m21, transform.m22, transform.m23, transform.m24,
                                       transform.m31, transform.m32, transform.m33, transform.m34,
                                       transform.m41, transform.m42, transform.m43, transform.m44);
    
    return matrix;
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/19.png" alt="19"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/5.Transforms/images/20.png" alt="20"/></p>

<h4 id="toc_13">Touch Events</h4>

<blockquote>
<p>虽然说我们现在用的是<strong>UILabel</strong>, 如果我们把3, 4, 5, 6换成<strong>UIButton</strong>和<strong>UIView</strong>的组合, 那4, 5, 6点击按钮是无法触发点击事件的.<br/>
<dr/><br/>
这是因为由于视图的顺序, 在之前我们就说过, 点击事件的处理是由视图再父视图中的顺序决定的, 并不是在<strong>3D空间</strong>的<strong>Z轴顺序</strong>上.<br/>
<dr/><br/>
但在这个例子当中, 我们的视图的确是按照顺序来添加的, 那为什么把4, 5, 6换成<strong>UIButton</strong>和<strong>UIView</strong>之后就无法处理点击事件了呢? 那是因为被前面的三个视图挡住了, 在表面上截断了4, 5, 6的点击事件, 这个是和普通的2D布局在按钮上覆盖物体是一样的.<br/>
<dr/><br/>
我们可以把除了3视图之外的视图<strong>userInteractionEnabled</strong>属性都设置成<strong>NO</strong>, 这样子就可以禁止事件传递, 或者通过简单的代码, 把<strong>视图3</strong>覆盖在<strong>视图6</strong>上, 那这样子无论你如何点, 都可以点击到按钮了.</p>
</blockquote>

<hr/>

<h3 id="toc_14">总结</h3>

<blockquote>
<p>总结一下:<br/>
* AffineTransforms的使用<br/>
* AffineTransforms的混合变换<br/>
* 3D Transforms的Perspective Projection<br/>
* 3D Transforms的The Vanishing Point<br/>
* 3D Transforms的Sublayer Transform<br/>
* 3D Transforms的Backfaces<br/>
* 3D Transforms的Layer Flattening<br/>
* 最后再来一丢丢的Solid Objects</p>
</blockquote>

<hr/>

<h3 id="toc_15">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_16">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：4.《Core Animation》CALayer的视觉效果]]></title>
    <link href="https://cainrun.github.io/14775511877452.html"/>
    <updated>2016-10-27T14:53:07+08:00</updated>
    <id>https://cainrun.github.io/14775511877452.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前一章我们对<strong>CALayer</strong>了解的更加深入了一些<a href="https://cainrun.github.io/14773198375857.html">《Core Animation》CALayer的几何图层</a>今天我们就来讲讲<strong>CALayer Visual Effects</strong>, 也就是<strong>CALayer</strong>的视觉效果.</p>

<p><dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>CALayer Visual Effects</strong>讲得是<strong>CALayer</strong>一些我们能够看得见的东西, 这些知识点在我们日常开发中也会有用到的, 比如<strong>Rounded Corners</strong>, <strong>Layer Borders</strong>, <strong>Drop Shadows</strong>, <strong>Layer Masking</strong>, <strong>Scaling Filters</strong>, <strong>Group Opacity</strong>等等, 待我们一一去讲解.</p>
</blockquote>

<hr/>

<h3 id="toc_2">Rounded Corners</h3>

<blockquote>
<p><strong>Rounded Corners</strong>这个东西我们用的其实也是挺多的, 我们都知道, 在<strong>iOS 7</strong>之前, 基本上所有的<strong>Button</strong>都是椭圆形的, 而这些<strong>Button</strong>之所以都是椭圆形, 大多数都是因为<strong>Rounded Corners</strong>这个东西的原因.<br/>
<dr/><br/>
在<strong>CALayer</strong>有一个叫<strong>conrnerRadius</strong>的CGFloat类型属性来控制着图层角的曲率, 默认值为0, 你可以设置任意数值, 是的图层角显示不一样的曲率, 而且<strong>conrnerRadius</strong>这个属性所影响的到的只有设置该属性的<strong>CALayer</strong>, 并不会影响到子图层或者是背景图, 但如果你要让子图层或者是背景图也要跟着该<strong>CALayer</strong>进行曲率处理, 你可以把<strong>masksToBounds</strong>设置为<strong>YES</strong>, 这样子就可以满足你的需求了.<br/>
<dr/><br/>
我们直接来看看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerRoundedCorners {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor redColor];
    view.layer.cornerRadius = 50.f;
    view.layer.masksToBounds = YES;
    
    CALayer *layer = [CALayer layer];
    
    layer.backgroundColor = [UIColor blueColor].CGColor;
    layer.frame = CGRectMake(50, 50, 50, 50);
    
    [view.layer addSublayer:layer];
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/2.png" alt="2"/></p>

<blockquote>
<p><strong><font color=red>PS: 这里需要注意一点, 由于</strong>masksToBounds<strong>和</strong>conrnerRadius<strong>这两个属性同时使用是挺消耗性能的, 如果你是要大面积的去使用, 会造成卡顿现象, 比如说在</strong>UICollectionView<strong>或者是</strong>UITableView<strong>上使用.</font></strong></p>
</blockquote>

<hr/>

<h3 id="toc_3">Layer Borders</h3>

<blockquote>
<p><strong>CALayer</strong>还有两个更好玩的属性, 这也是在<strong>iOS 7</strong>之前<strong>Button</strong>会默认实现的两个属性, 一个叫做<strong>borderWidth</strong>, 一个叫做<strong>borderColor</strong>.<br/>
<dr/></p>

<ul>
<li><strong>borderWidth</strong>: 这是一个<strong>CGFloat</strong>类型的属性, 是用来设置<strong>CALayer</strong>边框宽度, 默认值是为0.</li>
<li><strong>borderColor</strong>: 这是一个<strong>CGColorRef</strong>类型的属性, 所以你不能给它直接设置一个<strong>UIColor</strong>对象, 前面我们已经对<strong>CGColorRef</strong>这个东东进行了简单的介绍, 这里我们只需要知道直接给它赋个值就好了, 还有就是<strong>borderColor</strong>是用来设置<strong>CALayer</strong>边框颜色, 在<strong>iOS 7</strong>之前默认值是为黑色, <strong>iOS 7</strong>之后默认值是为透明.</li>
</ul>

<p><dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerBorders {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor blueColor];
    view.layer.borderWidth = 5.f;
    view.layer.borderColor = [UIColor redColor].CGColor;
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/3.png" alt="3"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_4">Drop Shadows</h3>

<blockquote>
<p>在<strong>iOS</strong>当中, 还有一个特性, 叫做<strong>Drop Shadows(阴影)</strong>, 其实这个也不算是<strong>iOS</strong>特有的, 毕竟在<strong>Mac OS</strong>里早就已经有这个特性了.<br/>
<dr/><br/>
阴影往往是起暗示作用, 比如说你现在正在显示的窗口, 周边就会带上阴影, 或者是强调里面的某个图层的优先级, 大多数时候只是用来装饰罢了.<br/>
<dr/><br/>
设置阴影的时候也是很简单, 直接给<strong>shadowOpacity</strong>属性设置一个大于<strong>0.0</strong>的值就好了, <strong>shadowOpacity</strong>这个属性可设置的值是在<strong>0.0~1.0</strong>之间, 默认是<strong>0.f</strong>, 最大值是<strong>1.f</strong>, 如果直接设置为<strong>1.f</strong>, 那么将会显示一个轻微模糊的黑色阴影在图层的上方, 另外, 你可以通过<strong>CALayer</strong>所提供的<strong>shadowColor</strong>, <strong>shadowOffset</strong>, <strong>shadowRadius</strong>对阴影进行一些额外的操作, 这里就不一一介绍了, 各位童鞋们可以自行尝试一下~<br/>
<dr/><br/>
说到这里, 会有人问, 为什么阴影是在图层的上方呢? 其实在之前我们就有了解过Mac OS和iOS的一些东西, 基本上iOS的一些东西都是从Mac OS搬过来, 然后再改改的, 包括这个阴影也是如此, 所以你才会看到在iOS当中阴影是反过来的, 这里我们只需要设置一下<strong>shadowOffset</strong>就可以正常显示了.<br/>
<dr/><br/>
直接看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerDropShadows {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor redColor];
    view.layer.shadowOpacity = 1.0f;
    view.layer.shadowOffset = CGSizeMake(0, 3);
    view.layer.shadowRadius = 10.f;
    view.layer.shadowColor = [UIColor blueColor].CGColor;
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/5.png" alt="5"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/6.png" alt="6"/></p>

<h4 id="toc_5">Shadow Clipping</h4>

<blockquote>
<p>这里还有一个比较好玩的东西, 就是阴影剪切, 我们都知道<strong>CALayer</strong>超出了<strong>UIView</strong>的范围, 如果要剪切掉的话, 只能用<strong>masksToBounds</strong>这个属性去剪切.<br/>
<dr/><br/>
但这样子会带来另一个的问题, 因为一旦使用<strong>masksToBounds</strong>这个属性, 剪切掉的就不只是多出来的部分, 会连阴影部分都一起剪切完, 为了防止阴影也跟着被剪切掉, 我们需要使用一个比较笨的方法, 就是再创建多一个<strong>CALayer</strong>, 让它去创建阴影部分, 另一个<strong>CALayer</strong>去剪切内容就可以了.<br/>
<dr/><br/>
我们还是直接看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerShadowClipping {
    
    UIView *contentView = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 100, 100)];
    UIView *blueView = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    UIView *shadowView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    contentView.backgroundColor = [UIColor grayColor];
    blueView.backgroundColor = [UIColor blueColor];
    
    contentView.layer.masksToBounds = YES;
    
    shadowView.layer.shadowOpacity = 1.0f;
    shadowView.layer.shadowOffset = CGSizeMake(0, 0.5f);
    shadowView.layer.shadowColor = [UIColor redColor].CGColor;

    [contentView addSubview:blueView];
    [shadowView addSubview:contentView];
    
    [self.view addSubview:shadowView];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/7.png" alt="7"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/8.png" alt="8"/></p>

<h4 id="toc_6">shadowPath</h4>

<blockquote>
<p>我们都知道其实阴影是没有形态的, 它是根据图层的形状来进行显示, 如果在一个视图当中有很多子图层, 然后要一个一个的去计算阴影的形状, 那是非常耗性能的, 但如果在开发之前你就已经知道阴影的形状, 那么你就可以提前设置好, 这样子就可以优化性能了, 而这个属性就是<strong>shadowPath</strong>, <br/>
<dr/><br/>
<strong>shadowPath</strong>是<strong>CGPathRef</strong>类型, 可以说是一个指向<strong>CGPath</strong>的指针, 而<strong>CGPath</strong>是一个<strong>Core Graphics</strong>对象, 可以用来任意描绘一个矢量图形, 我们也可以使用它来描绘阴影, 大大的提升性能.<br/>
<dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerShadowPath {
    
    UIView *shadowViewOne = [[UIView alloc] initWithFrame:CGRectMake(50, 50, 100, 100)];
    UIView *shadowViewTwo = [[UIView alloc] initWithFrame:CGRectMake(50, 250, 100, 100)];

    shadowViewOne.layer.shadowOpacity = 0.5f;
    shadowViewTwo.layer.shadowOpacity = 0.5f;
    
    CGMutablePathRef squarePath = CGPathCreateMutable();
    CGPathAddRect(squarePath, NULL, shadowViewOne.bounds);
    shadowViewOne.layer.shadowPath = squarePath;
    
    CGPathRelease(squarePath);
    
    CGMutablePathRef circlePath = CGPathCreateMutable();
    CGPathAddEllipseInRect(circlePath, NULL, shadowViewTwo.bounds);
    shadowViewTwo.layer.shadowPath = circlePath;
    
    CGPathRelease(circlePath);

    [self.view addSubview:shadowViewOne];
    [self.view addSubview:shadowViewTwo];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/9.png" alt="9"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/10.png" alt="10"/></p>

<hr/>

<h3 id="toc_7">Layer Masking</h3>

<blockquote>
<p>我们都知道如果我们要剪切超出范围的图层可以使用<strong>masksToBounds</strong>, 通过<strong>conrnerRadius</strong>可以设置图层为圆角, 但如果你需要设置一个不规整的图层时, 用上面的两个属性是没法实现的.<br/>
<dr/><br/>
虽然我们可以使用一个<strong>32位</strong>且带有<strong>alpha</strong>通道的<strong>png</strong>图片可以实现, 但这个方法也是有局限的, 不能以动态编码的形式生成蒙版, 也不能让子图层或者子视图也裁剪成同样的形状.<br/>
<dr/><br/>
苹果为了解决这个为题, 在<strong>CALayer</strong>当中提供了一个<strong>CGLayer</strong>类型, 名叫<strong>mask</strong>的属性, 有着和其他CALayer一样的布局属性, 它就像是一个子图层, 相对于父图层来进行布局的, 但它又区别于子图层, 它是定义父图层可见部分的.<br/>
<dr/><br/>
虽然<strong>mask</strong>里也有<strong>Color</strong>这个属性, 但它并没啥用, 真正重要的是图层的轮廓, 它就像是一台切割机一样, 实心图层部分会被保留, 其他的就会作为垃圾一样被抛弃.<br/>
<dr/><br/>
我们直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerMasking {
    
    UIImageView *imageView = [[UIImageView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    imageView.image = [UIImage imageNamed:@&quot;arrow&quot;];
    
    CALayer *maskLayer = [CALayer layer];
    UIImage *maskImage = [UIImage imageNamed:@&quot;star&quot;];
    
    maskLayer.frame = imageView.bounds;
    maskLayer.contents = (__bridge id _Nullable)(maskImage.CGImage);
    
    imageView.layer.mask = maskLayer;
    
    [self.view addSubview:imageView];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/11.png" alt="11"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/12.png" alt="12"/></p>

<hr/>

<h3 id="toc_8">Scaling Filters</h3>

<blockquote>
<p>这里我们提及一个点, 是关于图片显示的一个问题, 我们都知道如果要让一个<strong>CALayer</strong>显示一张图片是直接给它的<strong>contents</strong>直接设置内容, 但是呢, 这个图片是否正确的显示, 画质如何, 我们都无从而知.<br/>
<dr/><br/>
为了解决这个问题,<strong>CALayer</strong>分别提供了<strong>minificationFilter</strong>和<strong>magnificationFilter</strong>属性, 它们都是<strong>NSString</strong>类型, 说到这里, 有人会疑问, 直接显示不就是最好的么, 为啥要那么麻烦, 其实不一定的, 原因的话, 大概有三点吧:<br/>
<dr/></p>

<ul>
<li>能够显示最好的画质, 指的是像素没有被压缩也没有被拉伸.</li>
<li>可以节省资源, 比如神马内存, 存储之类的.</li>
<li>可以优化性能, 减轻CPU的压力.
<dr/></li>
</ul>

<p>打个比方, 比如我们开发的时候, 有个头像省略图, 这个时候呢, 你说是用全图比较好, 还是压缩过的比较好? 答案肯定是压缩过的比较好, 因为可以省资源.<br/>
<dr/><br/>
顺便说说, 这两个属性可设置的值分别是:</p>

<ul>
<li>kCAFilterLinear(默认值)</li>
<li>kCAFilterNearest</li>
<li>kCAFilterTrilinear
<dr/>
说那么多, 直接来看Demo吧:</li>
</ul>
</blockquote>

<pre><code class="language-objectivec">- (void)layerScalingFilters {
    
    UIImageView *imageViewOne = [[UIImageView alloc] initWithFrame:CGRectMake(0, 100, self.view.bounds.size.width / 2, 200)];
    UIImageView *imageViewTwo = [[UIImageView alloc] initWithFrame:CGRectMake(self.view.bounds.size.width / 2, 100, self.view.bounds.size.width / 2, 200)];
    UIImageView *imageViewThree = [[UIImageView alloc] initWithFrame:CGRectMake(0, 300, self.view.bounds.size.width / 2, 200)];
    
    imageViewOne.image = [UIImage imageNamed:@&quot;expression&quot;];
    imageViewTwo.image = [UIImage imageNamed:@&quot;expression&quot;];
    imageViewThree.image = [UIImage imageNamed:@&quot;expression&quot;];

    imageViewOne.layer.magnificationFilter = kCAFilterNearest;
    imageViewTwo.layer.magnificationFilter = kCAFilterLinear;
    imageViewThree.layer.magnificationFilter = kCAFilterTrilinear;

    imageViewOne.layer.minificationFilter = kCAFilterNearest;
    imageViewTwo.layer.minificationFilter = kCAFilterLinear;
    imageViewThree.layer.minificationFilter = kCAFilterTrilinear;
    
    [self.view addSubview:imageViewOne];
    [self.view addSubview:imageViewTwo];
    [self.view addSubview:imageViewThree];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/13.png" alt="13"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/4.VisualEffects/images/14.png" alt="14"/></p>

<blockquote>
<p>额...这个有些尴尬, 看起来的效果区别不太大...凑合着看吧..</p>
</blockquote>

<hr/>

<h3 id="toc_9">Group Opacity</h3>

<blockquote>
<p>最后, 我们来说说<strong>Group Opacity</strong>这个东西, 在<strong>iOS 7</strong>之前, 如果你在一个<strong>Button</strong>上添加一个视图, 在<strong>alpha</strong>设置为<strong>50%</strong>的情况下会出现图层有分割, 需要设置<strong>shouldRasterize</strong>和<strong>rasterizationScale</strong>两个属性才能使得在半透明的情况下看起来是一体, 但是这个问题在<strong>iOS 7</strong>之后就已经解决了, 现在<strong>shouldRasterize</strong>属性更多的是用来解决<strong>UITableView</strong>里的<strong>CALayer</strong>圆角显示图层的处理, 这里就不做多的解释了, 有兴趣的童鞋们可以去谷歌搜搜<strong>shouldRasterize</strong>的用法, 都是挺简单的~</p>
</blockquote>

<hr/>

<h3 id="toc_10">总结</h3>

<blockquote>
<p>总结一下, 这一章我们了解更多的是<strong>CALayer</strong>肉眼上能看到的东西, 比如:<br/>
<br/></p>

<ul>
<li><strong>Rounded Corners</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>圆角的处理.</li>
<li><strong>Layer Borders</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>边框的处理, 包括边框的厚度, 以及颜色等</li>
<li><strong>Drop Shadows</strong>: 在这个知识点里, 我们知道了<strong>CALayer</strong>阴影的处理.</li>
<li><strong>Layer Masking</strong>: 在这个知识点里, 我们了解了<strong>CALayer</strong>可以作为一个<strong>mask</strong>去使用, 并且可以显示不同不规则的形状.</li>
<li><strong>Scaling Filters</strong>: 在这个知识点里, 我们知道<strong>CALayer</strong>可以更改显示的画质, 优化显示的资源等等.</li>
<li><strong>Group Opacity</strong>: 在这个知识点里, 虽然在<strong>iOS 7</strong>之后已经解决了这个问题, 但我们也可以把<strong>shouldRasterize</strong>属性运用在其他的地方.</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_11">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_12">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：3.《Core Animation》CALayer的几何图层]]></title>
    <link href="https://cainrun.github.io/14773198375857.html"/>
    <updated>2016-10-24T22:37:17+08:00</updated>
    <id>https://cainrun.github.io/14773198375857.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前一章我们了解真正了<strong>CALayer</strong>是干嘛的, <a href="https://cainrun.github.io/14771496782021.html">《Core Animation》初识CALayer</a>今天我们就来讲讲<strong>CALayer Geometry</strong>.<br/>
<dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong>CALayer Geometry</strong>讲得是图层的几何, 主要内容分别有<strong>Layout</strong>, <strong>anchorPoint</strong>, <strong>Coordinate Systems</strong>, <strong>Hit Testing</strong>, <strong>Automatic Layout</strong>, 待我们一一去了解和学习~</p>
</blockquote>

<hr/>

<h3 id="toc_2">Layout</h3>

<blockquote>
<p><strong>Layout</strong>顾名思义就是布局的意思, 这一段讲的是视图和图层简单的布局, 比如<strong>UIView</strong>里面有<strong>frame</strong>, <strong>bounds</strong>, <strong>center</strong>, <strong>CALayer</strong>里面有<strong>frame</strong>, <strong>bounds</strong>, <strong>position</strong>.<br/>
<dr/><br/>
这里对布局属性进行一下解释: <br/>
<dr/></p>

<ul>
<li><strong>frame</strong>: 代表了的是图层外部的一个坐标轴, 也是相对于父视图.</li>
<li><strong>bounds</strong>: 代表了的是内部坐标轴, 它的原点永远都是<strong>{0, 0}</strong>, 是相对于本视图的位置和大小.</li>
<li><strong>center</strong>以及<strong>position</strong>: 代表的是现对于父视图所在的位置, 也就是我们经常所说的中心点, 但是呢, 其实这个说法不太对, 其实是应该相对于父视图<strong>anchorPoint</strong>属性所在的位置才对,<strong>anchorPoint</strong>属性我们后面再解释, 现在让它打一下酱油先.</li>
</ul>

<p>我们来看看Demo中的实例:</p>
</blockquote>

<pre><code class="language-objectivec">
- (void)viewDidLoad {
    [super viewDidLoad];
    
    [self logViewAndLayer];
}

- (void)logViewAndLayer {

    NSLog(@&quot;View X: %f&quot;, self.view.center.x);
    NSLog(@&quot;View Y: %f&quot;, self.view.center.y);
    NSLog(@&quot;View Frame Width: %f&quot;, self.view.frame.size.width);
    NSLog(@&quot;View Frame Height: %f&quot;, self.view.frame.size.height);
    NSLog(@&quot;View Bounds Width: %f&quot;, self.view.bounds.size.width);
    NSLog(@&quot;View Bounds Height: %f&quot;, self.view.bounds.size.height);
    NSLog(@&quot;\n&quot;);
    NSLog(@&quot;Layer X: %f&quot;, self.view.layer.position.x);
    NSLog(@&quot;Layer Y: %f&quot;, self.view.layer.position.y);
    NSLog(@&quot;Layer Frame Width: %f&quot;, self.view.layer.frame.size.width);
    NSLog(@&quot;Layer Frame Height: %f&quot;, self.view.layer.frame.size.height);
    NSLog(@&quot;Layer Bounds Width: %f&quot;, self.view.layer.bounds.size.width);
    NSLog(@&quot;Layer Bounds Height: %f&quot;, self.view.layer.bounds.size.height);
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/1.png" alt="1"/></p>

<blockquote>
<p>在这里, 我们看到<strong>layer</strong>的<strong>frame</strong>, <strong>bounds</strong>, <strong>position</strong>和<strong>UIView</strong>的<strong>frame</strong>, <strong>bounds</strong>, <strong>center</strong>都是一致的.<br/>
<dr/><br/>
但是在<strong>UIView</strong>里, <strong>frame</strong>, <strong>bounds</strong>, <strong>center</strong>这三个属性只是存取方法罢了, 当<strong>UIView</strong>对<strong>frame</strong>属性进行操作时, 其实是对<strong>CALayer</strong>的<strong>frame</strong>进行操作, 是不能够脱离了<strong>CALayer</strong>的去改变视图的<strong>frame</strong>.<br/>
<dr/><br/>
<strong>frame</strong>这个属性对于<strong>UIView</strong>和<strong>CALayer</strong>来说, 它是一个比较玄的属性, 它的值是根据<strong>UIView</strong>或者是<strong>CALayer</strong>的<strong>bounds</strong>, <strong>center</strong>/<strong>position</strong>, <strong>transform</strong>计算所得到的一个值, 一旦你去改变了<strong>bounds</strong>, <strong>center</strong>/<strong>position</strong>, <strong>transform</strong>其中一个值, <strong>frame</strong>也会随之而改变, 当然啦, 你去改变<strong>frame</strong>, <strong>bounds</strong>, <strong>center</strong>/<strong>position</strong>, <strong>transform</strong>这三个值也会跟着改变的.<br/>
<dr/><br/>
<strong><font color=red>PS: 这里还需要提一点, 如果你对</strong>CALayer<strong>进行了</strong>transform<strong>的旋转或者是缩放时,</strong> frame<strong>所显示的宽高与</strong>bounds<strong>的宽高就不会再一样了.</font></strong></p>

<p>直接来看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerTransform {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(20, 20, 100, 100)];
    
    view.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:view];
    
    view.layer.transform = CATransform3DMakeRotation(M_PI_4, 1, 1, 0.5);
    
    NSLog(@&quot;View X: %f&quot;, view.center.x);
    NSLog(@&quot;View Y: %f&quot;, view.center.y);
    NSLog(@&quot;View Frame Width: %f&quot;, view.frame.size.width);
    NSLog(@&quot;View Frame Height: %f&quot;, view.frame.size.height);
    NSLog(@&quot;View Bounds Width: %f&quot;, view.bounds.size.width);
    NSLog(@&quot;View Bounds Height: %f&quot;, view.bounds.size.height);
    NSLog(@&quot;\n&quot;);
    NSLog(@&quot;Layer X: %f&quot;, view.layer.position.x);
    NSLog(@&quot;Layer Y: %f&quot;, view.layer.position.y);
    NSLog(@&quot;Layer Frame Width: %f&quot;, view.layer.frame.size.width);
    NSLog(@&quot;Layer Frame Height: %f&quot;, view.layer.frame.size.height);
    NSLog(@&quot;Layer Bounds Width: %f&quot;, view.layer.bounds.size.width);
    NSLog(@&quot;Layer Bounds Height: %f&quot;, view.layer.bounds.size.height);
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/2.png" alt="2"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_3">AnchorPoint</h3>

<blockquote>
<p><strong>anchorPoint</strong>这个属性名, 也叫作<strong>锚点</strong>, 指的一个<strong>UIView</strong>和<strong>CALayer</strong>相对于父视图的位置参考点, 左上角为<strong>{0, 0}</strong>, 居中为<strong>{0.5, 0.5}</strong>, 右下角为<strong>{1, 1}</strong>, 默认都是位于父视图层的中点, 也就是<strong>{0.5, 0.5}</strong>.<br/>
<dr/><br/>
在<strong>UIView</strong>当中, <strong>anchorPoint</strong>属性并没有公开出来, 你只能操作<strong>center</strong>这个值, 间接性的给<strong>anchorPoint</strong>赋值, <strong>CALayer</strong>也可以通过改变<strong>position</strong>来给<strong>anchorPoint</strong>进行赋值, 从而改变<strong>CALayer</strong>的<strong>frame</strong>.<br/>
<dr/><br/>
这里还需要提及一点, 如果你改变了<strong>CALayer</strong>的<strong>anchorPoint</strong>, 那么<strong>CALayer</strong>的<strong>frame</strong>也会被改变, 那么<strong>anchorPoint</strong>属性所显示的值再也不是该<strong>CALayer</strong>的中心点, 但<strong>bounds</strong>,<strong>position</strong>这些值并不会被改变.</p>

<p>我们直接来看看Demo吧~</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewAnchorPoint {
    
    UIView *viewOne = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];

    viewOne.backgroundColor = [UIColor grayColor];

    NSLog(@&quot;before X: %f&quot;, viewOne.layer.frame.origin.x);
    NSLog(@&quot;before Y: %f&quot;, viewOne.layer.frame.origin.y);
    
    // change anchorPoint
    viewOne.layer.anchorPoint = CGPointMake(0.1f, 0.1f);

    NSLog(@&quot;After X: %f&quot;, viewOne.layer.frame.origin.x);
    NSLog(@&quot;After Y:%f&quot;, viewOne.layer.frame.origin.y);
    
    UIView *viewTwo = [[UIView alloc] init];
    
    viewTwo.backgroundColor = [UIColor redColor];
    viewTwo.bounds = CGRectMake(0, 0, 100, 100);
    viewTwo.center = viewOne.center;

    [self.view addSubview:viewOne];
    [self.view addSubview:viewTwo];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/4.png" alt="4"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/5.png" alt="5"/></p>

<blockquote>
<p>一般来讲, 能够用到<strong>anchorPoint</strong>属性的场景, 大多数都是在与图层叠加方面, 不然基本布局就已经够用了, 当然, 这只是在简单页面的基础上来讲而已, 还是看个人需求吧.</p>
</blockquote>

<hr/>

<h3 id="toc_4">Coordinate Systems</h3>

<blockquote>
<p><strong>Coordinate Systems</strong>也叫作坐标系, 和<strong>UIView</strong>一样,<strong>CALayer</strong>也是相对于父图层并且按照层级关系来摆放, 如果父图层的位置发生了变化, 那么子图层也会随之而改变.<br/>
<dr/><br/>
但某些情况下, 你想要知道这个图层的绝对位置, 或者是相对于另一个图层的位置时, 你就可以使用CALayer所提供的几个API进行处理了:</p>
</blockquote>

<pre><code class="language-objectivec">    - (CGPoint)convertPoint:(CGPoint)point toView:(nullable UIView *)view;
    - (CGPoint)convertPoint:(CGPoint)point fromView:(nullable UIView *)view;
    - (CGRect)convertRect:(CGRect)rect toView:(nullable UIView *)view;
    - (CGRect)convertRect:(CGRect)rect fromView:(nullable UIView *)view;
</code></pre>

<blockquote>
<p>这些方法，可以采取任何一层的坐标系中所定义的点或矩形，并将其转换到另一个坐标系。</p>
</blockquote>

<h4 id="toc_5">翻转CALayer的几何图层</h4>

<blockquote>
<p>这里再普及一个概念, 我们都知道在<strong>iOS</strong>当中<strong>CALayer</strong>的<strong>position</strong>是在父图层的左上角, 但在<strong>Mac OS</strong>当中, 一般来说是在左下角, 而<strong>Core Animation</strong>为了解决这个问题, 提供了一个<strong>BOOL</strong>属性<strong>geometryFlipped</strong>来适配这两种情况, 它决定了一个图层的坐标是否相对于父图层且垂直翻转, 如果在<strong>iOS</strong>上把<strong>geometryFlipped</strong>设置为<strong>YES</strong>的话, 那么图层的排版就会沿着底部来排版, 而不是我们通常所看到的那样, 包括它的子图层也是如此, 除非你再把子图层里的<strong>geometryFlipped</strong>属性设置为<strong>YES</strong>.</p>

<p>直接看Demo吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)layerGeometryFlipped {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    view.backgroundColor = [UIColor blueColor];
    view.layer.geometryFlipped = YES;
    
    CALayer *layer = [CALayer layer];
    
    layer.frame = CGRectMake(0, 0, 25, 25);
    layer.backgroundColor = [UIColor redColor].CGColor;
    
    [view.layer addSublayer:layer];
    
    [self.view addSubview:view];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/6.png" alt="6"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/7.png" alt="7"/></p>

<h4 id="toc_6">Z坐标轴</h4>

<blockquote>
<p>其实<strong>CALayer</strong>除了有<strong>UIView</strong>常规的二维坐标轴之外, 还有一个<strong>Z坐标轴</strong>, 也就是说<strong>CALayer</strong>存在于三维空间当中.<br/>
<dr/><br/>
除了我们之前接触过的<strong>position</strong>和<strong>anchorPoint</strong>之外, 还有两个<strong>Z坐标轴</strong>的属性, 叫做<strong>zPosition</strong>和<strong>anchorPointZ</strong>, 且都是<strong>CGFloat</strong>类型.<br/>
<dr/><br/>
<strong>zPosition</strong>这个属性在通常情况下并不常用, 在后面我们涉及到一些3D转换的内容时才会去使用这个<strong>zPosition</strong>属性, <strong>zPosition</strong>属性除了用来做3D转换之外, 更多是用来改变<strong>CALayer</strong>的显示顺序了.</p>

<p>来看看Demo吧</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewsZPosition {
    
    UIView *greenView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    greenView.backgroundColor = [UIColor greenColor];
    greenView.layer.zPosition = 1.0f;
    
    UIView *redView = [[UIView alloc] initWithFrame:CGRectMake(150, 150, 100, 100)];
    
    redView.backgroundColor = [UIColor redColor];
    
    [self.view addSubview:greenView];
    [self.view addSubview:redView];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/8.png" alt="8"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/9.png" alt="9"/></p>

<hr/>

<h3 id="toc_7">Hit Testing</h3>

<blockquote>
<p>在之前的文章里, 我们知道CALayer并不能处理任何响应链的事件, 所以不能直接去处理触摸事件或者手势, 但是呢, CALayer提供了一些方法可以让你知道你知道你点击了这个CALayer.</p>
</blockquote>

<pre><code class="language-objectivec">- (void)containsPoint;
- (void)hitTest;
</code></pre>

<blockquote>
<p>我们直接来看看代码吧:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)hitTestingLayer {
    
    _backgroundView = [[UIView alloc] initWithFrame:CGRectMake(100, 100, 100, 100)];
    
    _backgroundView.backgroundColor = [UIColor grayColor];
    
    _blueLayer = [CALayer layer];
    
    _blueLayer.backgroundColor = [UIColor blueColor].CGColor;
    _blueLayer.frame = CGRectMake(25, 25, 50, 50);
    
    [_backgroundView.layer addSublayer:_blueLayer];
    
    [self.view addSubview:_backgroundView];
}

- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event {
    
    CGPoint point = [[touches anyObject] locationInView:self.view];
    
    CALayer *layer = [self.backgroundView.layer hitTest:point];
    
    UIAlertView *alerView = [[UIAlertView alloc] initWithTitle:@&quot;你点击了屏幕&quot;
                                                       message:@&quot;&quot;
                                                      delegate:nil
                                             cancelButtonTitle:@&quot;确定&quot;
                                             otherButtonTitles:nil, nil];

    if (layer == self.blueLayer) {
        
        alerView.message = @&quot;你点中了蓝色的Layer&quot;;
        
    } else if (layer == self.backgroundView.layer){
        
        alerView.message = @&quot;你点中了灰色的Layer&quot;;
        
    } else {
        alerView.message = @&quot;你点中了其他的Layer&quot;;
    }
    
    [alerView show];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/10.png" alt="10"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/3.LayerGeometry/images/11.png" alt="11"/></p>

<hr/>

<h3 id="toc_8">Automatic Layout</h3>

<blockquote>
<p>所谓的<strong>Automatic Layout</strong>就是我们经常所说的自动布局, 自动布局是苹果在<strong>iOS 6</strong>的时候引入进来的一套布局机制, 但当时好像<strong>Xcode</strong>不够给力, 最终并没有得到很好的运用.<br/>
<dr/><br/>
在<strong>Mac OS</strong>当中<strong>CALayer</strong>有一个叫做<strong>layoutManager</strong>的属性, 它可以通过<strong>CALayoutManager</strong>协议和<strong>CAConstraintLayoutManger</strong>类来实现自动布局, 但这个东东在<strong>iOS</strong>上并不能使用, 详细我也不太了解.<br/>
<dr/><br/>
再补充多一点, 在我们对<strong>UIView</strong>使用自动布局的时候, 你可以直接使用<strong>UIView</strong>提供的<strong>UIViewAutoresizingMask</strong>和<strong>NSLayoutConstraint</strong>两个API进行布局, 但如果你要对一个<strong>CALayer</strong>进行布局的话, 那么最简单的方式就是使用<strong>CALayerDelegate</strong>提供的<strong>API</strong>:</p>
</blockquote>

<pre><code class="language-objectivec"> - (void)layoutSublayersOfLayer:(CALayer *)layer;
</code></pre>

<blockquote>
<p>当<strong>CALayer</strong>的<strong>bounds</strong>发生了改变或者<strong>- (void)setNeedsLayout;</strong>方法被调用的时候, 上面所提及的<strong>API</strong>就会被调用, 这样子你就可以在上面所提及的<strong>API</strong>里手动去调整<strong>CALayer</strong>的布局.<br/>
<dr/><br/>
但这样子会有一个致命的问题, 由于<strong>CALayer</strong>并没有<strong>autoresizingMask</strong>以及<strong>constraints</strong>属性, 所以不能像<strong>UIView</strong>那样自适应屏幕旋转, 这也是为什么绝大多数人选择使用<strong>UIView</strong>进行布局的原因之一.<br/>
<dr/><br/>
这里我就不多说了, 自动布局的知识点在谷歌搜一大堆, 有神马<strong>xib</strong>的, <strong>storyboard</strong>的, 还有纯代码的, 但是呢, 纯代码的自动布局我只服<strong><a href="https://github.com/SnapKit/Masonry">Masonry</a></strong>, 也有<strong><a href="https://github.com/SnapKit/SnapKit">Swift</a></strong>版本的, 大家可以自行去了解一下, 使用教程神马的, 在谷歌搜搜也是有一堆的, 这里就不做介绍了~</p>
</blockquote>

<hr/>

<h3 id="toc_9">总结</h3>

<blockquote>
<p>说了那么多, 常规的总结一下, 这次我们更深入的了解了<strong>CALayer</strong>几何图层, 其中包括: </p>

<ul>
<li><strong>Layout</strong>:<strong>CALayer</strong>的常规布局</li>
<li><strong>AnchorPoint</strong>: <strong>CALayer</strong>的锚点</li>
<li><strong>Coordinate Systems</strong>: <strong>CALayer</strong>的坐标轴, 其中包括如何翻转<strong>CALayer</strong>的几何图层, 还有就是<strong>Z坐标轴</strong>.</li>
<li><strong>Hit Testing</strong>: <strong>CALayer</strong>如何知道用户是否点击该图层</li>
<li><strong>Automatic Layout</strong>: 有关于<strong>CALayer</strong>以及<strong>UIView</strong>的自动布局, 以及一个第三方的布局框架</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_10">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_11">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：2.《Core Animation》初识CALayer]]></title>
    <link href="https://cainrun.github.io/14771496782021.html"/>
    <updated>2016-10-22T23:21:18+08:00</updated>
    <id>https://cainrun.github.io/14771496782021.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前面我们简单介绍了一些图层与视图的关系, 也介绍了<strong>CALayer</strong>以及<strong>UIView</strong>的相同点和区别, 没看过的朋友可以去看看<a href="https://cainrun.github.io/14770254062641.html">《Core Animation》基础概念</a>今天我们就着重的来讲讲<strong>CALayer</strong>.<br/>
<dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p>前面我们已经简单介绍了什么是<strong>CALayer</strong>, <strong>CALayer</strong>主要是用来做什么的, 现在我们来更加深入的了解<strong>CALayer</strong>到底有些什么东西供给我们去使用的.</p>
</blockquote>

<hr/>

<h3 id="toc_2">CALayer的Contents属性</h3>

<blockquote>
<p>在<strong>CALayer</strong>中, 有这么一个<strong>contents</strong>属性, 那么<strong>contents</strong>这个属性是用来做什么的呢? 我们先来看一段官方解释.<br/>
<dr/><br/>
<strong><font color=blue>An object that provides the contents of the layer. Animatable.</font></strong><br/>
<dr/><br/>
从字面上意思来看, 这是一个提供图层内容的对象, 并且是<strong>id</strong>类型, 也就意味着, 我们可以给这个<strong>contents</strong>属性赋任意的值, 毕竟是<strong>id</strong>类型嘛, 但在实际操作中, 是行不通的, 为什么? <br/>
<dr/><br/>
这里就要牵扯到<strong>Mac OS</strong>了, 因为在<strong>Mac OS</strong>当中, 给<strong>CALayer</strong>中的<strong>contents</strong>属性赋值, 无论是<strong>CGImage</strong>还是<strong>NSImage</strong>, 都能得到对应的效果, 而在<strong>iOS</strong>当中, 只能赋值<strong>CGImage</strong>, 或许到了这里, 你会觉得挺简单的, 但呵呵了, 这里还要牵扯到指针的问题(个人对指针有些晕).<br/>
<dr/><br/>
实际上, 我们给<strong>contents</strong>属性赋<strong>CGImage</strong>的时候, 真正赋值的是<strong>CGImageRef</strong>, 它是指向<strong>CGImage</strong>的指针, 用过<strong>UIImage</strong>的朋友应该会发现, <strong>UIImage</strong>当中有一个<strong>CGImage</strong>的属性, 这个属性的返回值就是<strong>CGImageRef</strong>.<br/>
<dr/><br/>
某些童鞋会说, 既然是<strong>CGImageRef</strong>类型的话, 那直接赋值给<strong>contents</strong>不就好了么, 其实并不是滴, 直接这么赋值会报编译错误滴, 为什么?? <br/>
<dr/><br/>
因为<strong>CGImageRef</strong>并不是一个真正的<strong>Cocoa</strong>对象, 它是属于<strong>Core Foundation</strong>里的东西(什么是<strong>Core Foundation</strong>? 嘿嘿, 自行百度去吧~~), 那么我们就没办法给<strong>contents</strong>赋值吗? 肯定不是啦, 我们可以通过一些关键字进行赋值, 就能够得到对应的效果了, 代码如下:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
}
</code></pre>

<blockquote>
<p>这里提一点哈, 这个关键字在<strong>非ARC内存管理机制</strong>中是不需要加滴, 但是呢, 特么的, 你为啥不用<strong>ARC</strong>? 估计连你自己都会这么问你自己了.<br/>
<dr/><br/>
效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/1.png" alt="1"/></p>

<blockquote>
<p>看完效果图之后, 我们再看看它的层级结构, 你就会发现和我们使用的<strong>UIImageView</strong>完全一模一样, 不信? 我给你们加个UIImageView看看~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/2.png" alt="2"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/3.png" alt="3"/></p>

<blockquote>
<p>虽然我们并不是通过使用<strong>UIImageView</strong>来实现加载图片的, 但我们可以通过<strong>Layer</strong>层给<strong>UIView</strong>进行加载图片, 酱紫的话, 大家是不是对苹果如何封装<strong>UIImageView</strong>有了一个思路呢?</p>
</blockquote>

<hr/>

<h3 id="toc_3">CALayer的ContentGravity属性</h3>

<blockquote>
<p>不知道你们有没有发现, 我们所展示的图片有一些变形, 如果是用<strong>UIImageView</strong>的话, 我们可以直接设置<strong>contentModel</strong>这个属性, 使得图片正常显示, 但如果是在<strong>CALayer</strong>呢? <br/>
<dr/><br/>
当然<strong>CALayer</strong>也有一个类似<strong>contentModel</strong>的属性, 它叫做<strong>contentGravity</strong>, 虽然名字有些差别, 但是使用效果都是差不多的~~<br/>
<dr/><br/>
进入头文件之后我们会看到<strong>contentGravity</strong>可以赋值的选项有:</p>

<ul>
<li>kCAGravityCenter</li>
<li>kCAGravityTop</li>
<li>kCAGravityBottom</li>
<li>kCAGravityLeft</li>
<li>kCAGravityRight</li>
<li>kCAGravityTopLeft</li>
<li>kCAGravityTopRight</li>
<li>kCAGravityBottomLeft</li>
<li>kCAGravityBottomRight</li>
<li>kCAGravityResize</li>
<li>kCAGravityResizeAspect</li>
<li>kCAGravityResizeAspectFill
<dr/>
现在我们就来改改工程里的代码:</li>
</ul>
</blockquote>

<pre><code class="language-objectivec">    layerView.layer.contentsGravity = kCAGravityResizeAspect;
</code></pre>

<blockquote>
<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/4.png" alt="4"/></p>

<blockquote>
<p>酱紫图片显示正确啦~~貌似<strong>UIImageView</strong>的<strong>contentModel</strong>也就是这么实现的~</p>
</blockquote>

<hr/>

<h3 id="toc_4">CALayer的ContentsScale属性</h3>

<blockquote>
<p>其实我在想, 我是不是不应该把<strong>CALayer</strong>里的所有属性都拿出来讲一讲? 只是简单讲一些重要的好了, 接下来的就是<strong>contentsScale</strong>.<br/>
<dr/><br/>
<strong>contentsScale</strong>这个属性主要是定义图层的像素和视图比例大小, 默认情况是<strong>1.0</strong>, 而且是<strong>CGFloat</strong>类型.<br/>
<dr/><br/>
但如果你的<strong>CALayer</strong>已经设置了<strong>contentsGravity</strong>, 那么再设置<strong>contentsScale</strong>, 效果就是没多大影响, 或者直接说压根就没影响吧, 如果你只是想着单纯的放大缩小<strong>CALayer</strong>, 可以直接使用<strong>transform</strong>和<strong>affineTransForm</strong>实现你想要的效果, 后续会详细讲解<strong>transforms</strong>.<br/>
<dr/><br/>
当然放大缩小肯定也不是<strong>contentsScale</strong>属性的主要作用, 这里就需要解释一下<strong>contentsScale</strong>: <br/>
<dr/><br/>
<strong>contentsScale</strong>主要是支持<strong>Retina</strong>机制的一部分, 它是用来判断绘制图层时应该需要创建多大的空间, 和需要显示图片的拉伸度,<strong>UIView</strong>也有一个类似的属性, 叫做<strong>contentScaleFactor</strong>, 只是我们非常少的去使用罢了.<br/>
<dr/><br/>
这个时候我们来改改工程里的代码, 让<strong>contentsScale</strong>呈现效果: </p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
    
    layerView.layer.contentsGravity = kCAGravityCenter;
    layerView.layer.contentsScale = image.scale;
}
</code></pre>

<blockquote>
<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_5">CALayer的MaskToBounds属性</h3>

<blockquote>
<p>看完了<strong>contentsScale</strong>属性, 现在我们继续来看<strong>maskToBounds</strong>属性.<br/>
<dr/><br/>
我们先来看一段官方文字介绍: <br/>
<dr/><br/>
<strong><font color=blue>A Boolean indicating whether sublayers are clipped to the layer’s bounds. Animatable.</font></strong><br/>
<dr/><br/>
看完之后, 我们知道这个属性是一个<strong>BOOL</strong>类型, 问你如果子图层超出了视图层, 是否剪切掉, 如果你设置为<strong>YES</strong>, 那就剪切掉了, 默认为<strong>NO</strong>.<br/>
<dr/><br/>
就拿我们刚刚的工程作为一个事例来讲, 那张图片肯定是超过了视图层的, 如果我们把<strong>maskToBounds</strong>属性设置为<strong>YES</strong>, 效果就不一样了:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
    
    layerView.layer.contentsGravity = kCAGravityCenter;
    layerView.layer.contentsScale = image.scale;
    layerView.layer.masksToBounds = YES;
}
</code></pre>

<blockquote>
<p>效果图:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/6.png" alt="6"/></p>

<hr/>

<h3 id="toc_6">CALayer的ContentsRect属性</h3>

<blockquote>
<p><strong>CALayer</strong>有一个属性叫做<strong>contentsRect</strong>, 它是可以根据输入的坐标轴来显示区域块的图层, 而<strong>frame</strong>,<strong>bounds</strong>则是以点来计算的, 在这里它们有一些区别.<br/>
<dr/><br/>
还有一个注意点, <strong>contentsRect</strong>的坐标轴默认是<strong>{0, 0, 1, 1}</strong>, 单位坐标一般指定的是<strong>0~1</strong>之间, 如果小于这个数, 或者是大于这个数, 哼哼, 你自己试试看吧~<br/>
<dr/><br/>
说到这里, 应该会有人有些疑惑, 神马是点? 难道和像素不一样的么? 那就先来普及一下先吧(这里我是搜到的一些比较中肯的说法)~<br/>
</br><br/>
点: <br/>
<dr/> </p>

<ul>
<li>在<strong>iOS</strong>和<strong>Mac OS</strong>中最常见的坐标体系。</li>
<li>点就像是虚拟的像素, 也被称作逻辑像素。</li>
<li>在标准设备上, 一个点就是一个像素, 但是在<strong>Retina</strong>设备上, 一个点等于<strong>2*2</strong>个像素。</li>
<li><strong>iOS</strong>用点作为屏幕的坐标测算体系就是为了在<strong>Retina</strong>设备和普通设备上能有一致的视觉效果。</li>
</ul>

<p></br><br/>
像素:<br/>
<dr/></p>

<ul>
<li>物理像素坐标并不会用来屏幕布局, 但是仍然与图片有相对关系。 </li>
<li><strong>UIImage</strong>是一个屏幕分辨率解决方案, 所以指定点来度量大小。</li>
<li><p>但是一些底层的图片表示如<strong>CGImage</strong>就会使用像素, 所以你要清楚在<strong>Retina</strong>设备和普通设备上, 他们表现出来了不同的大小。<br/>
</br><br/>
单位: <br/>
<dr/></p></li>
<li><p>对于与图片大小或是图层边界相关的显示, 单位坐标是一个方便的度量方式, 当大小改变的时候, 也不需要再次调整。</p></li>
<li><p>单位坐标在<strong>OpenGL</strong>这种纹理坐标系统中用得很多,<strong>Core Animation</strong>中也用到了单位坐标。<br/>
</br><br/>
这里我们还是继续拿刚刚的工程来演示: </p></li>
</ul>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];

    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
    
    layerView.layer.contentsGravity = kCAGravityCenter;
    layerView.layer.contentsScale = image.scale;
    layerView.layer.masksToBounds = YES;
    layerView.layer.contentsRect = CGRectMake(0, 0, 0.5, 0.5);
}
</code></pre>

<blockquote>
<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/7.png" alt="7"/></p>

<blockquote>
<p>补充一些额外的知识点:<br/>
<dr/><br/>
<strong>contentsRect</strong>在<strong>App</strong>当中, 还有一个更好玩的用法叫做<strong>image sprites</strong>, 如果你有游戏开发经验的话, 你肯定对<strong>image sprites</strong>不陌生, 甚至是非常熟练的使用, 可以使图片独立的变更在屏幕上显示的位置.<br/>
<dr/><br/>
但如果我们抛开游戏开发来说的话, 在我们日常生活当中, 微博就是一个经典的代表, 把图片拼接成一张大图片, 然后再分享出去, 这里使用的就是<strong>contentsRect</strong>, 这样子的好处就是可以减少内存的使用, 载入的时间, 还有渲染的性能等等.<br/>
<dr/><br/>
这里我就不做演示了, 感兴趣的童鞋可以 到网上找找资料.</p>
</blockquote>

<hr/>

<h3 id="toc_7">CALayer的ContentsCenter属性</h3>

<blockquote>
<p>讲到这里, 已经算是<strong>CALayer</strong>最后的一个属性了, 它叫做<strong>contentsCenter</strong>, 它的意思比较拗口, 它是一个<strong>CGRect</strong>, 且定义了一个固定的边框和一个图层上可拉伸的区域.<br/>
<dr/><br/>
如果你只是单单改变<strong>contentsCenter</strong>的值, 并不会影响到<strong>CALayer</strong>的显示效果, 要同时去改变这个图层的大小, 才能看到效果.<br/>
<dr/><br/>
我们还是直接看代码吧, 在我们原先的项目上添加一个方法, 并且加多一个<strong>UIView</strong>类:</p>
</blockquote>

<pre><code class="language-objectivec">- (void)viewDidLoad {
    [super viewDidLoad];
    
    self.view.backgroundColor = [UIColor lightGrayColor];
    
    UIView *layerView = [[UIView alloc] init];
    layerView.backgroundColor = [UIColor whiteColor];
    layerView.center = self.view.center;
    layerView.bounds = CGRectMake(0, 0, 200, 200);
    
    [self.view addSubview:layerView];
    
    
    UIImage *image = [UIImage imageNamed:@&quot;bear&quot;];
    
    /**
     *  Contents
     */
    layerView.layer.contents = (__bridge id _Nullable)(image.CGImage);
    
    /**
     *  ContentsGravity
     */
    layerView.layer.contentsGravity = kCAGravityCenter;
    
    /**
     *  ContentsScale
     */
    layerView.layer.contentsScale = image.scale;
    
    /**
     *  MasksToBounds
     */
    layerView.layer.masksToBounds = YES;
    
    /**
     *  contentsRect
     */
    layerView.layer.contentsRect = CGRectMake(0, 0, 1.1, 1.1);
    
    
    [self addImage:[UIImage imageNamed:@&quot;bear&quot;] withContensRect:CGRectMake(0.25, 0.25, 0.5, 0.5)];
}

- (void)addImage:(UIImage *)image withContensRect:(CGRect)rect {
    
    UIView *view = [[UIView alloc] initWithFrame:CGRectMake(0, 0, 200, 200)];
    
    view.layer.contents = (__bridge id _Nullable)(image.CGImage);
    view.layer.contentsCenter = rect;
    
    [self.view addSubview:view];
}
</code></pre>

<blockquote>
<p>效果图:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/8.png" alt="8"/></p>

<blockquote>
<p>补充一个知识点, 如果你是使用Storyboard或者是xib的话, 你可以在右侧的栏目看到<strong>contentsCenter</strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/9.png" alt="9"/></p>

<hr/>

<h3 id="toc_8">CALayer的Delegate</h3>

<blockquote>
<p>降到这里, 基本上就已经介绍完了<strong>CALayer</strong>, 但还有一点也是需要提一提的, <strong>CALayer</strong>除了使用<strong>contents</strong>赋值<strong>CGImage</strong>来显示图层之后, 还可以使用<strong>Core Graphics</strong>去进行绘制, 在<strong>UIView</strong>就可以看到这个方法, 叫做<strong>-drawRect:</strong>.<br/>
<dr/><br/>
<strong>-drawRect:</strong>方法默认没有去实现, 因为在<strong>UIView</strong>中,<strong>backing image</strong>并不是必须的, 但如果你去调用<strong>-drawRect:</strong>方法, 那么UIView就会给你生成一个新的<strong>backing image</strong>, 而这个<strong>backing image</strong>的像素尺寸等于视图大小乘以<strong>contentsScale</strong>的值.<br/>
<dr/><br/>
这里需要注意一个点, 如果你的视图里不需要创建一个<strong>backing image</strong>的话, 千万不要去写一个空的<strong>-drawRect:</strong>方法, 这样子就会对CPU与内存造成浪费, 这也是苹果官方建议的.<br/>
<dr/><br/>
我们先来解释一下<strong>-drawRect:</strong>方法的实现原理:<br/>
<dr/></p>

<ul>
<li>当<strong>-drawRect:</strong>被调用,<strong>UIView</strong>会创建一个新的<strong>backing image</strong>.</li>
<li>会使用<strong>Core Graphics</strong>对<strong>backing image</strong>进行描绘.</li>
<li>然后这个描绘好的<strong>backing image</strong>会被缓存起来, 等到它需要被更新的时候, 就会去使用.
<dr/>
当然, 我们自己也可以手动去调用, 比如去调用<strong>-setNeedsDisplay:</strong>, 那么被重新绘制的<strong>backing image</strong>就会立马显示出来了.
<dr/>
总而言之, <strong>-drawRect:</strong>看似是<strong>UIView</strong>的方法, 但实际上都是在内部对CALayer进行了重绘以及缓存的操作.
<dr/>
还有, <strong>CALayer</strong>也有一个<strong>delegate</strong>的属性, 而且是<strong>id</strong>类型, 并实现<strong>CALayerDelegate</strong>协议, 当<strong>CALayer</strong>需要一个特定内容时, 就会从代理方法里去请求, 由于<strong>CALayerDelegate</strong>是一个非正式的协议, 所以并没有神马属性给你引用, 直接调用代理方法就可以了.
<dr/>
当需要被重绘的时候, <strong>CALayer</strong>就会去调用:</li>
</ul>
</blockquote>

<pre><code class="language-objectivec">    -(void)displayLayer:(CALayer *)layer;
</code></pre>

<blockquote>
<p>如果你还想再重绘的时候设置一下<strong>contents</strong>的话, 那么就要在这个方法里去实现, 不然在别的方法里就没法做到了.<br/>
<dr/><br/>
但如果没有实现以上的方法时, 那么就会去调用:</p>
</blockquote>

<pre><code class="language-objectivec">    - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
</code></pre>

<blockquote>
<p>在调用这个方法之前, <strong>CALayer</strong>会创建一个适合尺寸的<strong>backing image</strong>, 当然, 尺寸肯定是由<strong>bounds</strong>和<strong>contentsScale</strong>决定的, 还有一个<strong>Core Graphics</strong>绘制的上下文, 未绘制<strong>backing image</strong>做准备, 等的就是<strong>ctx</strong>的传入.<br/>
<dr/><br/>
说了那么多我们直接用代码演示吧~</p>
</blockquote>

<pre><code class="language-objectivec">- (void)createNewLayerWithSuperView {
    
    // Background View
    UIView *backgroundView = [[UIView alloc] initWithFrame:CGRectMake(220, 0, 100, 100)];
    backgroundView.backgroundColor = [UIColor whiteColor];
    
    [self.view addSubview:backgroundView];
    
    // Blue Layer
    CALayer *blueLayer = [CALayer layer];
    
    blueLayer.frame = CGRectMake(25, 25, 50, 50);
    blueLayer.backgroundColor = [UIColor blueColor].CGColor;
    
    // Set Layer Delegate
    blueLayer.delegate = self;
    
    // Set Layer contentsScale
    blueLayer.contentsScale = [UIScreen mainScreen].scale;
    
    [backgroundView.layer addSublayer:blueLayer];
    
    [blueLayer display];
}

- (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx {
    
    CGContextSetLineWidth(ctx, 5);
    CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor);
    CGContextStrokeEllipseInRect(ctx, layer.bounds);
}
</code></pre>

<blockquote>
<p>效果图: </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/2.CALayer/images/10.png" alt="10"/></p>

<blockquote>
<p>看到效果图代码之后, 有两点我们是需要注意一下的:<br/>
<dr/></p>

<ul>
<li>不同的<strong>CALayer</strong>在不同的<strong>UIView</strong>视图中使用, 是不会自动去重载它的内容的, 所以在事例当中, 我们用<strong>blueLayer</strong>调用了<strong>display</strong>这个方法.</li>
<li>在事例当中, 我们并没有对<strong>blueLayer</strong>设置<strong>masksToBounds</strong>属性, 但所绘制的那个圆仍然被裁剪了一些, 这个是因为我们在使用<strong>CALayerDelegate</strong>的时候, 并没有让需要描绘的<strong>backing image</strong>支持超出边界外的支持.</li>
</ul>

<p><dr/><br/>
聊到这里, 虽然我们知道了<strong>CALayerDelegate</strong>, 但在实际开发当中, 我们基本上非常非常少去接触它, 因为当<strong>UIView</strong>创建<strong>backing image</strong>的时候, 就会默认把<strong>CALayerDelegate</strong>设置为它自己, 同时也会提供一个<strong>- (void)displayLayer:(CALayer *)layer;</strong>的实现, 所以基本上不会遇到什么问题.<br/>
<dr/><br/>
当你使用有<strong>backing image</strong>的<strong>UIView</strong>时, 你也不必实现下面两个方法</p>
</blockquote>

<pre><code class="language-objectivec">    - (void)displayLayer:(CALayer *)layer;
    - (void)drawLayer:(CALayer *)layer inContext:(CGContextRef)ctx;
</code></pre>

<blockquote>
<p>因为<strong>UIView</strong>提供了一个<strong>- (void)drawRect:(CGRect)rect;</strong>的方法, 只要你实现了这个方法, 那么剩下的东西<strong>UIView</strong>都是全部帮你完成.</p>
</blockquote>

<hr/>

<h3 id="toc_9">总结一下</h3>

<blockquote>
<p>不得不说, 这次的内容有些多, 还是来总结一下:<br/>
<dr/></p>

<ul>
<li><strong>contents</strong>是给<strong>CALayer</strong>设置内容的一个属性</li>
<li><strong>ContentGravity</strong>是给<strong>CALayer</strong>设置内容的显示, 类似<strong>UIView</strong>的<strong>contentModel</strong>.</li>
<li><strong>contentsScale</strong>定义图层的像素和视图比例大小, 默认大小为<strong>1.0f</strong>, 并且是CGFloat类型.</li>
<li><strong>maskToBounds</strong>是一个<strong>BOOL</strong>类型, 默认为<strong>NO</strong>, 如果设置为<strong>YES</strong>, 则会裁剪掉超出视图的部分.</li>
<li><strong>contentsRect</strong>是一个坐标轴, 默认是<strong>CGRectMake(0, 0, 1, 1)</strong>, 输入对应的坐标轴, 可以让<strong>CALayer</strong>显示所输入坐标轴的区域内容.</li>
<li><strong>cntentsCenter</strong>是用来定义一个固定的边框和一个图层上可拉伸的区域.</li>
<li><strong>delegate</strong>是用来定义CALayerDelegate对象, 当UIView创建CALayer的时候, 默认就会实现, 并且提供一个<strong>- (void)displayLayer:(CALayer *)layer;</strong>方法的实现.</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_10">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_11">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：1.《Core Animation》基础概念]]></title>
    <link href="https://cainrun.github.io/14770254062641.html"/>
    <updated>2016-10-21T12:50:06+08:00</updated>
    <id>https://cainrun.github.io/14770254062641.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>最近作者一直有一些迷糊, 感觉在研究上有了一些迷糊, 不知道怎么往下研究了, 咨询了一下朋友和一些前辈, 决定先玩一玩<strong>Core Animation</strong>, 毕竟是<strong>iOS</strong>的核心层之一, 也是最吸引人的地方之一, 今天就让我们先来了解一下<strong>Core Animation</strong>的一些概念知识.<br/>
<dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Core Animation</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<ul>
<li><strong>Core Animation</strong>是<strong>iOS</strong>与<strong>OS X</strong>平台上负责图形渲染与动画的基础设施。</li>
<li><strong>Core Animation</strong>可以动画视图和其他的可视元素。</li>
<li><strong>Core Animation</strong>为你完成了实现动画所需的大部分绘帧工作。</li>
<li>你只需在配置少量的动画参数（如开始点位置和结束点位置）就可启动<strong>Core Animation</strong>。</li>
<li><strong>Core Animation</strong>将大部分实际的绘图任务交给了图形硬件处理，图形硬件会加速图形渲染的速度。</li>
<li>这种自动化的图形加速让动画具有更高的帧率且更加平滑，但这并不会增加<strong>CPU</strong>的负担而导致影响你应用的运行速度。</li>
</ul>

<p>以上的文字都是从官方文档里直接拷贝的, 如果有啥问题, 直接去PK<a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CoreAnimation_guide/Introduction/Introduction.html">通用官方文档</a>和<a href="https://developer.apple.com/library/content/documentation/WindowsViews/Conceptual/ViewPG_iPhoneOS/Introduction/Introduction.html">iOS官方文档</a>~~</p>
</blockquote>

<hr/>

<h3 id="toc_2">图层与视图结构</h3>

<blockquote>
<p>在我们日常开发<strong>iOS</strong>或者是<strong>Mac</strong>应用中, 我们都避免不了对<strong>UI</strong>的布局(不然要UI设计师干嘛), 那我们一般是怎么去看应用中的图层结构呢? 让我们直接来看一个<strong>Demo</strong>吧.</p>

<p>创建一个新的项目, 然后在项目当中随意添加一个或者多个<strong>UI</strong>控件.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/1.viewLayer/images/1.png" alt="1"/></p>

<blockquote>
<p>运行了项目之后, 找到查看图层的按钮, 点击之后就会跳转到查看图层的界面.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/1.viewLayer/images/2.png" alt="2"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/1.viewLayer/images/3.png" alt="3"/></p>

<blockquote>
<p>再换个角度看看~~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CoreAnimation/master/1.viewLayer/images/4.png" alt="4"/></p>

<blockquote>
<p>在<strong>iOS</strong>当中, 无论是神马<strong>UIButton</strong>,<strong>UIScrollView</strong>, 还是神马<strong>UITableView</strong>, 都是基于<strong>UIView</strong>基类派生而来的, 而<strong>UIView</strong>是可以处理<strong>Touch</strong>事件, 也支持<strong>Core Graphics</strong>的绘画, 也可以做仿射变换(也就是神马旋转, 缩放事件), 当然, 也可以做类似于滑动, 渐变等<strong>UIView</strong>基础动画.</p>
</blockquote>

<hr/>

<h3 id="toc_3">CALayer</h3>

<blockquote>
<p><strong>CALayer</strong>其实是和<strong>UIView</strong>的概念差不多, 也是同样被层级关系树所管理, 也一样有神马图片, 文本, 背景色等内容, 或者是管理一些子图层等等, 但<strong>CALayer</strong>和<strong>UIView</strong>最大的区别是在于,<strong>CALayer</strong>并不能处理用户交互, 即使<strong>CALayer</strong>提供了一些方法来判断触点是否在图层的范围之内.</p>
</blockquote>

<hr/>

<h3 id="toc_4">UIView和CALayer层级关系</h3>

<blockquote>
<p>用过<strong>UIView</strong>的朋友们其实都知道, 每一个<strong>UIView</strong>当中都有一个<strong>CALayer</strong>实例的图层属性, 也就是所谓<strong>backing layer</strong>.</p>

<p><strong>UIView</strong>的职责是用来创建并管理这个图层, 以确保层级关系中添加或者被移除的时候, 所关联的<strong>Layer</strong>也会有同样的操作.</p>

<p>虽然<strong>UIView</strong>是作为一个管理者, 但实际上显示在屏幕上以及做动画效果的都是<strong>Layer</strong>,<strong>UIView</strong>仅仅只是对<strong>Layer</strong>的一个封装, 提供了一些而外的方法, 比如<strong>Touch</strong>的功能,<strong>Core Animation</strong>底层方法的高级<strong>API</strong>, 所以<strong>UIView</strong>和<strong>CALayer</strong>是处于一个平级的关系.</p>
</blockquote>

<hr/>

<h3 id="toc_5">疑惑</h3>

<blockquote>
<p>说到这里, 就会有一个疑惑, 为什么苹果要把<strong>UIView</strong>和<strong>CALayer</strong>处于一个平级的关系呢?(或许有人会有这样子的疑问)</p>

<p>其实原因很简单, 是为了职责分离, 也算是模块化划分吧, 因为在<strong>Mac OS</strong>当中, 并没有<strong>UIView</strong>这个类, 所以并不能处理<strong>Touch</strong>事件, 但却有<strong>CALayer</strong>, 所以苹果为了能够让<strong>Mac OS</strong>和<strong>iOS</strong>两个系统相互共享代码, 直接把<strong>CALayer</strong>给独立出来了~~</p>
</blockquote>

<hr/>

<h3 id="toc_6">CALayer的能力</h3>

<blockquote>
<p>其实在系统库当中, 苹果已经通过<strong>UIView</strong>提供了许多高级的<strong>API</strong>, 间接的使得动画变得很简单.</p>

<p>但这样子就带来另外的一个问题, 就是灵活性的缺失, 打个比方, 如果你想在底层做一些额外的操作, 通过系统提供的<strong>API</strong>是没法实现的, 这个时候, 我们除了去学习和了解<strong>Core Animation</strong>之外, 再也没有其他途径了.</p>

<p>那么说到底,<strong>CALayer</strong>到底能用来做什么呢? 有好几个点, 比如:</p>

<ul>
<li>阴影, 圆角, 边框</li>
<li>3D变换(比如拉伸, 放大, 缩小等)</li>
<li>非矩形范围</li>
<li>透明遮罩</li>
<li>多级非线性动画</li>
</ul>

<p>大致上就这一些, 后续我们会通过学习<strong>Core Animation</strong>, 会了解更多的<strong>Layer</strong>, 以及怎么利用<strong>Layer</strong>做出我们想做的效果.</p>
</blockquote>

<hr/>

<h3 id="toc_7">使用CALayer</h3>

<blockquote>
<p>一般来讲, 在我们日常开发中, 都是面对视图开发, 但如果某些特殊的场景, 我们还是需要面向CALayer来进行开发的, 比如</p>

<ul>
<li>开发一个可同时在Mac OS和iOS两个平台上使用的应用</li>
<li>使用多种的CALayer子类, 并且不想创建一个UIView去封装它们</li>
<li>做一些对性能特别挑剔的工作(暂时我也没想到, 知道的朋友可以和我说说)</li>
</ul>

<p>但总的来说, 直接面向视图开发, 要比面向<strong>CALayer</strong>开发的要简单.</p>
</blockquote>

<hr/>

<h3 id="toc_8">总结一下</h3>

<blockquote>
<p>说了那么多东西, 其实重点就那么几个: </p>

<ul>
<li>CALayer与UIView是平级关系</li>
<li>CALayer与UIView的相同点与区别</li>
<li>CALayer可跨平台使用</li>
<li>CALayer不能够响应事件</li>
<li>UIView是基于CALayer封装的一个类, 并提供<strong>Touch</strong>事件</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_9">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CoreAnimation">https://github.com/CainRun/CoreAnimation</a></p>

<hr/>

<h3 id="toc_10">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：Touch ID集成]]></title>
    <link href="https://cainrun.github.io/14758230794995.html"/>
    <updated>2016-10-07T14:51:19+08:00</updated>
    <id>https://cainrun.github.io/14758230794995.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>这个国庆由于种种原因, 过的不太安稳, 搬家, 办证, 东跑西跑, 忙的压根就不像是在过节....不过算了, 挑最后一天写写博文.<br/>
<dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Apple Pay</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong><code>Touch ID</code></strong>是苹果公司的一种指纹识别技术。苹果把用户的指纹数据存放在处理器的<strong><code>安全区域</code></strong>中，充分保护用户的数据安全。除此之外，苹果还有另外一道指纹数据安全防线，以一种前所未有的硬件技术实现了对用户数据的保护。</p>

<p>在集成的时候非常的简单, 基本上没多少东西可以写的, 这里我就简单的写写.</p>

<p><strong><font color=red>PS: 由于Touch ID只能在真机上调试, 所以模拟器是没法用来调试.</font></strong></p>
</blockquote>

<hr/>

<h3 id="toc_2">创建工程</h3>

<blockquote>
<p>直接创建一个新的工程, 并且命名为<strong><code>SimpleTouchID</code></strong>, 然后在<strong><code>Storyboard</code></strong>拖一个<strong><code>UIButton</code></strong>, 然后关联到<strong><code>ViewController</code></strong>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/SimpleTouchID/master/images/1.png" alt="1"/></p>

<blockquote>
<p>关联完成之后, 导入<strong><code>LocalAuthentication</code></strong>依赖库, 在<strong><code>ViewController</code></strong>也别忘记导入.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/SimpleTouchID/master/images/2.png" alt="2"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/SimpleTouchID/master/images/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_3">实现Touch ID校验</h3>

<blockquote>
<p>这里的代码非常简单这里就不细说了, 唯一不太一样的就是, 在<strong><code>iOS 9</code></strong>之后新增了三个校验的状态, 大家可以看看<strong><code>Demo</code></strong>里的注释.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/SimpleTouchID/master/images/4.png" alt="4"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/SimpleTouchID/master/images/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_4">最终效果</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/SimpleTouchID/master/images/0.gif" alt="0"/></p>

<hr/>

<h3 id="toc_5">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/SimpleTouchID">https://github.com/CainRun/SimpleTouchID</a></p>

<hr/>

<h3 id="toc_6">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：集成 Apple Pay]]></title>
    <link href="https://cainrun.github.io/14747805717408.html"/>
    <updated>2016-09-25T13:16:11+08:00</updated>
    <id>https://cainrun.github.io/14747805717408.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在中秋过后终于把国内的三大支付平台<strong><code>SDK</code></strong>集成都搞定了, 现在我们终于可以来研究<strong><code>Apple</code></strong>自家的支付<strong><code>Apple Pay</code></strong><br/>
<dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Apple Pay</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong><code>Apple Pay</code></strong>呢, 是<strong><code>Apple</code></strong>在2014年的时候发布的功能, 是基于NFC上开发的, 所以在<strong><code>2014</code></strong>年之前的机型都是不支持的, 比如<strong><code>iPhone 5</code></strong>和<strong><code>iPhone 5s</code></strong>, 但可以通过另外的方法, 比如连接<strong><code>Apple Watch</code></strong>就可以用了, 在2016年的2月18号, 中国地区才正式上线<strong><code>Apple Pay</code></strong>, 既然已经来到了, 我们就要去看看怎么去使用<strong><code>Apple Pay</code></strong>啦.</p>
</blockquote>

<hr/>

<h3 id="toc_2">准备工作</h3>

<blockquote>
<p>既然是<strong><code>Apple</code></strong>自家的功能, 那我们肯定要去先查看一下<strong><a href="https://developer.apple.com/apple-pay/Getting-Started-with-Apple-Pay.pdf">Apple Pay文档</a></strong>, 了解了一下文档的内容, 它是需要去开发者中心申请一个<strong><code>Merchant ID证书</code></strong>, 那事不宜迟, 我们赶紧去申请一个.</p>
</blockquote>

<hr/>

<h3 id="toc_3">申请商务证书</h3>

<blockquote>
<p>其实申请商务证书和申请<strong><code>App ID</code></strong>证书的步骤没啥区别, 最大的区别就是在于一些小细节, 首先我们要去打开<strong><a href="https://developer.apple.com">开发者中心</a></strong>, 登录之后, 我们找到<strong><code>Merchant ID证书</code></strong>申请的地方, 申请一下<strong><code>Merchant ID证书</code></strong>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/1.png" alt="1"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/2.png" alt="2"/></p>

<blockquote>
<p>找到之后, 我们输入一些信息, 比如<strong><code>Merchant ID Description</code></strong>, 然后就是<strong><code>Identifier</code></strong>.</p>

<p>PS: <strong><code>Identifier</code></strong>是唯一的, 如果别人使用你所输入的<strong><code>Identifier</code></strong>, <strong><code>Apple</code></strong>就会叫你更换成另一个</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/3.png" alt="3"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/4.png" alt="4"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/5.png" alt="5"/></p>

<blockquote>
<p>现在我们已经搞定了第一步, 已经有了<strong><code>Merchant ID</code></strong>, 接下来我们需要去创建<strong><code>Merchant ID证书</code></strong>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/6.png" alt="6"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/7.png" alt="7"/></p>

<blockquote>
<p>这里会问一个问题, 是否要设置成中国地区特有的<strong><code>Apple Pay</code></strong>, <strong><code>App</code></strong>只是面对国内的话, 那这个选择<strong><code>YES</code></strong>就好了, 如果是全球性的<strong><code>App</code></strong>, 那就选择<strong><code>NO</code></strong>, 当然这个也不是强制性, 自己看着办吧~~我这里就选择<strong><code>NO</code></strong>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/8.png" alt="8"/></p>

<blockquote>
<p>接下来就是重头戏了, 我们这里需要仔细看一下Apple给我们的提示, 我们要生成的证书类型是<strong><code>ECC</code></strong>, 并且是<strong><code>256bits</code></strong>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/9.png" alt="9"/></p>

<blockquote>
<p>打开系统的钥匙串, 创建我们所需的类型证书.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/10.png" alt="10"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/11.png" alt="11"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/12.png" alt="12"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/13.png" alt="13"/></p>

<blockquote>
<p>创建完成之后就可以关闭了, 然后在开发者中心点击<strong><code>Continue</code></strong>, 由于我创建的时候, 是把证书放在桌面上的, 所以开发者中心里选择的证书也是选择桌面上的这个证书, 然后再点击<strong><code>Continue</code></strong>就搞定了.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/14.png" alt="14"/></p>

<blockquote>
<p>但是别忘了我们还要下载这个证书哦, 下载完成后要双击添加到我们的钥匙串里去~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/15.png" alt="15"/></p>

<blockquote>
<p>剩下怎么去弄<strong><code>配置文件</code></strong>以及<strong><code>App ID证书</code></strong>, 我这里就不做多介绍了, 第一次尝试的童鞋可以自行到<a href="http://www.jianshu.com/p/61d1b4c33f5f">iOS APP上架流程详解</a>, <a href="http://www.jianshu.com/p/2813abee7187">完整的iOS上架App流程</a>查看哈~</p>
</blockquote>

<hr/>

<h3 id="toc_4">关联Merchant ID</h3>

<blockquote>
<p>刚刚我们已经申请好了<strong><code>Merchant ID证书</code></strong>, 在申请完成<strong><code>App ID</code></strong>之后, 我们要就要去找到刚刚创建好的<strong><code>App ID</code></strong>, 然后关联上我们的<strong><code>Merchant ID</code></strong>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/16.png" alt="16"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/17.png" alt="17"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/18.png" alt="18"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/19.png" alt="19"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/20.png" alt="20"/></p>

<blockquote>
<p>酱紫, 我们就关联完成了, 下面来就是在之前的支付工程里添加一个新的工程, 命名为<strong><code>ApplePay-Objective-C</code></strong></p>
</blockquote>

<hr/>

<h3 id="toc_5">开启Apple Pay</h3>

<blockquote>
<p>打开我们新建的工程, 然后添加我们的<strong><code>Merchant ID</code></strong>, 勾上<strong><code>Apple Pay</code></strong>的选项, 然后我们就来写实现代码啦~~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/21.png" alt="21"/></p>

<hr/>

<h3 id="toc_6">实现Apple Pay</h3>

<blockquote>
<p>实现<strong><code>Apple Pay</code></strong>的代码其实很简单, 遵循<strong><code>PKPaymentAuthorizationViewControllerDelegate</code></strong>代理, 实现两个必须实现的代理方法, 这是第一步, 第二步就是创建一个<strong><code>PKPaymentRequest</code></strong>请求, 然后再创建<strong><code>PKPaymentAuthorizationViewController</code></strong>, 最终就可以实现<strong><code>Apple Pay</code></strong>支付啦~下面是代码截图, 由于代码过多, 这里就不贴出来了, 大家需要的话, 就去看看Demo吧~~~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/22.png" alt="22"/><br/>
<img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/23.png" alt="23"/></p>

<blockquote>
<p>顺便说一声, <strong><code>Apple Pay</code></strong>的国际化不需要我们去实现, 内部就已经实现了</p>
</blockquote>

<hr/>

<h3 id="toc_7">最终效果</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/ApplePay-Objective-C/images/24.gif" alt="24"/></p>

<hr/>

<h3 id="toc_8">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/PayProject">https://github.com/CainRun/PayProject</a></p>

<hr/>

<h3 id="toc_9">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：集成 Union Pay - 银联支付]]></title>
    <link href="https://cainrun.github.io/14740149724404.html"/>
    <updated>2016-09-16T16:36:12+08:00</updated>
    <id>https://cainrun.github.io/14740149724404.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前面已经把<strong><code>WeChat SDK</code></strong>的支付, <strong><code>AliPay SDK</code></strong>搞得七七八八了, 接下来就是银联支付的<strong><code>Union Pay SDK</code></strong>.<br/>
<dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Union Pay SDK</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p>银联嘛, 用过银行卡的人都懂的, 我们大天朝的产物, 主要是用来联合大天朝各个银行, 实现各个银行互通, 可跨行, 跨区, 跨境使用等等....其实换了一句话来说, 就是中国版的<strong><code>VISA</code></strong>, <strong><code>MasterCard</code></strong>, 虽然银联起步的比较晚, 但发展的脚步不比<strong><code>VISA</code></strong>, <strong><code>MasterCard</code></strong>要差.</p>
</blockquote>

<hr/>

<h3 id="toc_2">准备工作</h3>

<blockquote>
<p>在这里, 我不得不吐槽一下, 如果是第一次集成银联的童鞋, 估计一开始还真是够呛的, 或许你连<strong><code>SDK</code></strong>都找不到在哪里下载, 这网站还真的很难找, 所以我在这里贴出来给你们了, 方便各位童鞋们自行去查找下载<strong><a href="https://open.unionpay.com">商家技术服务</a></strong><br/>
<dr/><br/>
这里还有怎么去查找SDK的示例, 大家也看看呗</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/2.png" alt="2"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/3.png" alt="3"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/4.png" alt="4"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/5.png" alt="5"/></p>

<blockquote>
<p>这里我下载下来的是3.3.3版本, 54.8MB大小, 或许之后银联会继续更新SDK包, 这个的话, 大家看着办吧~~</p>
</blockquote>

<hr/>

<h3 id="toc_3">废话来一段</h3>

<blockquote>
<p>惯例, 继续来一段废话, 打开我们之前的集成<strong><code>WeChat SDK</code></strong>和<strong><code>AliPay SDk</code></strong>的工程, 新建一个工程叫做<strong><code>UnionPay-Objective-C</code></strong>的新工程</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/6.png" alt="6"/></p>

<hr/>

<h3 id="toc_4">配置工程</h3>

<blockquote>
<p>配置工程的话, 首先我们要引入<strong><code>Union Pay SDK</code></strong>的依赖包, 一共五个, 这或许是第三方支付品台里需要导入最少依赖的.</p>

<ul>
<li>LocalAuthentication.framework</li>
<li>SystemConfiguration.framework</li>
<li>CoreGraphics.framework</li>
<li>CFNetwork.framework</li>
<li>libz.tbd</li>
</ul>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/7.png" alt="7"/></p>

<blockquote>
<p>然后呢, 我们需要去到<strong><code>Info.plist</code></strong>里, 添加三个属性</p>

<ul>
<li>App Transport Security Settings

<ul>
<li>Allow Arbitrary Loads</li>
</ul></li>
<li>Application requires iPhone environment</li>
<li>LSApplicationQueriesSchemes

<ul>
<li>uppaysdk</li>
<li>uppaywallet</li>
<li>uppayx1</li>
<li>uppayx2</li>
<li>uppayx3</li>
</ul></li>
</ul>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/8.png" alt="8"/></p>

<blockquote>
<p>接下来, 我们要去添加<strong><code>URL Schemes</code></strong>了, </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/9.png" alt="9"/></p>

<blockquote>
<p>最后, 就是我们要把<strong><code>Union Pay SDK</code></strong>导进来了, 这样子就配置好整个工程了, 顺带说一声, 这个<strong><code>SDK</code></strong>在<strong><code>paymentcontrol</code></strong>这个目录下~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/10.png" alt="10"/></p>

<blockquote>
<p>差点别忘了把<strong><code>-ObjC</code></strong>这个宏加上, 不然没法跑</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/11.png" alt="11"/></p>

<hr/>

<h3 id="toc_5">布局UI界面</h3>

<blockquote>
<p>惯例, 这里我们也是只给一个<strong><code>UIButton</code></strong>以及一个<strong><code>Action</code></strong>事件.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/12.png" alt="12"/></p>

<hr/>

<h3 id="toc_6">补充多一个点</h3>

<blockquote>
<p>这里还需要补充一个点, 由于银联是采用<strong><code>C</code></strong>、<strong><code>C++</code></strong>以及<strong><code>Objective-C</code></strong>混编的, 所以这个有些蛋疼, 官方提供三种方式去适配, 我这里采用了最简单的一种, 直接把<strong><code>.m</code></strong>改成<strong><code>.mm</code></strong>.</p>
</blockquote>

<p><strong><font color=purple>第一种</font></strong></p>

<blockquote>
<ul>
<li><p>由于支付控件使用到了<strong><code>C</code></strong>、<strong><code>C++</code></strong>和<strong><code>Objective-C</code></strong>混编的情况，所以商户工程引入<strong><code>UPPaymentControl.h</code></strong>头文件以后可能会出现链接错误，这个时候可以通过以下三种方式解决：</p>

<ul>
<li><p>将涉及到引用<strong><code>UPPaymentControl.h</code></strong>的源文件的后缀名都改为<strong><code>.mm</code></strong>；</p></li>
<li><p>如果商户不想修改源文件的后缀名，可以在工程中添加一个空的继承自<strong><code>NSObject</code></strong>的类，并将文件.m后缀名该改为.mm即可方法为<strong><code>New File</code></strong> -&gt; <strong><code>Objective-C class</code></strong> -&gt; <strong><code>类名自取</code></strong> -&gt; <strong><code>保存</code></strong> -&gt; <strong><code>修改后缀名为.mm</code></strong>；</p></li>
<li><p>将工程的<strong><code>compile source as</code></strong>选项的值设置为<strong><code>Objective–C++</code></strong>；</p></li>
</ul></li>
</ul>
</blockquote>

<p><strong><font color=purple>第二种</font></strong></p>

<blockquote>
<ul>
<li>由于在Demo工程中添加了自定义的库文件<strong><code>libPaymentControl.a</code></strong>
，当编译Demo工程时，应该检查工程设置<strong><code>Search Paths</code></strong>里的<strong><code>Framework Search Paths</code></strong>、<strong><code>Header Search Paths</code></strong>、<strong><code>Library Search Paths</code></strong>的路径设置，看设置路径是否正确，另外还要注意里边是否多余一些不确定的路径。</li>
</ul>
</blockquote>

<p><strong><font color=purple>第三种</font></strong></p>

<blockquote>
<ul>
<li>将<strong><code>Xcode</code></strong>工程中<strong><code>Build Setting</code></strong> -&gt; <strong><code>Apple LLVM compiler Language</code></strong>标签下的<strong><code>C++ Language Dialect</code></strong>和<strong><code>C++ Standard Library</code></strong>属性值修改为<strong><code>Compiler Default</code></strong>如实在无法解决，尝试添加<strong><code>-ObjC</code></strong>宏的地方修改为<strong><code>-force_load</code></strong> + <strong><code>空格</code></strong> + <strong><code>控件路径</code></strong>，如：<strong><code>-force_load $(PROJECT_DIR)/ libPaymentControl.a</code></strong>，如果还报错，上下文应该会有<strong><code>libPaymentControl.a</code></strong>文件找不到异常，比如<strong><code>ld: file not found: /Users/apple/Desktop/Communication 2/ libPaymentControl.a
clang: error: linker command failed with exit code 1 (use -v to see invocation)</code></strong>
请确定<strong><code>libPaymentControl.a</code></strong>文件确实存在于此路径，可能为上下文路径配错。</li>
</ul>
</blockquote>

<hr/>

<h3 id="toc_7">实现银联支付</h3>

<blockquote>
<p>集成的时候, 这里我们需要分为两个步骤, 一个是网络, 一个是本地操作.</p>
</blockquote>

<p><strong><font color=purple>本地部分</font></strong></p>

<blockquote>
<p>所谓的本地部分, 指的就是弹框, 灭框的一些操作, 还有发起网络一些点击事件等等.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/13.png" alt="13"/></p>

<p><strong><font color=purple>网络部分</font></strong></p>

<blockquote>
<p>银联支付需要用到一个网络交互的流程, 这里的话, 我们直接引用<strong><code>Demo</code></strong>里的代码, 然后再加以修改一丢丢, 就可以了~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/14.png" alt="14"/></p>

<hr/>

<h3 id="toc_8">测试支付</h3>

<blockquote>
<p>在测试支付这点上, 微信和银联都做的挺不错的, 唯独支付宝这个连个测试账号都不提供, 真的是蛋疼...疼...疼, 打开银联接入指南, 里面就会有两个测试卡号.</p>
</blockquote>

<table>
<thead>
<tr>
<th>测试账号</th>
<th>测试信息</th>
</tr>
</thead>

<tbody>
<tr>
<td>姓名</td>
<td>张三</td>
</tr>
<tr>
<td>手机号码</td>
<td>18100000000</td>
</tr>
<tr>
<td>证件类型</td>
<td>01身份证</td>
</tr>
<tr>
<td>证件号</td>
<td>510265790128303</td>
</tr>
<tr>
<td>招商银行卡</td>
<td>6226090000000048</td>
</tr>
<tr>
<td>密码</td>
<td>111101</td>
</tr>
<tr>
<td>验证码</td>
<td>123456（<strong><font color=red>先点获取验证码之后再输入</font></strong>）</td>
</tr>
</tbody>
</table>

<table>
<thead>
<tr>
<th>测试账号</th>
<th>测试信息</th>
</tr>
</thead>

<tbody>
<tr>
<td>姓名</td>
<td>张三</td>
</tr>
<tr>
<td>手机号码</td>
<td>18100000000</td>
</tr>
<tr>
<td>证件类型</td>
<td>01身份证</td>
</tr>
<tr>
<td>CVN2</td>
<td>248</td>
</tr>
<tr>
<td>有效期</td>
<td>1219</td>
</tr>
<tr>
<td>证件号</td>
<td>510265790128303</td>
</tr>
<tr>
<td>华夏银行贷记卡</td>
<td>6226388000000095</td>
</tr>
<tr>
<td>密码</td>
<td>111101</td>
</tr>
<tr>
<td>验证码</td>
<td>123456（<strong><font color=red>先点获取验证码之后再输入</font></strong>）</td>
</tr>
</tbody>
</table>

<hr/>

<h3 id="toc_9">最终效果</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/UnionPay-Objective-C/images/15.png" alt="15"/></p>

<hr/>

<h3 id="toc_10">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/PayProject">https://github.com/CainRun/PayProject</a></p>

<hr/>

<h3 id="toc_11">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：集成 AliPay - 支付宝]]></title>
    <link href="https://cainrun.github.io/14739456388212.html"/>
    <updated>2016-09-15T21:20:38+08:00</updated>
    <id>https://cainrun.github.io/14739456388212.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>前面我已经写了一篇关于<strong><code>WeChat SDK</code></strong>的支付篇, 那我们继续研究接下来的支付<strong><code>SDK</code></strong>, 这次就是国民支付软件<strong><code>支付宝</code></strong>, 下面就让我们来看看怎么集成<strong><code>AliPay SDK</code></strong>.<br/>
<dr/><br/>
<strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>AliPay SDK</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p>支付宝SDK, 只要做过支付类App的, 都百分百接触过, 至于为什么那么多人喜欢用支付宝, 这个我就不在这里做解释了, 大家都懂的, 但是呢, 由于在阿里巴巴的发展下, 支付宝慢慢与蚂蚁金服整合, 甚至连开放平台名字都改成<strong><code>蚂蚁金服开放平台</code></strong>, 但无论怎么样, 支付宝都是行业内安全性最高的,</p>
</blockquote>

<hr/>

<h3 id="toc_2">准备工作</h3>

<blockquote>
<p>其实集成<strong><code>AliPay SDK</code></strong>和<strong><code>WeChat SDK</code></strong>有些类似, 就连<strong><code>商家ID</code></strong>的申请, <strong><code>App ID</code></strong>的申请, 流程都差不多, 详细这里我就不在这里讲解了, 大家可以去<strong><a href="https://b.alipay.com/">支付宝商家商户服务平台</a></strong>了解了解.</p>
</blockquote>

<hr/>

<h3 id="toc_3">下载SDK包</h3>

<blockquote>
<p>由于蚂蚁金服和支付宝的整合, 就连SDK的资源都改了, 大家可以去<strong><a href="https://doc.open.alipay.com/">开放平台-文档中心</a></strong>找到资源下载.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/2.png" alt="2"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_4">继续来段废话</h3>

<blockquote>
<p>SDK包下载好了之后, 我们去到之前的那个支付工程建立我们的新工程, 命名为<strong><code>AliPay-Objective-C</code></strong>, 接下来我们就可以继续集成<strong><code>AliPay SDK</code></strong>了.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/4.png" alt="4"/></p>

<hr/>

<h3 id="toc_5">配置文件</h3>

<blockquote>
<p>现在我们建立好了工程, 然后我们和集成<strong><code>WeChat SDK</code></strong>一样, 需要配置一下工程, 这样子我们才能让<strong><code>AliPay SDK</code></strong>正常工作.<br/>
<dr/><br/>
现在让我们来打开工程的<strong><code>Info.plist</code></strong>文件, 添加一些配置.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/5.png" alt="5"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/6.png" alt="6"/></p>

<hr/>

<h3 id="toc_6">添加依赖包</h3>

<blockquote>
<p>和<strong><code>WeChat SDK</code></strong>一样, <strong><code>AliPay SDK</code></strong>一样是需要导入依赖包的, 但是这个依赖包要比<strong><code>WeChat SDK</code></strong>要多一些, 这个比较蛋疼.</p>

<ul>
<li><strong>UIKit.framework</strong></li>
<li><strong>CoreMotion.framework</strong></li>
<li><strong>CFNetWork.framework</strong></li>
<li><strong>Foundation.framework</strong></li>
<li><strong>CoreGraphics.framework</strong></li>
<li><strong>CoreText.framework</strong></li>
<li><strong>QuartzCore.framework</strong></li>
<li><strong>CoreTelephony.framework</strong></li>
<li><strong>SystemConfiguration.framework</strong></li>
<li><strong>libz.tbd</strong></li>
<li><strong>libc++.tbd</strong></li>
</ul>

<p><dr/><br/>
这些都是所需的依赖库, 真的是非常的蛋疼.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/7.png" alt="7"/></p>

<hr/>

<h3 id="toc_7">注册App ID</h3>

<blockquote>
<p>由于<strong><code>AliPay SDK</code></strong>是不需要在<strong><code>AppDelegate.m</code></strong>文件里注册的, 所以注册<strong><code>App ID</code></strong>这个步骤我们就忽略了.</p>
</blockquote>

<hr/>

<h3 id="toc_8">布局UI界面</h3>

<blockquote>
<p>这里的UI布局界面就和<strong><code>WeChat SDK</code></strong>那样, 直接拖一个<strong><code>UIButton</code></strong>, 以及加一个<strong><code>Action</code></strong>事件就好了.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/8.png" alt="8"/></p>

<hr/>

<h3 id="toc_9">注意!!!</h3>

<blockquote>
<p>由于<strong><code>AliPay</code></strong>改版了, 如果是老版本的SDK需要更新到最新的话, 一定要去好好的读一下接口文档, 因为这里需要添加多两个额外库以及一些依赖的签名文件, 这两个库在<strong><code>AliPay</code></strong>的资源包里可以找到.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/9.png" alt="9"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/10.png" alt="10"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/11.png" alt="11"/></p>

<blockquote>
<p>把这些依赖文件都拖入我们的工程里, 这样子我们就能正常的完成开发了~~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/12.png" alt="12"/></p>

<hr/>

<h3 id="toc_10">集成SDK</h3>

<blockquote>
<p>之前的所有准备工作都已经做好了, 现在重点来了, 就让我们看看怎么实现支付宝支付!</p>
</blockquote>

<p><dr/></p>

<blockquote>
<p>首先我们需要一个订单对象, 这里我们命名为<strong><code>AliPayOther</code></strong>, 还有一个<strong><code>AliPayBizContent</code></strong>, 然后声明一些属性, 并且在内部实现一些方法, 由于这里的代码比较多, 这里就不列举了, 各位童鞋们还是自行去翻翻工程吧~~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/13.png" alt="13"/></p>

<blockquote>
<p>然后呢, 我们就要把两个重量级的文件拖入到工程, 一个就是<strong><code>AlipaySDK.bundle</code></strong>, 一个是<strong><code>AlipaySDK.framework</code></strong>, 这两个文件也是在<strong><code>AliPay</code></strong>的资源包里可以找到.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/14.png" alt="14"/></p>

<blockquote>
<p>导入之后编译一下, Xcode居然提示出错了!!!</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/15.png" alt="15"/></p>

<blockquote>
<p>看了一下错误信息, 提示<strong><code>NSObject</code></strong>, 我想应该是<strong><code>&lt;Foundation/Foundation.h&gt;</code></strong>没有导入到对应的文件里去吧, 试试看先</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/16.png" alt="16"/></p>

<blockquote>
<p>我屮艸芔茻, 一些问题解决了, 另一些问题又出来了, 仔细一看, 我勒个去, 原来是忘了导入刚刚所说的<strong><code>libcrypto.a</code></strong>以及<strong><code>libssl.a</code></strong>库了...我说怎么好像少了两个东西, 赶紧导入进去~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/17.png" alt="17"/></p>

<blockquote>
<p>导入完之后, 还有一个错误, 我也是醉醉哒....尼玛, 这是玩我呢....以前导入SDK那有那么麻烦啊...翻了一下文档, 发现要添加一个<strong><code>Header</code></strong>的链接....我也是醉了, 这个链接的写法是<strong><code>$(SRCROOT)/(工程名)</code></strong>, 我这里所写的是<strong><code>$(SRCROOT)/AliPay-Objective-C</code></strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/18.png" alt="18"/></p>

<hr/>

<h3 id="toc_11">实现支付宝支付</h3>

<blockquote>
<p>好了, 我们把遇到的坑填完之后, 现在就来实现支付宝支付, 这里我们就直接把<strong><code>AliPayDemo</code></strong>里的代码直接拷贝过来, </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/19.png" alt="19"/></p>

<blockquote>
<p>添加完之后, 别忘了处理<strong><code>AliPay</code></strong>回调回来的信息, 顺便说说, 这里的代理方法会有两个, 一个是<strong><code>iOS 9</code></strong>之后才有的新方法, 大家可以动动小脑袋, 看看怎么样封装才会比较好一些~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/20.png" alt="20"/></p>

<blockquote>
<p>到这里我们就已经集成完毕了, 由于支付宝的Demo里没有提供<strong><code>App ID</code></strong>和<strong><code>私钥</code></strong>, 所以我们这里显示的效果只能是酱紫了...需要测试的童鞋们只能自己去申请<strong><code>App ID</code></strong>和<strong><code>私钥</code></strong>了</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/AliPay-Objective-C/images/21.png" alt="21"/></p>

<hr/>

<h3 id="toc_12">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/PayProject">https://github.com/CainRun/PayProject</a></p>

<hr/>

<h3 id="toc_13">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：集成 WeChat SDK - 支付篇]]></title>
    <link href="https://cainrun.github.io/14735762460993.html"/>
    <updated>2016-09-11T14:44:06+08:00</updated>
    <id>https://cainrun.github.io/14735762460993.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>惯例, 开头都是要说些东西的了, 随着现在的App越来越商业化, 很多公司的App都会集成第三方的支付SDK, 这样子的成本就比较低, 但是呢, 有很多朋友还是不太会集成, 也不太爱看集成文档(我也是~), 想了想, 还是写一篇关于支付的文章吧, 现在写的是<strong><code>微信支付</code></strong>, 过段时间就把<strong><code>支付宝</code></strong>, <strong><code>银联</code></strong>, <strong><code>Apple Pay</code></strong>的也补上.</p>

<p><strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>WeChat支付</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p>微信SDK, 一个集成了社会化分享以及财付通支付功能的SDK, 需要商家先去微信开放平台先登记注册, 审批过后才能获得商家ID, 这样子才能使用支付功能, 下面让我们一起来看看吧.</p>
</blockquote>

<hr/>

<h3 id="toc_2">准备工作</h3>

<blockquote>
<p>首先, 我们要来做好准备工作: </p>

<ul>
<li>1.申请商家ID</li>
<li>2.申请App ID</li>
<li>3.下载, 集成SDK包</li>
<li>4.添加依赖包</li>
<li>5.最后, 调起支付<br/><br/></li>
</ul>

<p>做好以上的工作, 微信的SDK集成就告一段落了~</p>
</blockquote>

<hr/>

<h3 id="toc_3">申请商家ID</h3>

<blockquote>
<p>这里就不做详细介绍了, 毕竟我们这里讲的是如何集成SDK, 如果想了解的童鞋, 可以自行去<strong><a href="https://mp.weixin.qq.com/">微信公众平台</a></strong>自行查看哈~</p>
</blockquote>

<hr/>

<h3 id="toc_4">申请App ID</h3>

<blockquote>
<p>申请<strong><code>App ID</code></strong>这里也不做介绍, 这个步骤也很简单, 直接去<strong><a href="https://open.weixin.qq.com/">微信开放平台</a></strong>, 根据对应的指导信息, 一步一步的往下填写就OK了, 微信的<strong><code>App ID</code></strong>是需要审核时间的, 快的话几分钟, 慢的话, 慢慢等吧~~</p>
</blockquote>

<hr/>

<h3 id="toc_5">下载SDK包</h3>

<blockquote>
<p>下载SDK包, 这个更加的简单了, 直接去到<strong><a href="https://open.weixin.qq.com/cgi-bin/showdocument?action=dir_list&amp;t=resource/res_list&amp;verify=1&amp;id=open1419319164&amp;token=&amp;lang=zh_CN">资源中心</a></strong>看到<strong><code>iOS开发工具包64位<br/>
</code></strong>就赶紧毫不犹豫的直接点下载, </p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/1.png" alt="1"/></p>

<blockquote>
<p>下载完成之后, 我们来看看SDK包里都有啥</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/2.png" alt="2"/></p>

<blockquote>
<p>我看了看2.0版本的Demo, 里面居然是没有微信支付的相关代码, 这相当蛋疼, 如果是第一次集成的童鞋们, 那就要哭了...不过好在我们用庞大的互联网搜索引擎, 谷歌, 百度, 这些问题都是可以解决的, </p>
</blockquote>

<hr/>

<h3 id="toc_6">再废话一段</h3>

<blockquote>
<p>废话讲了那么多, 现在让我们来看看怎么集成DSK包, 我们先创建一个<strong><code>WorkSpace</code></strong>文件, 叫<strong><code>PayProject</code></strong>, 然后再创建我们的第一个工程<strong><code>WeChatPay-Objective-C</code></strong>, 由于之前有人和我反应过, 为啥没有<strong><code>Swift</code></strong>版本的, 其实不是我想写<strong><code>Swift</code></strong>版本, 是它的语法到现在居然都还没有定型, 每个版本改一丢丢, 这比较蛋疼, 现在有人反应, 那我今后也把<strong><code>Swift</code></strong>版本给补上吧, 如果以后语法继续有更改, 那大家就根据自己的编程经验以及<strong><code>Xcode</code></strong>的提示自行修改哈~~</p>
</blockquote>

<hr/>

<h3 id="toc_7">配置工程</h3>

<blockquote>
<p>打开我们创建好的<strong><code>WeChatPay-Objective-C</code></strong>工程, 把<strong><code>SDK</code></strong>包拖进去, 这里的文件夹我改名字了, 你们也可以根据你们自己的喜好来改</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/3.png" alt="3"/></p>

<blockquote>
<p>添加完<strong><code>SDK</code></strong>包之后, 我们还要操作某些东西, 因为在<strong><code>iOS 9</code></strong>之后, 苹果限制了正常的<strong><code>HTTP</code></strong>请求, 如果我们要继续用, 就得先配置一下~~在微信的<strong><code>SDK</code></strong>文件夹里也有声明</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/4.png" alt="4"/></p>

<blockquote>
<p>打开工程, 找到工程的<strong><code>Info.plist</code></strong>文件, 直接添加就好了, 有时候Xcode不会提示, 需要我们手动填入, 这个就比较蛋疼了, 我这里就列举出来吧</p>

<ul>
<li>Application requires iPhone environment</li>
<li>LSApplicationQueriesSchemes</li>
<li>App Transport Security Settings

<ul>
<li>Allow Arbitrary Loads</li>
</ul></li>
</ul>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/5.png" alt="5"/></p>

<blockquote>
<p>添加完这些之后, 还是不够的, 我们需要去添加一个<strong><code>URL Schemes</code></strong>, 这里我先提供一个<strong><code>App ID</code></strong>, 是从以前的微信官方Demo里拷贝下来的~~<strong><code>wxb4ba3c02aa476ea1</code></strong>, 童鞋们自动复制粘贴哈, 这个时候, 我们就要打开工程配置了, 然后添加微信的<strong><code>URL Schemes</code></strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/6.png" alt="6"/></p>

<blockquote>
<p>到这一步, 基本上这个阶段已经告已段落了, 继续下一个阶段~~~</p>
</blockquote>

<hr/>

<h3 id="toc_8">添加依赖包</h3>

<blockquote>
<p>使用第三方<strong><code>SDK</code></strong>最蛋疼的一件事就是需要添加很多的依赖包, 因为第三方需要做数据的收集, 或者其他操作之类的, 这样子你才能在他们的后台列表了查询到你的App流量, 微信的依赖包有好几个, </p>

<ul>
<li>UIKit.framework</li>
<li>Foundation.framework</li>
<li>SystemConfiguration.framework</li>
<li>CoreTelephony.framework</li>
<li>Security.framework</li>
<li>libz.tbd</li>
<li>libc++.tbd</li>
<li>libsqlite3.tbd<br/><br/></li>
</ul>

<p>现在我们就来添加这些依赖包吧, 怎么添加应该不用我说了吧0.0</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/7.png" alt="7"/></p>

<hr/>

<h3 id="toc_9">注册AppID</h3>

<blockquote>
<p>前期工作我们都做完了, 现在我们就用代码来实现微信支付~, 首先我们肯定要先注册一下微信<strong><code>App ID</code></strong>, 不然别说支付了, 就连分享神马之类的功能你都没法用, 打开<strong><code>AppDelegate.m</code></strong>, 导入<strong><code>WXApi.h</code></strong>文件, 注册<strong><code>App ID</code></strong>, 这个<strong><code>App ID</code></strong>, 就是我刚刚提供的那个<strong><code>wxb4ba3c02aa476ea1</code></strong>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/8.png" alt="8"/></p>

<hr/>

<h3 id="toc_10">布局UI</h3>

<blockquote>
<p>要调起微信支付, 我们肯定要有一个点击事件, 这里的<strong><code>UI</code></strong>, 我们就只给个<strong><code>UIButton</code></strong>和一个<strong><code>Action</code></strong>事件就好了.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/9.png" alt="9"/></p>

<hr/>

<h3 id="toc_11">调起微信支付</h3>

<blockquote>
<p>重头戏来了, 前面做了那么多的工作, 写了那么多的废话, 只为了现在真正的调起微信支付进行支付~~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/10.png" alt="10"/></p>

<blockquote>
<p>实现代码都给你们贴出来了~这是我在以前的官方Demo中拷贝出来的~ <br/>
<br/></p>

<p><strong><font color=red>PS: 这里是Demo, 所以这里拿到的神马签名啊, 商户ID, 支付链接神马的, 都是写在客户端的, 但在实际开发当中, 这是强烈不建议在客户端内自己生成, 一定一定要由服务器返回, 不然你会非常深刻的了解到蛋疼这个词语是啥意思~~</font></strong></p>
</blockquote>

<pre><code class="language-objectivec">    NSString *urlString = @&quot;http://wxpay.weixin.qq.com/pub_v2/app/app_pay.php?plat=ios&quot;;
    
    NSURLRequest *request = [NSURLRequest requestWithURL:[NSURL URLWithString:urlString]];
    
    NSOperationQueue *queue = [[NSOperationQueue alloc] init];
    
    [NSURLConnection sendAsynchronousRequest:request
                                       queue:queue
                           completionHandler:^(NSURLResponse * _Nullable response, NSData * _Nullable data, NSError * _Nullable connectionError) {
                               
                               if (data != nil) {
                                   
                                   NSError *error;
                                   NSMutableDictionary *dictionart = NULL;
                                   
                                   dictionart = [NSJSONSerialization JSONObjectWithData:data
                                                                          options:NSJSONReadingMutableLeaves
                                                                            error:&amp;error];
                                   
                                   NSLog(@&quot;URL: %@&quot;, urlString);
                                   
                                   if (dictionart != nil) {
                                       
                                       NSMutableString *retCode = [dictionart objectForKey:@&quot;retcode&quot;];
                                       
                                       if (retCode.integerValue == 0) {
                                           
                                           NSMutableString *stamp = [dictionart objectForKey:@&quot;timestamp&quot;];
                                           
                                           // 调起微信支付
                                           PayReq *req   = [[PayReq alloc] init];
                                           req.partnerId = [dictionart objectForKey:@&quot;partnerid&quot;];
                                           req.prepayId  = [dictionart objectForKey:@&quot;prepayid&quot;];
                                           req.nonceStr  = [dictionart objectForKey:@&quot;noncestr&quot;];
                                           req.timeStamp = stamp.intValue;
                                           req.package   = [dictionart objectForKey:@&quot;package&quot;];
                                           req.sign      = [dictionart objectForKey:@&quot;sign&quot;];
                                           
                                           [WXApi sendReq:req];
                                           
                                           // 日志输出
                                           NSLog(@&quot;appid = %@&quot;, [dictionart objectForKey:@&quot;appid&quot;]);
                                           NSLog(@&quot;partnerId = %@&quot;, req.partnerId);
                                           NSLog(@&quot;prepayId = %@&quot;, req.prepayId);
                                           NSLog(@&quot;nonceStr = %@&quot;, req.nonceStr);
                                           NSLog(@&quot;timeStamp = %d&quot;, req.timeStamp);
                                           NSLog(@&quot;package = %@&quot;, req.package);
                                           NSLog(@&quot;sign = %@&quot;, req.sign);
                                           
                                       } else {
                                           
                                           NSLog(@&quot;retmsg: %@&quot;, [dictionart objectForKey:@&quot;retmsg&quot;]);
                                       }
                                   } else {
                                       
                                       NSLog(@&quot;服务器返回错误, 未获取到JSON对象&quot;);
                                   }
                               } else {
                                   
                                   NSLog(@&quot;服务器返回错误&quot;);
                               }
                           }];
</code></pre>

<hr/>

<h3 id="toc_12">处理回调结果</h3>

<blockquote>
<p>实现代码我们都搞定了, 现在我们差的就是要处理微信回调回来的结果, 无论你支付成功或者是支付失败, 还是微信服务器爆炸了, 这个结果我们都要获取到, 还有对应的<strong><code>errCode</code></strong>.<br><br/>
打开<strong><code>AppDelegate.m</code></strong>, 我们要添加微信的代理协议, 实现一个微信的代理方法, 以及<strong><code>AppDelegate</code></strong>的两个方法</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/11.png" alt="11"/></p>

<blockquote>
<p>具体实现的代码</p>
</blockquote>

<pre><code class="language-Objectivec">- (void)onResp:(BaseResp *)resp {
    
    if ([resp isKindOfClass:[PayResp class]]) {
        
        NSString *stringMessage = @&quot;支付结果&quot;;
        NSString *stringTitle  = @&quot;支付结果&quot;;
        
        switch (resp.errCode) {
            case WXSuccess:
                
                stringMessage = @&quot;支付结果: 成功!&quot;;
                
                NSLog(@&quot;支付成功 - PaySuccess, retCode = %d&quot;, resp.errCode);
                
                break;
            default:
                
                stringMessage = [NSString stringWithFormat:@&quot;支付结果: 失败!, retcode = %d, retstr = %@&quot;, resp.errCode, resp.errStr];
                
                break;
        }
        
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:stringTitle
                                                            message:stringMessage
                                                           delegate:nil
                                                  cancelButtonTitle:@&quot;好的&quot;
                                                  otherButtonTitles:nil, nil];
        
        [alertView show];
    }
}

- (BOOL)application:(UIApplication *)application
      handleOpenURL:(NSURL *)url {
    
    return [WXApi handleOpenURL:url delegate:self];
}

- (BOOL)application:(UIApplication *)application
            openURL:(NSURL *)url
  sourceApplication:(NSString *)sourceApplication
         annotation:(id)annotation {
    
    return [WXApi handleOpenURL:url delegate:self];
}
</code></pre>

<hr/>

<h3 id="toc_13">最终效果</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/12.gif" alt="12"/></p>

<hr/>

<h3 id="toc_14">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/PayProject">https://github.com/CainRun/PayProject</a></p>

<hr/>

<h3 id="toc_15">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：iOS 8 新特性《UIVisualEffect》]]></title>
    <link href="https://cainrun.github.io/14730058185822.html"/>
    <updated>2016-09-05T00:16:58+08:00</updated>
    <id>https://cainrun.github.io/14730058185822.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在iOS 8发布的时候, <strong><code>Apple</code></strong>介绍了很多<strong><code>iOS 8</code></strong>的新特性, 比如什么<strong><code>Extensions</code></strong>,<strong><code>Photo</code></strong>,<strong><code>Siri</code></strong>等等之类的, 虽然讲了不少, 但也有很多东西被忽略掉的, 比如今天我们所讲的<strong><code>UIVisualEffect</code></strong>.<br/>
<dr/><br/>
有人会问, 这个类是干嘛的呢? 有人又会说, 这个类我用过, 但不好用等等之类的<br/>
<dr/><br/>
的确, 这个类的确是不太好用, 限制性太强了, 能使用的<strong><code>API</code></strong>也就一丢丢, 对于现在的需求逐渐多元化来说, 是远远不够的, 但我们可以期待一下, 或许以后苹果会逐渐的开放这个控件呢~</p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong><code>UIVisualEffect</code></strong>这个控件其实就是一个高斯模糊的一个实现的类, 它继承与<strong><code>NSObject</code></strong>, 有三种样式, 分别是: </p>

<ul>
<li><strong><code>UIBlurEffectStyleExtraLight</code></strong></li>
<li><strong><code>UIBlurEffectStyleLight</code></strong></li>
<li><strong><code>UIBlurEffectStyleDark</code></strong></li>
</ul>

<p><dr/><br/>
有一个子类叫做<strong><code>UIVibrancyEffect</code></strong>, 还有一个可调用<strong><code>UIVisualEffect</code></strong>的类叫做<strong><code>UIVisualEffectView</code></strong>, 下面让我们来看看怎么去使用吧.</p>
</blockquote>

<hr/>

<h3 id="toc_2">新建工程</h3>

<blockquote>
<p>这里我们建了一个叫做<strong><code>UIVisualEffect</code></strong>的工程</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/New-Features-For-iOS-8/master/03.UIVisualEffect/images/0.png" alt="0"/></p>

<hr/>

<h3 id="toc_3">布局UI界面</h3>

<blockquote>
<p>建完一个工程之后, 我们来布局一下UI, 由于这个类有三种样式, 所以我们这里就建立三个<strong><code>UIButton</code></strong>, 并且新建三个<strong><code>ViewController</code></strong>, 这样子我们就能比较清晰的看到三种不同的效果了.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/New-Features-For-iOS-8/master/03.UIVisualEffect/images/1.png" alt="1"/></p>

<blockquote>
<p>这个是和<strong><code>Storyboard</code></strong>绑定好的页面, 这样子, 我们就可以根据点击自己想要的按钮就跳转到对应的页面去了</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/New-Features-For-iOS-8/master/03.UIVisualEffect/images/2.png" alt="2"/></p>

<blockquote>
<p>在实现之前, 我偷偷的丢了一张图片在工程里面, 也对UI进行了一个布局, 并且关联了其中一个图片的属性, 这里大家凑合着看吧, 毕竟丑~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/New-Features-For-iOS-8/master/03.UIVisualEffect/images/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_4">实现对应的效果</h3>

<blockquote>
<p>这里我只拿<strong><code>ExtraLight</code></strong>效果来做演示, 其他的两种效果大家可以自行去翻查一下<strong><code>Demo</code></strong>代码, 代码都是比较简单的~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/New-Features-For-iOS-8/master/03.UIVisualEffect/images/4.png" alt="4"/></p>

<blockquote>
<p>这样子就完成了, 下面是具体实现的代码:</p>
</blockquote>

<pre><code class="language-Objectivec">    self.title = NSStringFromClass(self.class);
    
    UIBlurEffect *blurEffect = [UIBlurEffect effectWithStyle:UIBlurEffectStyleDark];
    
    UIVisualEffectView *visualEffectView = [[UIVisualEffectView alloc] initWithEffect:blurEffect];
    
    visualEffectView.alpha = 0.5;
    
    visualEffectView.frame = self.imageView.bounds;
    
    [self.imageView addSubview:visualEffectView];
</code></pre>

<hr/>

<h3 id="toc_5">最终效果</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/New-Features-For-iOS-8/master/03.UIVisualEffect/images/5.gif" alt="5"/></p>

<hr/>

<h3 id="toc_6">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/New-Features-For-iOS-8">https://github.com/CainRun/New-Features-For-iOS-8</a></p>

<h3 id="toc_7">最后</h3>

<p><center>码字很费脑, 看官赏点饭钱可好</center></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E5%BE%AE%E4%BF%A1QRC.jpg" alt="微信"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/PayProject/master/WeChatPay-Objective-C/Images/%E6%94%AF%E4%BB%98%E5%AE%9DQRC.jpg" alt="支付宝"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：横向滑动条《CALToolBarListView》]]></title>
    <link href="https://cainrun.github.io/14729678790305.html"/>
    <updated>2016-09-04T13:44:39+08:00</updated>
    <id>https://cainrun.github.io/14729678790305.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>关于横向滑动条, 我一直都想自己封装一个, 但由于精力有限, 目前只能封装个比较简陋的, 如果有朋友想帮忙完善一下的话, 可以私聊我, 我给你开通一下权限哈~~</p>

<p><strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>CALToolBarListView</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p><strong><code>CALToolBarListView</code></strong>是一个仿<strong><code>UISegmentedControl</code></strong>的一个<strong><code>UI控件</code></strong>, 在刚开始设计的时候, 注重点就是为了灵活性, 可以自定义标题颜色, 选中提示条的颜色等等, 目前只有两个样式, 当然, 你可以根据我提供的源码来自行添加你所喜欢的样式</p>
</blockquote>

<hr/>

<h2 id="toc_2"><p align="center">使用说明</p></h2>

<h3 id="toc_3">初始化</h3>

<blockquote>
<p>在使用<strong><code>CALToolBarListView</code></strong>的时候必须得通过以下的初始化方法来进行初始化, 并且<strong><code>titleArray</code></strong>不能为空, 否则就会<strong><code>Crash</code></strong>.</p>
</blockquote>

<pre><code class="language-objectivec">/**
 *  初始化TooBar
 *
 *  @param frame      设置TooBar的Frame
 *
 *  @return self
 */
- (instancetype)initToolBarWithFrame:(CGRect)frame;
</code></pre>

<hr/>

<h3 id="toc_4">通用属性</h3>

<pre><code class="language-objectivec">/**
 *  是否根据按钮宽度自动缩小标题, default: NO
 */
@property (nonatomic, assign) BOOL titleAdjustsFontSizeToFitWidth;

/**
 *  选中的按钮文字的颜色, default: redColor
 */
@property (nonatomic, strong) UIColor *selectedColor;

/**
 *  非选中的按钮文字的颜色, default: blackColor
 */
@property (nonatomic, strong) UIColor *deselectColor;

/**
 *  背景颜色, default: whiteColor
 */
@property (nonatomic, strong) UIColor *barBakcgroundColor;

/**
 *  底部线条的颜色, default: grayColor
 */
@property (nonatomic, strong) UIColor *bottomLineColor;

/**
 *  选中按钮提示条的颜色, default: cyanColor
 */
@property (nonatomic, strong) UIColor *selectedLineColor;

/**
 *  按钮文字大小, default: 16
 */
@property (nonatomic, assign) NSInteger textFont;

/**
 *  按钮之间的间距, default: 10
 */
@property (nonatomic, assign) CGFloat buttonSpacing;

/**
 *  是否需要底部线
 */
@property (nonatomic, assign) BOOL isNeedLine;

/**
 *  是否需要选中提示条
 */
@property (nonatomic, assign) BOOL isNeedSelectedLine;

/**
 *  当前点击的currentIndex, default: 0
 */
@property (nonatomic, getter=currentIndex) NSInteger currentIndex;
</code></pre>

<hr/>

<h3 id="toc_5">显示样式</h3>

<blockquote>
<p>在这里我提供了两个显示的样式</p>
</blockquote>

<pre><code class="language-objectivec">typedef NS_ENUM(NSInteger, CALToolBarStyle) {
    CALToolBarNormalStyle = 0,
    CALToolBarSeparationStyle
};
</code></pre>

<blockquote>
<p>可以通过下面这个属性进行设置, 默认是<strong><code>CALToolBarNormalStyle</code></strong></p>
</blockquote>

<pre><code class="language-objectivec">/**
 *  设置ToolBar显示的样式, default: CALToolBarNormalStyle
 */
@property (nonatomic, assign) CALToolBarStyle toolBarStyle;
</code></pre>

<blockquote>
<p><strong><code>CALToolBarNormalStyle</code></strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CALToolBarView/master/images-File/CALToolBarNormalStyle.png" alt="1"/></p>

<blockquote>
<p><strong><code>CALToolBarSeparationStyle</code></strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CALToolBarView/master/images-File/CALToolBarSeparationStyle.png" alt="2"/></p>

<blockquote>
<p>选择样式二的时候, 可通过以下的属性修改显示的颜色</p>
</blockquote>

<pre><code class="language-objectivec">/**
 *  Seoaration分割线的颜色
 *  注意: 前提是你设置了toolBarStyle为CALToolBarSeparationStyle才有效, 默认为grayColor
 */
@property (nonatomic, strong) UIColor *separationColor;
</code></pre>

<hr/>

<h3 id="toc_6">通用方法</h3>

<blockquote>
<p>首先肯定是最常用的方法<strong><code>reloadData</code></strong>, 是用来刷新整个<strong><code>CALToolBarListView</code></strong>数据的方法, 只有调用了这个方法, <strong><code>CALToolBarListView</code></strong>才会显示对应的数据.<br/>
<code>objectivec<br/>
/**<br/>
 *  刷新整个列表<br/>
 */<br/>
- (void)reloadData;<br/>
</code></p>

<p>以下这个方法是默认选中指定<strong><code>Index</code></strong>的按钮, 但需要注意一点就是, 必须现有数据才能调用, 否则直接调用时无效的.<br/>
<code>objectivec<br/>
/**<br/>
 *  指定当前选中的Button Index<br/>
 *  @param 注意: 使用该方法, 必须先得实现reloadData的方法, 否则不生效<br/>
 *  @param index 指定当前选中的Button Index<br/>
 */<br/>
- (void)didSelectedButton:(NSInteger)index;<br/>
</code></p>

<p>以下这个方法是获取对应按钮的点击事件, 在这里我就没有使用代理来写, 毕竟写代理会增加更多的代码, 直接用一个<strong><code>Block</code></strong>就完事<br/>
<code>objectivec<br/>
/**<br/>
 *  点击事件Block<br/>
 */<br/>
@property (nonatomic, copy) void(^calToolBarSelectedBlock)(NSInteger index);<br/>
</code></p>
</blockquote>

<hr/>

<h3 id="toc_7">演示代码</h3>

<blockquote>
<p>以下就是使用的演示代码, 方便大家直接查看代码</p>
</blockquote>

<pre><code class="language-objectivec">    NSArray *titleArray = @[@&quot;标题一&quot;, @&quot;标题二&quot;, @&quot;标题三&quot;, @&quot;标题四&quot;, @&quot;标题五&quot;];

    CALToolBarListView *toolBarList = [[CALToolBarListView alloc] initToolBarWithFrame:CGRectMake(0, 250, self.view.frame.size.width, 40)
                                                                            titleArray:titleArray];
    toolBarList.barBakcgroundColor = [UIColor greenColor];
    toolBarList.selectedLineColor  = [UIColor redColor];
    toolBarList.bottomLineColor    = [UIColor blueColor];
    toolBarList.toolBarStyle       = CALToolBarSeparationStyle;
    toolBarList.separationColor    = [UIColor grayColor];
    
    [toolBarList reloadData];
    [toolBarList didSelectedButton:3];
    
    NSLog(@&quot;currentIndex: %zd&quot;, toolBarList.currentIndex);
    
    [toolBarList setCalToolBarSelectedBlock:^(NSInteger index) {
        NSLog(@&quot;index: %zd&quot;, index);
    }];
    
    [self.view addSubview:toolBarList];
</code></pre>

<hr/>

<h3 id="toc_8">展示效果</h3>

<blockquote>
<p>请原谅我用的渣渣<strong><code>GIF</code></strong>录制工具....</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CALToolBarView/master/images-File/demo.gif" alt="demo"/></p>

<hr/>

<h3 id="toc_9">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CALToolBarView">https://github.com/CainRun/CALToolBarView</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：使用自定义《UIActivity》进行内容分享]]></title>
    <link href="https://cainrun.github.io/14729665774054.html"/>
    <updated>2016-09-04T13:22:57+08:00</updated>
    <id>https://cainrun.github.io/14729665774054.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>在我写这篇文章的时候, 虽然国内有一堆文章介绍<strong><code>UIActivityViewController</code></strong>和<strong><code>UIActivity</code></strong>, 但都是零零散散的, 哪怕我翻墙出去看<strong><code>YouTube</code></strong>, 或者是著名的<strong><a href="http://nshipster.com/uiactivityviewcontroller/">黑胡子博客</a></strong>, 都没有详细的讲解怎么去自定义所需的<strong><code>UIActivity</code></strong>, 最后基本上翻遍了谷歌, 才找到了所需的.</p>

<p><strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>UIActivityViewController</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p>这段时间有很多朋友都问我关于怎么去集成<strong><code>ShareSDK</code></strong>或者<strong><code>友盟社会化分享SDK</code></strong>的问题, 其实我想说, <strong><code>Apple</code></strong>一开始就提供了一个类, 供我们去使用分享了, 在<strong><code>iOS 6</code></strong>之后更加增强了这个类, 使我们不再需要集成第三方的, 而且还支持自定义分享的<strong><code>item</code></strong>.</p>
</blockquote>

<hr/>

<h3 id="toc_2">创建新工程</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/1.png" alt="1 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/2.png" alt="2 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_3">创建一个继承与UIActivityViewController的类</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/3.png" alt="3 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/4.png" alt="4 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_4">创建一个继承与UIActivity的类</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/5.png" alt="5 | center | 1080x0"/></p>

<blockquote>
<p>这时候我们就要来给这个自定义的<strong><code>UIActivity</code></strong>类写上我们需要的内容, 首先我们可以去到系统提供的<strong><code>UIActivity</code></strong>头文件看<strong><code>API</code></strong>, 获取我们所需的<strong><code>API</code></strong>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/6.png" alt="6  | center | 1080x0"/></p>

<hr/>

<h3 id="toc_5">配置UIActivity和UIActivityViewController</h3>

<blockquote>
<p>下面是我写好的自定义<strong><code>WeiboActivity</code></strong> <strong><code>API</code></strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/7.png" alt="7  | center | 1080x0"/></p>

<blockquote>
<p>具体实现的代码:</p>
</blockquote>

<pre><code class="language-Objective-c">#import &quot;WeiboActivity.h&quot;

@implementation WeiboActivity

- (NSString *)activityType {
    
    return @&quot;CustomWeiboActivity&quot;;
}

- (NSString *)activityTitle {
    
    return @&quot;新浪微博&quot;;
}

- (UIImage *)activityImage {
    
    return [UIImage imageNamed:@&quot;ShareBundle.bundle/share_icon_1&quot;];
}

- (void)performActivity {
    [self activityDidFinish:YES];
}

@end
</code></pre>

<blockquote>
<p>下面是我写好的自定义<strong><code>UIActivityController</code></strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/8.png" alt="8  | center | 1080x0"/></p>

<blockquote>
<p>具体实现的代码:</p>
</blockquote>

<pre><code class="language-Objective-c">#import &quot;UIActivityController.h&quot;
#import &quot;WeiboActivity.h&quot;

#define CAL_GET_OBJECT(objc) if (objc) return objc

@interface UIActivityController ()

@property (nonatomic, strong) WeiboActivity *weiboActivity;

@end

@implementation UIActivityController

- (instancetype)initAspActivityControllerWithContent:(NSArray *)activityContent {
    
    NSArray *activitys = @[self.weiboActivity];
    
    if (self = [super initWithActivityItems:activityContent applicationActivities:activitys]) {
        
        self.excludedActivityTypes = @[UIActivityTypePostToFacebook,
                                       UIActivityTypePostToTwitter,
                                       UIActivityTypePostToWeibo,
                                       UIActivityTypeMail,
                                       UIActivityTypePrint,
                                       UIActivityTypeCopyToPasteboard,
                                       UIActivityTypeAssignToContact,
                                       UIActivityTypeSaveToCameraRoll,
                                       UIActivityTypeAddToReadingList,
                                       UIActivityTypePostToFlickr,
                                       UIActivityTypePostToVimeo,
                                       UIActivityTypePostToTencentWeibo,
                                       UIActivityTypeAirDrop,
                                       UIActivityTypeOpenInIBooks];
    }
    
    return self;
}

- (WeiboActivity *)weiboActivity {
    
    CAL_GET_OBJECT(_weiboActivity);
    
    _weiboActivity = [[WeiboActivity alloc] init];
    
    return _weiboActivity;
}

@end
</code></pre>

<blockquote>
<p>这里和大家说说<strong><code>excludedActivityTypes</code></strong>这个属性, 这个属性其实是一个数组属性, 代表的是, 如果我们不需要系统的服务就可以给它赋值, 这样子<strong><code>UIActivityViewController</code></strong>就不会显示对应的服务, 我这里默认全部干掉, 一个服务都不需要, 当然如果需要干掉我们自定义的<strong><code>UIActivity</code></strong>, 也可以在这里写上.</p>

<p>还有一点, 就是我们给<strong><code>UIActivityViewController</code></strong>赋值自定义的<strong><code>UIActivity</code></strong></p>

<p>PS: 注意一点, 这个赋值只能在<strong><code>initWithActivityItems: applicationActivities:</code></strong>这个方法的<strong><code>applicationActivities:</code></strong>赋值, 而且只能在初始化的时候赋值, 一旦赋值之后就不能再修改了.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/9.png" alt="9  | center | 1080x0"/></p>

<hr/>

<h3 id="toc_6">调起UIActivityViewController</h3>

<blockquote>
<p>最重要的地方来了, 就是调起我们自定义的<strong><code>UIActivityController</code></strong>.</p>

<p>首先我们要在<strong><code>Main.storyboard</code></strong>中拖一个<strong><code>UIButton</code></strong>, 然后添加对应的代码.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/10.png" alt="10  | center | 1080x0"/></p>

<blockquote>
<p>代码: </p>
</blockquote>

<pre><code class="language-Objective-c">#import &quot;ViewController.h&quot;
#import &quot;UIActivityController.h&quot;

@interface ViewController ()

@property (nonatomic, strong) UIActivityController *activityController;

@end

@implementation ViewController

- (IBAction)popActivityController:(UIButton *)sender {
    
    [self presentViewController:self.activityController animated:YES completion:nil];
}

- (UIActivityController *)activityController {
    
    NSString *shareTitle = @&quot;分享的标题&quot;;
    UIImage *shareImage = [UIImage imageNamed:@&quot;ShareBundle.bundle/share_icon_1&quot;];
    
    if (!_activityController) {
        
        _activityController = [[UIActivityController alloc] initAspActivityControllerWithContent:@[shareTitle, shareImage]];
    }
    
    return _activityController;
}

@end
</code></pre>

<blockquote>
<p>最后我们运行一下看看效果</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/11.png" alt="10  | center | 720x0"/></p>

<blockquote>
<p>发现什么都没有, 肯定在喷我, 觉得我是在耍你们, 哈哈, 其实在这里我们少了一个方法没有添加, 回到我们自定义的<strong><code>WeiboActivity</code></strong>中, 添加上就OK了</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/12.png" alt="12  | center | 1080x0"/></p>

<blockquote>
<p>具体实现的代码:</p>
</blockquote>

<pre><code class="language-Objective-c">- (BOOL)canPerformWithActivityItems:(NSArray *)activityItems {
    
    if (activityItems.count &gt; 0) {
        
        return YES;
    }
    
    return NO;
}
</code></pre>

<blockquote>
<p>再来运行看看效果</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/13.png" alt="13  | center | 720x0"/></p>

<blockquote>
<p>好了, <strong><code>item</code></strong>出来了, 但好像有什么不对, 图标呢???!!! 为啥是灰色的? 楼主你耍我, 我要去爆你菊花!!!!!</p>

<p>别紧张, 在系统默认的<strong><code>UIActivityViewController</code></strong>中, 下面这部分是属于系统服务, 默认只会显示一个轮廓, 并不会显示整张图片, 下面我们把自定义的<strong><code>WeiboActivity</code></strong>显示图片的方法改改就好了.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/14.png" alt="14  | center | 1080x0"/></p>

<blockquote>
<p>代码:</p>
</blockquote>

<pre><code class="language-Objective-c">- (UIImage *)_activityImage {
    
    return [UIImage imageNamed:@&quot;ShareBundle.bundle/share_icon_1&quot;];
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/15.png" alt="15  | center | 720x0"/></p>

<blockquote>
<p>好了, 我的菊花保住了, 图标出来了, 把我吓了一身冷汗</p>

<p>图标出来了, 我们就要给这个<strong><code>item</code></strong>添加点击事件了, 做什么好呢, 总不可能让我去导个微信微博等SDK进来演示, 毕竟还要去申请<strong><code>AppID</code></strong>和<strong><code>AppKey</code></strong>呢, 我们来个弹框吧~~~</p>

<p>我一般喜欢写个<strong><code>Block</code></strong>把点击事件抛出去做处理, 这次我也不例外~~</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/16.png" alt="16  | center | 1080x0"/></p>

<blockquote>
<p>具体实现的代码:</p>
</blockquote>

<pre><code class="language-Objective-c">- (void)performActivity {
    [self activityDidFinish:YES];
    
    if (self.weiboBlock) {
        self.weiboBlock();
    }
}
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/17.png" alt="17  | center | 1080x0"/></p>

<blockquote>
<p>具体实现的代码: </p>
</blockquote>

<pre><code class="language-Objective-c">- (WeiboActivity *)weiboActivity {
    
    CAL_GET_OBJECT(_weiboActivity);
    
    _weiboActivity = [[WeiboActivity alloc] init];
    
    [_weiboActivity setWeiboBlock:^{
        
        UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;新浪微博&quot;
                                                            message:@&quot;分享至新浪微博&quot;
                                                           delegate:nil
                                                  cancelButtonTitle:@&quot;好的&quot;
                                                  otherButtonTitles:nil, nil];
        
        [alertView show];
    }];

    return _weiboActivity;
}
</code></pre>

<blockquote>
<p>PS: 由于我这里是做示范, 所以使用<strong><code>UIAlertView</code></strong>, 如果大家要在项目中使用的话, 尽量使用<strong><code>UIAlertController</code></strong>.</p>
</blockquote>

<hr/>

<h3 id="toc_7">最终效果</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/ActivityControllerDemo/master/Image-file/18.png" alt="15  | center | 720x0"/></p>

<hr/>

<h3 id="toc_8">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/ActivityControllerDemo/tree/master/UIActivityViewControllerDemo">https://github.com/CainRun/ActivityControllerDemo/tree/master/UIActivityViewControllerDemo</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：非脚本版本《模拟器与真机静态Framework合成教程》]]></title>
    <link href="https://cainrun.github.io/14729651532234.html"/>
    <updated>2016-09-04T12:59:13+08:00</updated>
    <id>https://cainrun.github.io/14729651532234.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>为了写这篇文章, 我翻查了许多资料, 都没有找到详细点的可参考资料, 外国的文章就不用说了, 光是看鸡肠就头晕了, 所以我自己总结了一些经验, 整理了一番, 决定分享出来, 希望大家喜欢</p>

<p><strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Framework</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p>在我们做<strong><code>iOS开发中</code></strong>, 有时候我们会自己动手写一些库, 方便自己去调用, 但是我们又不想这个库的内部实现代码被别人知道, 这个时候我们就需要把这个库打包成<strong><code>Framework</code></strong>或者是<strong><code>lib.a</code></strong>文件, 这里我们只做<strong><code>Framework</code></strong>的打包教程, <strong><code>lib.a</code></strong>的打包方式和<strong><code>Framework</code></strong>趋同差异, 如果有需要, 后面我再补上.</p>
</blockquote>

<hr/>

<h3 id="toc_2">创建静态包工程</h3>

<blockquote>
<p>在开始合成之前, 我们肯定是需要创建一个生成<strong><code>Framework</code></strong>的工程, 这里推荐用<strong><code>WorkSpace</code></strong>来创建, 因为可以方便我们去测试<strong><code>Framework</code></strong>库.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/1.png" alt="1 | center | 1080x0"/></p>

<blockquote>
<p>添加新的工程</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/2.png" alt="2 | center | 1080x0"/></p>

<blockquote>
<p>选择创建<strong><code>Cocoa Touch Framework</code></strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/3.png" alt="3 | center | 1080x0"/></p>

<blockquote>
<p>给<strong><code>Framework</code></strong>命名, 喜欢啥名字, 自己看着办呗, 我个人的习惯就是, 这个是什么库, 我就命名是啥, 如果是用在某个工程的话, 我就会以该工程的名字来命名</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/4.png" alt="4 | center | 1080x0"/></p>

<blockquote>
<p>创建完之后, 我们会看到<strong><code>Framework</code></strong>里有一个头文件, 头文件里有一堆不明所以的代码, 这个时候我们不需要管, 直接干掉它</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/5.png" alt="5 | center | 1080x0"/></p>

<blockquote>
<p>这样子, 我们就创建<strong><code>Framework</code></strong>完毕了, 下面让我们来创建一个测试类.</p>
</blockquote>

<hr/>

<h3 id="toc_3">添加测试类</h3>

<blockquote>
<p>给这个测试类, 添加一个类方法</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/6.png" alt="6 | cneter | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/7.png" alt="7 | cneter | 1080x0"/></p>

<blockquote>
<p>添加完测试类之后, 下面让我们来配置一下整个<strong><code>Framework</code></strong>工程, 让它同时支持模拟器和真机.</p>
</blockquote>

<hr/>

<h3 id="toc_4">配置静态包工程</h3>

<blockquote>
<p>Xcode默认是会把Framework变成Debug模式, 这时候我们需要去改成Release模式</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/8.png" alt="8 | cneter | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/9.png" alt="9 | cneter | 1080x0"/></p>

<blockquote>
<p>然后我们去配置项目工程, 首先我们来添加一个模拟器的支持</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/10.png" alt="10 | cneter | 1080x0"/></p>

<blockquote>
<p>修改Framework最低支持iOS的版本, 我这里最低支持的是iOS7</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/11.png" alt="11 | cneter | 1080x0"/></p>

<blockquote>
<p>把默认的动态库, 切换成静态库</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/12.png" alt="12 | cneter | 1080x0"/></p>

<blockquote>
<p>配置需要暴露的<strong><code>.h</code></strong>文件</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/13.png" alt="13 | cneter | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/14.png" alt="14 | cneter | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/15.png" alt="15 | cneter | 1080x0"/></p>

<blockquote>
<p>最后, 我们在<strong><code>Test.h</code></strong>中导入<strong><code>TestClass.h</code></strong>, 当然, 我们也不需要这么做, 因为我们已经在配置中暴露了<strong><code>TestClass.h</code></strong>文件, 所以不需要引用也是可以的</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/16.png" alt="16 | cneter | 1080x0"/></p>

<blockquote>
<p>这个时候, 我们先来测试一下能不能生成<strong><code>Framework</code></strong>库</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/17.png" alt="17 | cneter | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/18.png" alt="18 | cneter | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/19.png" alt="19 | cneter | 1080x0"/></p>

<blockquote>
<p>最终测试, 是成功生成<strong><code>Framework</code></strong>库的, 但这个是模拟器库, 如果你需要支持真机的话, 那么只要切换运行的选项就好了</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/20.png" alt="20 | center | 1080x0"/></p>

<blockquote>
<p>这时候我们再去查看文件夹, 就会有两个<strong><code>Framework</code></strong>文件夹了</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/21.png" alt="21 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_5">检测静态包</h3>

<blockquote>
<p>虽然我们把<strong><code>Framework</code></strong>都打包好了, 但是我们需要检测一下是否符合我们的需求, 这是我们要打开<strong><code>Terminal</code></strong>, 并且输入命令.</p>
</blockquote>

<pre><code>lipo -info (Framework二进制文件地址)
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/22.png" alt="22 | center | 1080x0"/></p>

<blockquote>
<p>检测真机Framework包</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/23.png" alt="23 | center | 1080x0"/></p>

<blockquote>
<p>检测模拟器Framework包</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/24.png" alt="24 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_6">合成真机与模拟器通用的静态包</h3>

<blockquote>
<p>前面做了那么多的事情, 就为了现在这一步, 就是将模拟器与真机两个Framework包合成一个通用的Framework包, 由于我这里没有通用的Shell脚本, 只能用最笨的办法合成两个包了, 下面让我们一起来看看.</p>

<p>打开终端输入合成命令<br/>
<code><br/>
lipo -create (真机Framework路径) (模拟器Framework路径) -output (真机/模拟器路径)<br/>
</code></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/25.png" alt="25 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/26.png" alt="26 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/27.png" alt="27 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/28.png" alt="28 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/29.png" alt="29 | center | 1080x0"/></p>

<blockquote>
<p>检测合成后的通用Framework, 只有看到<strong><code>armv7 arm64 i386 x86_64</code></strong>这四个同时存在, 才真正的合成成功</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/30.png" alt="30 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/31.png" alt="31 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_7">注意!!!!!</h3>

<blockquote>
<p>这里有一个注意事项, 有时候用<strong><code>lipo</code></strong>合成会报一个错误(我这里没有发现)</p>
</blockquote>

<pre><code>crun: error: active developer path (“/Applications/Xcode 2.app/Contents/Developer”) does not exist, use xcode-select --switch path/to/Xcode.app to specify the Xcode that you wish to use for command line developer tools (or see man xcode-select)
</code></pre>

<blockquote>
<p>这时候不要慌, 只要再输入下面的命令, 输入电脑密码后, 然后再次运行合成<strong><code>Framework</code></strong>的命令, 就可以合成了</p>
</blockquote>

<pre><code>sudo xcode-select -switch /Applications/Xcode.app/Contents/Developer
</code></pre>

<hr/>

<h3 id="toc_8">测试静态包</h3>

<blockquote>
<p>既然我们那么辛苦的合成了一个通用的<strong><code>Framework</code></strong>, 不用用, 怎么对得起我们的付出呢? 再次回到<strong><code>Workspace</code></strong>, 新建一个测试工程.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/32.png" alt="32 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/33.png" alt="33 | center | 1080x0"/></p>

<blockquote>
<p>注意, 创建测试工程的时候, 不要新建到<strong><code>Framework</code></strong>的工程内</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/34.png" alt="34 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/35.png" alt="35 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/36.png" alt="36 | center | 1080x0"/></p>

<blockquote>
<p>模拟器测试</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/37.png" alt="37 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/38.png" alt="38 | center | 1080x0"/></p>

<blockquote>
<p>真机测试</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/39.png" alt="39 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/NotAggregateFramework/images/40.png" alt="40 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_9">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CreateGeneralFramework">https://github.com/CainRun/CreateGeneralFramework</a></p>

<hr/>

<h3 id="toc_10">结束语</h3>

<blockquote>
<p>好啦, 教程到这里就结束了, 谢谢大家的耐心观看</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：Aggregate脚本版本《模拟器与真机静态Framework合成教程》]]></title>
    <link href="https://cainrun.github.io/14729646870605.html"/>
    <updated>2016-09-04T12:51:27+08:00</updated>
    <id>https://cainrun.github.io/14729646870605.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>为了写这篇文章, 我翻查了许多资料, 都没有找到详细点的可参考资料, 外国的文章就不用说了, 光是看鸡肠就头晕了, 所以我自己总结了一些经验, 整理了一番, 决定分享出来, 希望大家喜欢</p>

<p><strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>Aggregate-Framework</code><strong>如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<blockquote>
<p>之前我写了一个关于非<strong><code>Aggregate</code></strong>版本的<a href="https://cainrun.github.io/14729651532234.html">模拟器与真机静态Framework合成教程</a>, 但那个实在是太麻烦的, 所以我又出墙翻了一些歪果仁写的博客, 果然是世上无难事只怕有心人, 终于被我找到合适的<strong><code>Shell</code></strong>脚本了</p>
</blockquote>

<hr/>

<h3 id="toc_2">创建静态包工程</h3>

<blockquote>
<p>新建一个Workpace文件</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/0.png" alt="0 | center | 1080x0"/></p>

<blockquote>
<p>新建Cocoa Touch Framework工程</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/1.png" alt="1 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/2.png" alt="2 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/3.png" alt="3 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/4.png" alt="4 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_3">添加测试类</h3>

<blockquote>
<p>添加一个测试类<strong><code>TestTwoClass</code></strong></p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/5.png" alt="5 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_4">配置静态包工程</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/6.png" alt="6 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/7.png" alt="7 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/8.png" alt="8 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/9.png" alt="9 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/10.png" alt="10 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/11.png" alt="11 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/12.png" alt="12 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_5">分别生成真机与模拟器的静态包</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/13.png" alt="13 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/14.png" alt="14 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_6">创建脚本选项</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/15.png" alt="15 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/16.png" alt="16 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/17.png" alt="17 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_7">配置脚本选项</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/18.png" alt="18 | center | 1080x0"/></p>

<blockquote>
<p>打开<strong><code>Run Script</code></strong>之后, 输入以下的脚本, 就可以自动合成通用的<strong><code>Framework</code></strong>库了</p>

<p>PS: 脚本是我在<strong><code>Google</code></strong>上搜到的, 详细是谁写的, 我也不清楚, 很感谢这个作者提供的脚本</p>
</blockquote>

<pre><code class="language-shell">if [ &quot;${ACTION}&quot; = &quot;build&quot; ]
then
INSTALL_DIR=${SRCROOT}/Products/${PROJECT_NAME}.framework

DEVICE_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphoneos/${PROJECT_NAME}.framework

SIMULATOR_DIR=${BUILD_ROOT}/${CONFIGURATION}-iphonesimulator/${PROJECT_NAME}.framework


if [ -d &quot;${INSTALL_DIR}&quot; ]
then
rm -rf &quot;${INSTALL_DIR}&quot;
fi

mkdir -p &quot;${INSTALL_DIR}&quot;

cp -R &quot;${DEVICE_DIR}/&quot; &quot;${INSTALL_DIR}/&quot;
#ditto &quot;${DEVICE_DIR}/Headers&quot; &quot;${INSTALL_DIR}/Headers&quot;

lipo -create &quot;${DEVICE_DIR}/${PROJECT_NAME}&quot; &quot;${SIMULATOR_DIR}/${PROJECT_NAME}&quot; -output &quot;${INSTALL_DIR}/${PROJECT_NAME}&quot;

#open &quot;${DEVICE_DIR}&quot;
#open &quot;${SRCROOT}/Products&quot;
fi
</code></pre>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/19.png" alt="19 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/20.png" alt="20 | center | 1080x0"/></p>

<blockquote>
<p>这里逮到一个错误, 不要慌, 因为我们之前是用<strong><code>Release</code></strong>模式的, 只要把<strong><code>Aggregate</code></strong>切换到<strong><code>Release</code></strong>模式, 再运行就可以了</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/21.png" alt="21 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/22.png" alt="22 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/23.png" alt="23 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/24.png" alt="24 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_8">检测静态包</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/25.png" alt="25 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/26.png" alt="26 | center | 1080x0"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/27.png" alt="27 | center | 1080x0"/></p>

<hr/>

<h3 id="toc_9">测试静态包</h3>

<blockquote>
<p>测试的方法和<a href="https://cainrun.github.io/14729651532234.html">模拟器与真机静态Framework合成教程</a>这里面的测试方法一样, 这样就不多做解释了</p>

<p>但是这里还有一点需要注意一些, 由于我们刚刚在打包的时候, 是把<strong><code>TestTwoClass.h</code></strong>是丢到<strong><code>Private</code></strong>里面去的, 哪怕我们已经把头文件丢到<strong><code>TestTwo.h</code></strong>中, 然后再引用<strong><code>TestTwo.h</code></strong>, 依旧是没办法去调用<strong><code>TestTwoClass</code></strong>内部的任何东西, 怎么办呢?</p>

<p>我们只要去改改导入的头文件就可以了, 比如:</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/CreateGeneralFramework/master/AggregateFramework/images/28.png" alt="28 | center | 1080x0"/></p>

<blockquote>
<p>PS: 这种方式只是我们来玩玩而已, 基本上我们都会吧<strong><code>.h</code></strong>文件放到<strong><code>public</code></strong>中</p>
</blockquote>

<hr/>

<h3 id="toc_10">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/CreateGeneralFramework">https://github.com/CainRun/CreateGeneralFramework</a></p>

<hr/>

<h3 id="toc_11">结束语</h3>

<blockquote>
<p>好啦, 教程到这里就结束了, 谢谢大家的耐心观看</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[玩转iOS开发：《iOS设计模式 — 观察者模式》]]></title>
    <link href="https://cainrun.github.io/14719369255829.html"/>
    <updated>2016-08-23T15:22:05+08:00</updated>
    <id>https://cainrun.github.io/14719369255829.html</id>
    <content type="html"><![CDATA[
<h3 id="toc_0">作者感言</h3>

<blockquote>
<p>这几天在捣鼓新项目, 在用通知中心的时候突然想到自己用了那么久的通知中心, 为啥不自己动手实现一个呢? 说干就干, 于是乎就研究通知中心的原理, 当然包括<strong><code>KVO</code></strong>, 这些都是基于<strong><code>观察者模式</code></strong>实现的, 既然知道了原理, 我们就Do It!!!</p>

<p><strong><font color=purple>最后:</font></strong><br/>
<strong><font color=purple>如果你有更好的建议或者对这篇文章有不满的地方, 请联系我, 我会参考你们的意见再进行修改, 联系我时, 请备注</strong><code>工厂模式</code><strong>, 如果觉得好的话, 希望大家也可以打赏一下~嘻嘻~祝大家学习愉快~谢谢~</font></strong></p>
</blockquote>

<span id="more"></span><!-- more -->

<hr/>

<h3 id="toc_1">简介</h3>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/ObserverUML.jpg" alt="ObserverUML"/></p>

<blockquote>
<p>说起观察模式, 其实可以举酱紫的一个例子, 就拿实验对象来说明, 研究者是<strong><code>观察者</code></strong>, 小白鼠是<strong><code>被观察者</code></strong>, 当研究者往小白鼠身上做某些实验的时候, 小白鼠会产生某些反应, 而研究者就会记录以及反馈观察对应的现象, 这种情况就叫做<strong><code>观察者模式</code></strong>.</p>

<p>说那么多废话, 直接上代码演示吧~~</p>
</blockquote>

<hr/>

<h3 id="toc_2">新建工程</h3>

<blockquote>
<p>依旧打开我们之前的那个<strong><code>workSpace</code></strong>工程, 然后新建一个<strong><code>ObserverPattern</code></strong>工程.</p>

<p>这里我们就拿微信公众号来举个例子, 首先我们要有一个微信公众号中心, 方便我们用来寻找我们想要的公众号.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/1.png" alt="1"/></p>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/2.png" alt="2"/></p>

<hr/>

<h3 id="toc_3">针对接口编程</h3>

<blockquote>
<p>这里普及一个思想, 就是<strong><code>针对接口编程</code></strong>, 说起<strong><code>针对接口编程</code></strong>, 估计会有一些道友会有迷惑, 啥是<strong><code>针对接口编程</code></strong>? 其实在我们日常开发当中, 我们就已经做到了<strong><code>针对接口编程</code></strong>, 只是我们本身没有意识到, 其实所谓的<strong><code>针对接口编程</code></strong>, 就是我们在写模块或者是在写SDK的时候, 我们会先设计对外公开的API, 然后再内部实现对应的逻辑, 这就是<strong><code>针对接口编程</code></strong>.</p>

<p>这里有一篇我觉得不错的文章<a href="http://blog.chinaunix.net/uid-20478213-id-1942005.html">针对接口编程</a>, 如果觉得不好, 可以去吐槽博主, 这我是不会反对的~</p>

<p>现在我们先去声明一些我们需要用到的API先.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/3.png" alt="3"/></p>

<hr/>

<h3 id="toc_4">限制用户</h3>

<blockquote>
<p>虽然我们声明了一些接口, 但其实是还不够的, 因为公众号并不知道你是否有没有订阅, 如果没有订阅的话, 公众号发出来的消息, 你不可能会收到, 所以在这里我们需要声明一个<strong><code>Protocol</code></strong>, 用来限制<br/>
用户, 因为订阅号所发送的消息不是全部用户都能接收的, 只要订阅了该订阅号的用户才能收到订阅号所发出来的消息.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/4.png" alt="4"/></p>

<blockquote>
<p>记得要把对象换一下, 换成了遵守了改协议的对象才能去接收消息</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/5.png" alt="5"/></p>

<hr/>

<h3 id="toc_5">实现内部方法</h3>

<blockquote>
<p>现在我们对应的接口和限制用户的协议都已经写好了, 接下来我们就要去实现<strong><code>PublicNumberCenter</code></strong>里的方法, 这样子我们就可以完完整整的实现一个观察者模式了.</p>

<p>由于通知中心是属于单例, 首先我们肯定是要来实现一下单例模式</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/6.png" alt="6"/></p>

<blockquote>
<p>实现完通知中心之后, 我们就要来实现内部的方法, 这样子我们要的通知中心就完成了</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/7.png" alt="7"/></p>

<hr/>

<h3 id="toc_6">调用自定义通知中心</h3>

<blockquote>
<p>写了那么久, 现在我们来尝试调用一下通知中心, 这里我们就简单实现一下, 就让<strong><code>ViewController</code></strong>成为用户, 遵守<strong><code>PublicNumberProtocol</code></strong>就好了.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/CainRun/DesignPattern/master/ObserverPattern/ObserverPattern%E8%AF%B4%E6%98%8E/8.png" alt="8"/></p>

<hr/>

<h3 id="toc_7">工程地址</h3>

<p>项目地址: <a href="https://github.com/CainRun/DesignPattern">https://github.com/CainRun/DesignPattern</a></p>

]]></content>
  </entry>
  
</feed>
